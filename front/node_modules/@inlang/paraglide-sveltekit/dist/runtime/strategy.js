import { bestMatch, resolveRoute, } from "@inlang/paraglide-js/internal/adapter-utils";
export function PrefixStrategy(availableLanguageTags, defaultLanguageTag, translations, matchers, prefixDefaultLanguage) {
    function getLanguageFromLocalisedPath(localisedPath) {
        const segments = localisedPath.split("/");
        const maybeLang = segments[1];
        if (availableLanguageTags.includes(maybeLang) &&
            (prefixDefaultLanguage === "always" || maybeLang !== defaultLanguageTag)) {
            return maybeLang;
        }
        if (prefixDefaultLanguage === "never")
            return defaultLanguageTag;
        else
            return undefined;
    }
    function getLocalisedPath(canonicalPath, languageTag) {
        const trailingSlash = canonicalPath.endsWith("/") && canonicalPath !== "/";
        canonicalPath = trailingSlash ? canonicalPath.slice(0, -1) : canonicalPath;
        let translatedPath = turnIntoTranslatedPath(canonicalPath, languageTag, translations, matchers);
        if (trailingSlash) {
            translatedPath += "/";
        }
        if (prefixDefaultLanguage === "always" || languageTag !== defaultLanguageTag) {
            translatedPath = `/${languageTag}${translatedPath}`;
        }
        return translatedPath;
    }
    function getCanonicalPath(localisedPath, languageTag) {
        const trailingSlahsBefore = localisedPath.endsWith("/") && localisedPath !== "/";
        if (prefixDefaultLanguage === "always" || languageTag !== defaultLanguageTag) {
            localisedPath = localisedPath.replace(`/${languageTag}`, "") || "/";
        }
        const trailingSlash = trailingSlahsBefore;
        localisedPath = trailingSlash ? localisedPath.slice(0, -1) : localisedPath;
        let canonicalPath = turnIntoCanonicalPath(localisedPath, languageTag, translations, matchers);
        if (trailingSlash) {
            canonicalPath += "/";
        }
        return canonicalPath;
    }
    return {
        getLanguageFromLocalisedPath,
        getLocalisedPath,
        getCanonicalPath,
    };
}
/**
 * Resolves the canonical path from a translated path
 * @param translatedPath The translated path WITHOUT the language or base
 */
function turnIntoCanonicalPath(translatedPath, lang, translations, matchers) {
    for (const [canonicalPathDefinition, translationsForPath] of Object.entries(translations)) {
        if (!(lang in translationsForPath))
            continue;
        const translatedPathDefinition = translationsForPath[lang];
        if (!translatedPathDefinition)
            continue;
        const match = bestMatch(translatedPath, [translatedPathDefinition], matchers);
        if (!match)
            continue;
        // return the resolved canonical path
        return resolveRoute(canonicalPathDefinition, match.params);
    }
    // fall back to translated path if no canonical path is found
    return translatedPath;
}
function turnIntoTranslatedPath(canonicalPath, lang, translations, matchers) {
    const match = bestMatch(canonicalPath, Object.keys(translations), matchers);
    if (!match)
        return canonicalPath;
    const translationsForPath = translations[match.id];
    if (!translationsForPath)
        return canonicalPath;
    const translatedPath = translationsForPath[lang];
    if (!translatedPath)
        return canonicalPath;
    // return the translated path
    return resolveRoute(translatedPath, match.params);
}
