import type { Repository } from "@lix-js/client";
/**
 * One step in a CLI chain.
 * Defines which types the context needs to extend and how it extends the context
 *
 * Cli Steps can be chained to slowly build up the context over time
 *
 * @example
 * ```ts
 * const step1:  CliStep<unknown, { foo: string }> = async (ctx) => {
 *    return {...ctx, foo: "hello" }
 * }
 *
 * const step2: CliStep<{ foo: string }, { bar: number }> = async (ctx) => {
 *   return { ...ctx, bar: 42 }
 * }
 *
 * const initial = { baz: "baz" } as const;
 * const ctx1 = await step1(initial);
 * const ctx2 = await step2(ctx1);
 *
 * ctx2 // Has type { foo: string, bar: number, baz: "baz" }
 * ```
 */
export type CliStep<In extends object, Out> = <Ctx extends In>(ctx: Ctx) => Promise<Ctx & Out>;
type CliStepIn<Step extends CliStep<any, any>> = Step extends CliStep<infer In, any> ? In : never;
type CliStepOut<Step extends CliStep<any, any>> = Step extends CliStep<any, infer Out> ? Out : never;
type Pair<Step1 extends CliStep<any, any>, Step2 extends CliStep<CliStepIn<Step1>, any>> = CliStep<CliStepIn<Step1>, CliStepOut<Step1> & CliStepOut<Step2>>;
export declare function pair<Step1 extends CliStep<any, any>, Step2 extends CliStep<CliStepIn<Step1>, any>>(step1: Step1, step2: Step2): Pair<Step1, Step2>;
export declare function succeedOrElse<T extends Promise<unknown>, U>(promise: T, orElse: U): Promise<T | U>;
export declare function normalizePath(id: string): string;
export declare function findFile(args: {
    candidates: string[];
    base: string;
    fs: Repository["nodeishFs"];
}): Promise<string | undefined>;
export declare function fileExists(fs: Repository["nodeishFs"], path: string): Promise<boolean>;
export {};
//# sourceMappingURL=utils.d.ts.map