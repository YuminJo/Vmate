import { parse } from "svelte/compiler";
import MagicString from "magic-string";
import { shouldApply } from "./precheck.js";
import { rewrite } from "./rewrite.js";
const TRANSLATIONS = {
    a: [
        {
            attribute_name: "href",
            lang_attribute_name: "hreflang",
        },
    ],
    form: [
        {
            attribute_name: "action",
        },
    ],
    button: [
        {
            attribute_name: "formaction",
        },
    ],
};
// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function preprocessor(_config) {
    return {
        name: "@inlang/paraglide-sveltekit",
        markup: ({ filename, content }) => {
            const NOOP = { code: content };
            //I dont' know when this would happen, but it's better to be safe than sorry
            if (!filename)
                return NOOP;
            //dont' process components owned by the framework
            if (filename.includes(".svelte-kit"))
                return NOOP;
            if (content.includes("<ParaglideJS") &&
                content.match(/<a\b[^>]*>.*?<\/a\s*>|<a\b[^>]*\/>/g)) {
                console.warn("[paraglide] `<a>` tags in the same file as `<ParaglideJS>` won't be translated.\nConsider moving it into another component.\n" +
                    filename);
            }
            //Run quick checks to see if preprocessing should be applied - skip parsing if not
            if (!shouldApply(content, TRANSLATIONS))
                return NOOP;
            //Parse the file
            let root;
            try {
                root = parse(content);
            }
            catch (error) {
                console.error(`[@inlang/paraglide-sveltekit] Failed to parse ${filename}. Link translations were NOT applied.`, error);
                return NOOP;
            }
            const code = new MagicString(content);
            const passResult = rewrite({
                root,
                code,
                originalCode: content,
                translations: TRANSLATIONS,
            });
            const before = new Set(passResult.scriptAdditions?.before);
            const after = new Set(passResult.scriptAdditions?.after);
            //Inject any imports that were added by the passes
            modifyScriptTag(root, code, { before, after });
            //Generate the code and map
            const map = code.generateMap({ hires: true });
            return { code: code.toString(), map };
        },
    };
}
function modifyScriptTag(root, code, additions) {
    const before = additions.before ? [...additions.before] : [];
    const after = additions.after ? [...additions.after] : [];
    if (!root.instance) {
        code.prepend("<script>\n" + before.join("\n") + "\n" + after.join("\n") + "</script>\n");
    }
    else {
        //@ts-ignore
        const scriptStart = root.instance.content.start;
        //@ts-ignore
        const scriptEnd = root.instance.content.end;
        code.appendLeft(scriptStart, "\n" + before.join("\n") + "\n");
        code.appendRight(scriptEnd, "\n" + after.join("\n") + "\n");
    }
}
