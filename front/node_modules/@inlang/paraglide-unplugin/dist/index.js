import { createUnplugin } from "unplugin";
import { Message, ProjectSettings, loadProject, normalizeMessage, } from "@inlang/sdk";
import { openRepository, findRepoRoot } from "@lix-js/client";
import path from "node:path";
import fs from "node:fs/promises";
import { compile, writeOutput, Logger, classifyProjectErrors } from "@inlang/paraglide-js/internal";
import crypto from "node:crypto";
const PLUGIN_NAME = "unplugin-paraglide";
const VITE_BUILD_PLUGIN_NAME = "unplugin-paraglide-vite-virtual-message-modules";
const isWindows = typeof process !== "undefined" && process.platform === "win32";
export const paraglide = createUnplugin((config) => {
    const options = {
        silent: false,
        ...config,
    };
    const projectPath = path.resolve(process.cwd(), options.project);
    const outputDirectory = path.resolve(process.cwd(), options.outdir);
    let normalizedOutdir = outputDirectory.replaceAll("\\", "/");
    if (!normalizedOutdir.endsWith("/"))
        normalizedOutdir = normalizedOutdir + "/";
    const logger = new Logger({ silent: options.silent, prefix: true });
    //Keep track of how many times we've compiled
    let numCompiles = 0;
    let previousMessagesHash = undefined;
    let virtualModuleOutput = {};
    async function triggerCompile(messages, settings, projectId) {
        const currentMessagesHash = hashMessages(messages ?? [], settings);
        if (currentMessagesHash === previousMessagesHash)
            return;
        if (messages.length === 0) {
            logger.warn("No messages found - Skipping compilation");
            return;
        }
        logMessageChange();
        previousMessagesHash = currentMessagesHash;
        const [regularOutput, messageModulesOutput] = await Promise.all([
            compile({
                messages,
                settings,
                outputStructure: "regular",
                projectId,
            }),
            compile({ messages, settings, outputStructure: "message-modules", projectId }),
        ]);
        virtualModuleOutput = messageModulesOutput;
        const fsOutput = regularOutput;
        await writeOutput(outputDirectory, fsOutput, fs);
        numCompiles++;
    }
    function logMessageChange() {
        if (!logger)
            return;
        if (options.silent)
            return;
        if (numCompiles === 0) {
            logger.info(`Compiling Messages into ${options.outdir}`);
        }
        if (numCompiles >= 1) {
            logger.info(`Messages changed - Recompiling into ${options.outdir}`);
        }
    }
    let project = undefined;
    async function getProject() {
        if (project)
            return project;
        const repoRoot = await findRepoRoot({ nodeishFs: fs, path: projectPath });
        const repo = await openRepository(repoRoot || "file://" + process.cwd(), {
            nodeishFs: fs,
        });
        project = await loadProject({
            appId: "library.inlang.paraglideJs",
            projectPath: path.resolve(process.cwd(), options.project),
            repo,
        });
        return project;
    }
    // if build
    return [
        {
            name: PLUGIN_NAME,
            enforce: "pre",
            async buildStart() {
                const project = await getProject();
                const initialMessages = project.query.messages.getAll();
                const settings = project.settings();
                await triggerCompile(initialMessages, settings, project.id);
                project.errors.subscribe((errors) => {
                    if (errors.length === 0)
                        return;
                    const { fatalErrors, nonFatalErrors } = classifyProjectErrors(errors);
                    for (const error of nonFatalErrors) {
                        logger.warn(error.message);
                    }
                    for (const error of fatalErrors) {
                        if (error instanceof Error) {
                            logger.error(error.message); // hide the stack trace
                        }
                        else {
                            logger.error(error);
                        }
                    }
                });
                let numInvocations = 0;
                project.query.messages.getAll.subscribe((messages) => {
                    numInvocations++;
                    if (numInvocations === 1)
                        return;
                    triggerCompile(messages, project.settings(), project.id);
                });
            },
            webpack(compiler) {
                //we need the compiler to run before the build so that the message-modules will be present
                //In the other bundlers `buildStart` already runs before the build. In webpack it's a race condition
                compiler.hooks.beforeRun.tapPromise(PLUGIN_NAME, async () => {
                    const project = await getProject();
                    await triggerCompile(project.query.messages.getAll(), project.settings(), project.id);
                    console.info(`Compiled Messages into ${options.outdir}`);
                });
            },
        },
        {
            name: VITE_BUILD_PLUGIN_NAME,
            vite: {
                apply: "build",
                resolveId(id, importer) {
                    // resolve relative imports inside the output directory
                    // the importer is alwazs normalized
                    if (importer?.startsWith(normalizedOutdir)) {
                        const dirname = path.dirname(importer).replaceAll("\\", "/");
                        if (id.startsWith(dirname))
                            return id;
                        if (isWindows) {
                            const resolvedPath = path
                                .resolve(dirname.replaceAll("/", "\\"), id.replaceAll("/", "\\"))
                                .replaceAll("\\", "/");
                            return resolvedPath;
                        }
                        const resolvedPath = path.resolve(dirname, id);
                        return resolvedPath;
                    }
                    return undefined;
                },
                load(id) {
                    id = id.replaceAll("\\", "/");
                    //if it starts with the outdir use the paraglideOutput virtual modules instead
                    if (id.startsWith(normalizedOutdir)) {
                        const internal = id.slice(normalizedOutdir.length);
                        const resolved = virtualModuleOutput[internal];
                        return resolved;
                    }
                    return undefined;
                },
            },
        },
    ];
});
export function hashMessages(messages, settings) {
    const normalizedMessages = messages
        .map(normalizeMessage)
        .sort((a, b) => a.id.localeCompare(b.id, "en"));
    try {
        const hash = crypto.createHash("sha256");
        hash.update(JSON.stringify(normalizedMessages));
        hash.update(JSON.stringify(settings));
        return hash.digest("hex");
    }
    catch (e) {
        return crypto.randomUUID();
    }
}
//# sourceMappingURL=index.js.map