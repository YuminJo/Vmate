import { LanguageTag } from "@inlang/language-tag";
import { Type } from "@sinclair/typebox";
export const Text = Type.Object({
    type: Type.Literal("Text"),
    value: Type.String(),
});
export const VariableReference = Type.Object({
    type: Type.Literal("VariableReference"),
    name: Type.String(),
});
export const Expression = Type.Union([VariableReference]);
export const Pattern = Type.Array(Type.Union([Text, Expression]));
export const Variant = Type.Object({
    languageTag: LanguageTag,
    /**
     * The number of keys in each variant match MUST equal the number of expressions in the selectors.
     *
     * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
     */
    // a match can always only be string-based because a string is what is rendered to the UI
    match: Type.Array(Type.String()),
    pattern: Pattern,
});
export const Message = Type.Object({
    id: Type.String(),
    alias: Type.Record(Type.String(), Type.String()),
    /**
     * The order in which the selectors are placed determines the precedence of patterns.
     */
    selectors: Type.Array(Expression),
    variants: Type.Array(Variant),
});
