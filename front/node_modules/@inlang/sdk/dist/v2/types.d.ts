import { type Static } from "@sinclair/typebox";
/**
 * Follows the IETF BCP 47 language tag schema.
 *
 * @see https://www.ietf.org/rfc/bcp/bcp47.txt
 * @see https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
 */
export type LanguageTag = Static<typeof LanguageTag>;
/**
 * Follows the IETF BCP 47 language tag schema with modifications.
 * @see REAMDE.md file for more information on the validation.
 */
export declare const pattern = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
export declare const LanguageTag: import("@sinclair/typebox").TString;
export type Literal = Static<typeof Literal>;
export declare const Literal: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"literal">;
    value: import("@sinclair/typebox").TString;
}>;
/**
 * A (text) element that is translatable and rendered to the UI.
 */
export type Text = Static<typeof Text>;
export declare const Text: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"text">;
    value: import("@sinclair/typebox").TString;
}>;
export type VariableReference = Static<typeof VariableReference>;
export declare const VariableReference: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"variable">;
    name: import("@sinclair/typebox").TString;
}>;
export type Option = Static<typeof Option>;
export declare const Option: import("@sinclair/typebox").TObject<{
    name: import("@sinclair/typebox").TString;
    value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"literal">;
        value: import("@sinclair/typebox").TString;
    }>, import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"variable">;
        name: import("@sinclair/typebox").TString;
    }>]>;
}>;
export type FunctionAnnotation = Static<typeof FunctionAnnotation>;
export declare const FunctionAnnotation: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"function">;
    name: import("@sinclair/typebox").TString;
    options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        name: import("@sinclair/typebox").TString;
        value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"literal">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"variable">;
            name: import("@sinclair/typebox").TString;
        }>]>;
    }>>;
}>;
/**
 * An expression is a reference to a variable or a function.
 *
 * Think of expressions as elements that are rendered to a
 * text value during runtime.
 */
export type Expression = Static<typeof Expression>;
export declare const Expression: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"expression">;
    arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"literal">;
        value: import("@sinclair/typebox").TString;
    }>, import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"variable">;
        name: import("@sinclair/typebox").TString;
    }>]>;
    annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"function">;
        name: import("@sinclair/typebox").TString;
        options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            name: import("@sinclair/typebox").TString;
            value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
        }>>;
    }>>;
}>;
/**
 * A pattern is a sequence of elements that comprise
 * a message that is rendered to the UI.
 */
export type Pattern = Static<typeof Pattern>;
export declare const Pattern: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"text">;
    value: import("@sinclair/typebox").TString;
}>, import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"expression">;
    arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"literal">;
        value: import("@sinclair/typebox").TString;
    }>, import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"variable">;
        name: import("@sinclair/typebox").TString;
    }>]>;
    annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"function">;
        name: import("@sinclair/typebox").TString;
        options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            name: import("@sinclair/typebox").TString;
            value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
        }>>;
    }>>;
}>]>>;
/**
 * A variant contains a pattern that is rendered to the UI.
 */
export type Variant = Static<typeof Variant>;
export declare const Variant: import("@sinclair/typebox").TObject<{
    /**
     * The number of keys in each variant match MUST equal the number of expressions in the selectors.
     *
     * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
     */
    match: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TString>;
    pattern: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"text">;
        value: import("@sinclair/typebox").TString;
    }>, import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"expression">;
        arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"literal">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"variable">;
            name: import("@sinclair/typebox").TString;
        }>]>;
        annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"function">;
            name: import("@sinclair/typebox").TString;
            options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                name: import("@sinclair/typebox").TString;
                value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
            }>>;
        }>>;
    }>]>>;
}>;
export type InputDeclaration = Static<typeof InputDeclaration>;
export declare const InputDeclaration: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"input">;
    name: import("@sinclair/typebox").TString;
    value: import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"expression">;
        arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"literal">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"variable">;
            name: import("@sinclair/typebox").TString;
        }>]>;
        annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"function">;
            name: import("@sinclair/typebox").TString;
            options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                name: import("@sinclair/typebox").TString;
                value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
            }>>;
        }>>;
    }>;
}>;
export type Declaration = Static<typeof Declaration>;
export declare const Declaration: import("@sinclair/typebox").TObject<{
    type: import("@sinclair/typebox").TLiteral<"input">;
    name: import("@sinclair/typebox").TString;
    value: import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"expression">;
        arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"literal">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"variable">;
            name: import("@sinclair/typebox").TString;
        }>]>;
        annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"function">;
            name: import("@sinclair/typebox").TString;
            options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                name: import("@sinclair/typebox").TString;
                value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
            }>>;
        }>>;
    }>;
}>;
export type Message = Static<typeof Message>;
export declare const Message: import("@sinclair/typebox").TObject<{
    locale: import("@sinclair/typebox").TString;
    declarations: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"input">;
        name: import("@sinclair/typebox").TString;
        value: import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"expression">;
            arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
            annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"function">;
                name: import("@sinclair/typebox").TString;
                options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                    name: import("@sinclair/typebox").TString;
                    value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"literal">;
                        value: import("@sinclair/typebox").TString;
                    }>, import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"variable">;
                        name: import("@sinclair/typebox").TString;
                    }>]>;
                }>>;
            }>>;
        }>;
    }>>;
    /**
     * The order in which the selectors are placed determines the precedence of patterns.
     */
    selectors: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        type: import("@sinclair/typebox").TLiteral<"expression">;
        arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"literal">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"variable">;
            name: import("@sinclair/typebox").TString;
        }>]>;
        annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"function">;
            name: import("@sinclair/typebox").TString;
            options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                name: import("@sinclair/typebox").TString;
                value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
            }>>;
        }>>;
    }>>;
    variants: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        /**
         * The number of keys in each variant match MUST equal the number of expressions in the selectors.
         *
         * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
         */
        match: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TString>;
        pattern: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"text">;
            value: import("@sinclair/typebox").TString;
        }>, import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"expression">;
            arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
            annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"function">;
                name: import("@sinclair/typebox").TString;
                options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                    name: import("@sinclair/typebox").TString;
                    value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"literal">;
                        value: import("@sinclair/typebox").TString;
                    }>, import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"variable">;
                        name: import("@sinclair/typebox").TString;
                    }>]>;
                }>>;
            }>>;
        }>]>>;
    }>>;
}>;
export type MessageBundle = Static<typeof MessageBundle>;
export declare const MessageBundle: import("@sinclair/typebox").TObject<{
    id: import("@sinclair/typebox").TString;
    alias: import("@sinclair/typebox").TRecord<import("@sinclair/typebox").TString, import("@sinclair/typebox").TString>;
    messages: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
        locale: import("@sinclair/typebox").TString;
        declarations: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"input">;
            name: import("@sinclair/typebox").TString;
            value: import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"expression">;
                arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
                annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"function">;
                    name: import("@sinclair/typebox").TString;
                    options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                        name: import("@sinclair/typebox").TString;
                        value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"literal">;
                            value: import("@sinclair/typebox").TString;
                        }>, import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"variable">;
                            name: import("@sinclair/typebox").TString;
                        }>]>;
                    }>>;
                }>>;
            }>;
        }>>;
        /**
         * The order in which the selectors are placed determines the precedence of patterns.
         */
        selectors: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"expression">;
            arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
            annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"function">;
                name: import("@sinclair/typebox").TString;
                options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                    name: import("@sinclair/typebox").TString;
                    value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"literal">;
                        value: import("@sinclair/typebox").TString;
                    }>, import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"variable">;
                        name: import("@sinclair/typebox").TString;
                    }>]>;
                }>>;
            }>>;
        }>>;
        variants: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            /**
             * The number of keys in each variant match MUST equal the number of expressions in the selectors.
             *
             * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
             */
            match: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TString>;
            pattern: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"text">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"expression">;
                arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
                annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"function">;
                    name: import("@sinclair/typebox").TString;
                    options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                        name: import("@sinclair/typebox").TString;
                        value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"literal">;
                            value: import("@sinclair/typebox").TString;
                        }>, import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"variable">;
                            name: import("@sinclair/typebox").TString;
                        }>]>;
                    }>>;
                }>>;
            }>]>>;
        }>>;
    }>>;
}>;
/**
 * A MessageSlot is a placeholder for a message with a locale.
 * This is useful to avoid merge conflicts when translations are added.
 */
export type MessageSlot = Static<typeof MessageSlot>;
export declare const MessageSlot: import("@sinclair/typebox").TObject<{
    locale: import("@sinclair/typebox").TString;
    slot: import("@sinclair/typebox").TLiteral<true>;
}>;
export type MessageBundleWithSlots = Static<typeof MessageBundleWithSlots>;
export declare const MessageBundleWithSlots: import("@sinclair/typebox").TObject<{
    id: import("@sinclair/typebox").TString;
    alias: import("@sinclair/typebox").TRecord<import("@sinclair/typebox").TString, import("@sinclair/typebox").TString>;
    messages: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
        locale: import("@sinclair/typebox").TString;
        declarations: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"input">;
            name: import("@sinclair/typebox").TString;
            value: import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"expression">;
                arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
                annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"function">;
                    name: import("@sinclair/typebox").TString;
                    options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                        name: import("@sinclair/typebox").TString;
                        value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"literal">;
                            value: import("@sinclair/typebox").TString;
                        }>, import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"variable">;
                            name: import("@sinclair/typebox").TString;
                        }>]>;
                    }>>;
                }>>;
            }>;
        }>>;
        /**
         * The order in which the selectors are placed determines the precedence of patterns.
         */
        selectors: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            type: import("@sinclair/typebox").TLiteral<"expression">;
            arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"literal">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"variable">;
                name: import("@sinclair/typebox").TString;
            }>]>;
            annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"function">;
                name: import("@sinclair/typebox").TString;
                options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                    name: import("@sinclair/typebox").TString;
                    value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"literal">;
                        value: import("@sinclair/typebox").TString;
                    }>, import("@sinclair/typebox").TObject<{
                        type: import("@sinclair/typebox").TLiteral<"variable">;
                        name: import("@sinclair/typebox").TString;
                    }>]>;
                }>>;
            }>>;
        }>>;
        variants: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
            /**
             * The number of keys in each variant match MUST equal the number of expressions in the selectors.
             *
             * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
             */
            match: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TString>;
            pattern: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"text">;
                value: import("@sinclair/typebox").TString;
            }>, import("@sinclair/typebox").TObject<{
                type: import("@sinclair/typebox").TLiteral<"expression">;
                arg: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"literal">;
                    value: import("@sinclair/typebox").TString;
                }>, import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"variable">;
                    name: import("@sinclair/typebox").TString;
                }>]>;
                annotation: import("@sinclair/typebox").TOptional<import("@sinclair/typebox").TObject<{
                    type: import("@sinclair/typebox").TLiteral<"function">;
                    name: import("@sinclair/typebox").TString;
                    options: import("@sinclair/typebox").TArray<import("@sinclair/typebox").TObject<{
                        name: import("@sinclair/typebox").TString;
                        value: import("@sinclair/typebox").TUnion<[import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"literal">;
                            value: import("@sinclair/typebox").TString;
                        }>, import("@sinclair/typebox").TObject<{
                            type: import("@sinclair/typebox").TLiteral<"variable">;
                            name: import("@sinclair/typebox").TString;
                        }>]>;
                    }>>;
                }>>;
            }>]>>;
        }>>;
    }>, import("@sinclair/typebox").TObject<{
        locale: import("@sinclair/typebox").TString;
        slot: import("@sinclair/typebox").TLiteral<true>;
    }>]>>;
}>;
//# sourceMappingURL=types.d.ts.map