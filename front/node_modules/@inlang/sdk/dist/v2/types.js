import { Type } from "@sinclair/typebox";
/**
 * Follows the IETF BCP 47 language tag schema with modifications.
 * @see REAMDE.md file for more information on the validation.
 */
export const pattern = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
export const LanguageTag = Type.String({
    pattern: pattern,
    description: "The language tag must be a valid IETF BCP 47 language tag.",
    examples: ["en", "de", "en-US", "zh-Hans", "es-419"],
});
export const Literal = Type.Object({
    type: Type.Literal("literal"),
    value: Type.String(),
});
export const Text = Type.Object({
    type: Type.Literal("text"),
    value: Type.String(),
});
export const VariableReference = Type.Object({
    type: Type.Literal("variable"),
    name: Type.String(),
});
export const Option = Type.Object({
    name: Type.String(),
    value: Type.Union([Literal, VariableReference]),
});
export const FunctionAnnotation = Type.Object({
    type: Type.Literal("function"),
    name: Type.String(),
    options: Type.Array(Option),
});
export const Expression = Type.Object({
    type: Type.Literal("expression"),
    arg: Type.Union([Literal, VariableReference]),
    annotation: Type.Optional(FunctionAnnotation),
});
export const Pattern = Type.Array(Type.Union([Text, Expression]));
export const Variant = Type.Object({
    /**
     * The number of keys in each variant match MUST equal the number of expressions in the selectors.
     *
     * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
     */
    // a match can always only be string-based because a string is what is rendered to the UI
    match: Type.Array(Type.String()),
    pattern: Pattern,
});
export const InputDeclaration = Type.Object({
    type: Type.Literal("input"),
    name: Type.String(),
    //TODO make this generic so that only Variable-Ref Expressions are allowed
    value: Expression,
});
export const Declaration = Type.Union([InputDeclaration]);
export const Message = Type.Object({
    locale: LanguageTag,
    declarations: Type.Array(Declaration),
    /**
     * The order in which the selectors are placed determines the precedence of patterns.
     */
    selectors: Type.Array(Expression),
    variants: Type.Array(Variant),
});
export const MessageBundle = Type.Object({
    id: Type.String(),
    alias: Type.Record(Type.String(), Type.String()),
    messages: Type.Array(Message),
});
export const MessageSlot = Type.Object({
    locale: LanguageTag,
    slot: Type.Literal(true),
});
export const MessageBundleWithSlots = Type.Object({
    id: Type.String(),
    alias: Type.Record(Type.String(), Type.String()),
    messages: Type.Array(Type.Union([Message, MessageSlot])),
});
