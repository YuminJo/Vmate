/* eslint-disable @typescript-eslint/no-non-null-assertion */
import { describe, expect, it } from "vitest";
import { resolvePlugins } from "./resolvePlugins.js";
import { PluginLoadMessagesFunctionAlreadyDefinedError, PluginSaveMessagesFunctionAlreadyDefinedError, PluginHasInvalidIdError, PluginReturnedInvalidCustomApiError, PluginsDoNotProvideLoadOrSaveMessagesError, } from "./errors.js";
it("should return an error if a plugin uses an invalid id", async () => {
    const mockPlugin = {
        // @ts-expect-error - invalid id
        id: "no-namespace",
        description: { en: "My plugin description" },
        displayName: { en: "My plugin" },
        loadMessages: () => undefined,
        saveMessages: () => undefined,
    };
    const resolved = await resolvePlugins({
        plugins: [mockPlugin],
        settings: {},
        nodeishFs: {},
    });
    expect(resolved.errors[0]).toBeInstanceOf(PluginHasInvalidIdError);
});
it("should expose the project settings including the plugin settings", async () => {
    const settings = {
        sourceLanguageTag: "en",
        languageTags: ["en", "de"],
        modules: [],
        "plugin.namespace.placeholder": {
            myPluginSetting: "value",
        },
    };
    const mockPlugin = {
        id: "plugin.namespace.placeholder",
        description: { en: "My plugin description" },
        displayName: { en: "My plugin" },
        saveMessages: async ({ settings }) => {
            expect(settings).toStrictEqual(settings);
        },
        addCustomApi: ({ settings }) => {
            expect(settings).toStrictEqual(settings);
            return {};
        },
        loadMessages: async ({ settings }) => {
            expect(settings).toStrictEqual(settings);
            return [];
        },
    };
    const resolved = await resolvePlugins({
        plugins: [mockPlugin],
        settings: settings,
        nodeishFs: {},
    });
    await resolved.data.loadMessages({ settings, nodeishFs: {} });
    await resolved.data.saveMessages({ settings, messages: [], nodeishFs: {} });
});
describe("loadMessages", () => {
    it("should load messages from a local source", async () => {
        const mockPlugin = {
            id: "plugin.namespace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            loadMessages: async () => [
                { id: "test", alias: {}, expressions: [], selectors: [], variants: [] },
            ],
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            settings: {},
            nodeishFs: {},
        });
        expect(await resolved.data.loadMessages({
            settings: {},
            nodeishFs: {},
        })).toEqual([{ id: "test", alias: {}, expressions: [], selectors: [], variants: [] }]);
    });
    it("should collect an error if function is defined twice in multiple plugins", async () => {
        const mockPlugin = {
            id: "plugin.namepsace.loadMessagesFirst",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            loadMessages: async () => undefined,
        };
        const mockPlugin2 = {
            id: "plugin.namepsace.loadMessagesSecond",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            loadMessages: async () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin, mockPlugin2],
            nodeishFs: {},
            settings: {},
        });
        expect(resolved.errors[0]).toBeInstanceOf(PluginLoadMessagesFunctionAlreadyDefinedError);
    });
    it("should return an error if no plugin defines loadMessages", async () => {
        const mockPlugin = {
            id: "plugin.namepsace.loadMessagesFirst",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            saveMessages: async () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            nodeishFs: {},
            settings: {},
        });
        expect(resolved.errors).toHaveLength(1);
        expect(resolved.errors[0]).toBeInstanceOf(PluginsDoNotProvideLoadOrSaveMessagesError);
    });
});
describe("saveMessages", () => {
    it("should save messages to a local source", async () => {
        const mockPlugin = {
            id: "plugin.namespace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            loadMessages: async () => undefined,
            saveMessages: async () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            nodeishFs: {},
            settings: {},
        });
        expect(resolved.errors).toHaveLength(0);
    });
    it("should collect an error if function is defined twice in multiple plugins", async () => {
        const mockPlugin = {
            id: "plugin.namepsace.saveMessages",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            saveMessages: async () => undefined,
        };
        const mockPlugin2 = {
            id: "plugin.namepsace.saveMessages2",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            saveMessages: async () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin, mockPlugin2],
            settings: {},
            nodeishFs: {},
        });
        expect(resolved.errors[0]).toBeInstanceOf(PluginSaveMessagesFunctionAlreadyDefinedError);
    });
    it("should return an error if no plugin defines saveMessages", async () => {
        const mockPlugin = {
            id: "plugin.namepsace.loadMessagesFirst",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            loadMessages: async () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            nodeishFs: {},
            settings: {},
        });
        expect(resolved.errors).toHaveLength(1);
        expect(resolved.errors[0]).toBeInstanceOf(PluginsDoNotProvideLoadOrSaveMessagesError);
    });
});
describe("addCustomApi", () => {
    it("it should resolve app specific api", async () => {
        const mockPlugin = {
            id: "plugin.namespace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            addCustomApi: () => ({
                "my-app": {
                    messageReferenceMatcher: () => undefined,
                },
            }),
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            settings: {},
            nodeishFs: {},
        });
        expect(resolved.data.customApi).toHaveProperty("my-app");
    });
    it("it should resolve multiple app specific apis", async () => {
        const mockPlugin = {
            id: "plugin.namespace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            addCustomApi: () => ({
                "my-app-1": {
                    functionOfMyApp1: () => undefined,
                },
                "my-app-2": {
                    functionOfMyApp2: () => undefined,
                },
            }),
        };
        const mockPlugin2 = {
            id: "plugin.namespace.placeholder2",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            addCustomApi: () => ({
                "my-app-3": {
                    functionOfMyApp3: () => undefined,
                },
            }),
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin, mockPlugin2],
            settings: {},
            nodeishFs: {},
        });
        expect(resolved.data.customApi).toHaveProperty("my-app-1");
        expect(resolved.data.customApi).toHaveProperty("my-app-2");
        expect(resolved.data.customApi).toHaveProperty("my-app-3");
    });
    it("it should throw an error if return value is not an object", async () => {
        const mockPlugin = {
            id: "plugin.namespace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            // @ts-expect-error - invalid return type
            addCustomApi: () => undefined,
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            settings: {},
            nodeishFs: {},
        });
        expect(resolved.errors[0]).toBeInstanceOf(PluginReturnedInvalidCustomApiError);
    });
    it("it should throw an error if the passed options are not defined inside customApi", async () => {
        const mockPlugin = {
            id: "plugin.namepsace.placeholder",
            description: { en: "My plugin description" },
            displayName: { en: "My plugin" },
            addCustomApi: () => ({
                "app.inlang.placeholder": {
                    messageReferenceMatcher: () => {
                        return { hello: "world" };
                    },
                },
            }),
        };
        const resolved = await resolvePlugins({
            plugins: [mockPlugin],
            settings: {},
            nodeishFs: {},
        });
        expect(resolved.data.customApi).toHaveProperty("app.inlang.placeholder");
        expect((resolved.data.customApi?.["app.inlang.placeholder"]).messageReferenceMatcher()).toEqual({
            hello: "world",
        });
    });
});
