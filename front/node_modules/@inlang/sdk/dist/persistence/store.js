import { addSlots, removeSlots, injectJSONNewlines } from "../v2/helper.js";
import { getDirname } from "@lix-js/fs";
import { acquireFileLock } from "./filelock/acquireFileLock.js";
import { releaseLock } from "./filelock/releaseLock.js";
import { batchedIO } from "./batchedIO.js";
import _debug from "debug";
const debug = _debug("sdk:store");
export async function openStore(args) {
    const nodeishFs = args.nodeishFs;
    const filePath = args.projectPath + "/messages.json";
    const lockDirPath = args.projectPath + "/messagelock";
    // the index holds the in-memory state
    // TODO: reload when file changes on disk
    // https://github.com/opral/inlang-message-sdk/issues/80
    let index = await load();
    const batchedSave = batchedIO(acquireSaveLock, releaseSaveLock, save);
    return {
        messageBundles: {
            reload: async () => {
                index.clear();
                index = await load();
            },
            get: async (args) => {
                return index.get(args.id);
            },
            set: async (args) => {
                index.set(args.data.id, args.data);
                await batchedSave(args.data.id);
            },
            delete: async (args) => {
                index.delete(args.id);
                await batchedSave(args.id);
            },
            getAll: async () => {
                return [...index.values()];
            },
        },
    };
    // load and save messages from file system atomically
    // using a lock file to prevent partial reads and writes
    async function load() {
        const lockTime = await acquireFileLock(nodeishFs, lockDirPath, "load");
        const messages = await readJSON({ filePath, nodeishFs: nodeishFs });
        const index = new Map(messages.map((message) => [message.id, message]));
        await releaseLock(nodeishFs, lockDirPath, "load", lockTime);
        return index;
    }
    async function acquireSaveLock() {
        return await acquireFileLock(nodeishFs, lockDirPath, "save");
    }
    async function releaseSaveLock(lock) {
        return await releaseLock(nodeishFs, lockDirPath, "save", lock);
    }
    async function save() {
        await writeJSON({
            filePath,
            nodeishFs: nodeishFs,
            messages: [...index.values()],
            locales: args.locales,
        });
    }
}
export async function readJSON(args) {
    let result = [];
    debug("loadAll", args.filePath);
    try {
        const file = await args.nodeishFs.readFile(args.filePath, { encoding: "utf-8" });
        result = JSON.parse(file);
    }
    catch (error) {
        if (error?.code !== "ENOENT") {
            debug("loadMessages", error);
            throw error;
        }
    }
    return result.map(removeSlots);
}
export async function writeJSON(args) {
    debug("saveall", args.filePath);
    try {
        await createDirectoryIfNotExits(getDirname(args.filePath), args.nodeishFs);
        const output = injectJSONNewlines(JSON.stringify(args.messages.map((bundle) => addSlots(bundle, args.locales))));
        await args.nodeishFs.writeFile(args.filePath, output);
    }
    catch (error) {
        debug("saveMessages", error);
        throw error;
    }
}
async function createDirectoryIfNotExits(path, nodeishFs) {
    try {
        await nodeishFs.mkdir(path, { recursive: true });
    }
    catch (error) {
        if (error.code !== "EEXIST") {
            throw error;
        }
    }
}
