import { n as normalizePath, g as getDirname, a as getBasename } from "./index.js";
import "dedent";
import "tty";
import "util";
import "os";
import "posthog-node";
import "node:fs/promises";
import "node:path";
import "node:crypto";
import "consola/utils";
import "consola";
class FilesystemError extends Error {
  code;
  path;
  syscall;
  target;
  constructor(code, path, syscall, target) {
    let message;
    switch (code) {
      case "ENOENT":
        message = `${code}: No such file or directory, ${syscall} '${path}'`;
        break;
      case "ENOTDIR":
        message = `${code}: Not a directory, ${syscall} '${path}'`;
        break;
      case "EISDIR":
        message = `${code}: Illegal operation on a directory, ${syscall} '${path}'`;
        break;
      case "ENOTEMPTY":
        message = `${code}: Directory not empty, ${syscall} '${path}'`;
        break;
      case "EEXIST":
        message = `${code}: File exists, ${syscall} '${path}' -> '${target}'`;
        break;
      case "EINVAL":
        message = `${code}: Invaid argument, ${syscall} '${path}'`;
        break;
      default:
        message = `Unknown error with code "${code}", '${syscall}' on '${path}'`;
    }
    super(message);
    this.name = "FilesystemError";
    this.code = code;
    this.path = path;
    this.syscall = syscall;
    this.target = target;
  }
}
function createNodeishMemoryFs() {
  const state = {
    lastIno: 1,
    fsMap: /* @__PURE__ */ new Map(),
    fsStats: /* @__PURE__ */ new Map()
  };
  state.fsMap.set("/", /* @__PURE__ */ new Set());
  newStatEntry({
    path: "/",
    stats: state.fsStats,
    kind: 1,
    modeBits: 493
  });
  const listeners = /* @__PURE__ */ new Set();
  async function stat(path) {
    path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
    const stats = state.fsStats.get(path);
    if (stats === void 0) {
      throw new FilesystemError("ENOENT", path, "stat");
    }
    if (stats.symlinkTarget) {
      return stat(stats.symlinkTarget);
    }
    return Object.assign({}, stats);
  }
  async function lstat(path) {
    path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
    const stats = state.fsStats.get(path);
    if (stats === void 0) {
      throw new FilesystemError("ENOENT", path, "lstat");
    }
    if (!stats.symlinkTarget) {
      return stat(path);
    }
    return Object.assign({}, stats);
  }
  return {
    _state: state,
    _createPlaceholder: async function(path, options) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dirName = getDirname(path);
      const baseName = getBasename(path);
      let parentDir = state.fsMap.get(dirName);
      if (!(parentDir instanceof Set)) {
        await this.mkdir(dirName, { recursive: true });
        parentDir = state.fsMap.get(dirName);
        if (!(parentDir instanceof Set)) {
          throw new FilesystemError("ENOENT", path, "writeFile");
        }
      }
      parentDir.add(baseName);
      const isSymbolicLink = options.mode === 12e4;
      newStatEntry({
        path,
        stats: state.fsStats,
        kind: isSymbolicLink ? 2 : 0,
        modeBits: options.mode,
        oid: options.oid,
        rootHash: options.rootHash
      });
      state.fsMap.set(path, { placeholder: true });
    },
    _isPlaceholder: function(path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const entry = state.fsMap.get(path);
      if (entry && "placeholder" in entry) {
        return true;
      }
      return false;
    },
    writeFile: async function(path, data, options) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dirName = getDirname(path);
      const baseName = getBasename(path);
      const parentDir = state.fsMap.get(dirName);
      if (!(parentDir instanceof Set))
        throw new FilesystemError("ENOENT", path, "writeFile");
      let inodeData;
      if (typeof data === "string") {
        inodeData = Buffer.from(new TextEncoder().encode(data));
      } else if (!(data instanceof Uint8Array)) {
        throw new FilesystemError('The "data" argument must be of type string/Uint8Array', data, "readFile");
      } else if (!Buffer.isBuffer(data)) {
        inodeData = Buffer.from(data);
      } else {
        inodeData = data;
      }
      parentDir.add(baseName);
      newStatEntry({
        path,
        stats: state.fsStats,
        kind: 0,
        modeBits: (options == null ? void 0 : options.mode) ?? 420
      });
      state.fsMap.set(path, inodeData);
      for (const listener of listeners) {
        listener({ eventType: "rename", filename: dirName + baseName });
      }
    },
    // @ts-expect-error
    //   Typescript can't derive that the return type is either
    //   a string or a Uint8Array based on the options.
    readFile: async function(path, options) {
      const decoder = new TextDecoder();
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const file = state.fsMap.get(path);
      if (file instanceof Set)
        throw new FilesystemError("EISDIR", path, "readFile");
      if (file === void 0)
        throw new FilesystemError("ENOENT", path, "readFile");
      if ("placeholder" in file)
        throw new FilesystemError("EPLACEHOLDER", path, "readFile");
      if (!((options == null ? void 0 : options.encoding) || typeof options === "string"))
        return file;
      return decoder.decode(file);
    },
    readdir: async function(path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dir = state.fsMap.get(path);
      if (dir instanceof Set)
        return [...dir.keys()];
      if (dir === void 0)
        throw new FilesystemError("ENOENT", path, "readdir");
      throw new FilesystemError("ENOTDIR", path, "readdir");
    },
    mkdir: async function mkdir(path, options) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dirName = getDirname(path);
      const baseName = getBasename(path);
      const parentDir = state.fsMap.get(dirName);
      if (typeof parentDir === "string" || parentDir && "palceholder" in parentDir) {
        throw new FilesystemError("ENOTDIR", path, "mkdir");
      }
      if (parentDir && parentDir instanceof Set) {
        if (state.fsMap.has(path)) {
          if (!(options == null ? void 0 : options.recursive)) {
            throw new FilesystemError("EEXIST", path, "mkdir");
          } else {
            return void 0;
          }
        }
        parentDir.add(baseName);
        newStatEntry({
          path,
          stats: state.fsStats,
          kind: 1,
          modeBits: 493
        });
        state.fsMap.set(path, /* @__PURE__ */ new Set());
        for (const listener of listeners) {
          listener({ eventType: "rename", filename: dirName + baseName });
        }
        return path;
      } else if (options == null ? void 0 : options.recursive) {
        const parent = getDirname(path);
        const parentRes = await mkdir(parent, options);
        await mkdir(path, { recursive: false }).catch(() => {
        });
        return parentRes;
      }
      throw new FilesystemError("ENOENT", path, "mkdir");
    },
    rm: async function rm(path, options) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dirName = getDirname(path);
      const baseName = getBasename(path);
      const target = state.fsMap.get(path);
      const targetStats = state.fsStats.get(path);
      const parentDir = state.fsMap.get(dirName);
      if (parentDir === void 0 || targetStats === void 0)
        throw new FilesystemError("ENOENT", path, "rm");
      if (parentDir instanceof Uint8Array || "placeholder" in parentDir) {
        throw new FilesystemError("ENOTDIR", path, "rm");
      }
      if (target instanceof Uint8Array || target && "placeholder" in target || targetStats.isSymbolicLink()) {
        parentDir.delete(baseName);
        state.fsStats.delete(path);
        state.fsMap.delete(path);
        for (const listener of listeners) {
          listener({ eventType: "rename", filename: dirName + baseName });
        }
        return;
      }
      if (target instanceof Set && (options == null ? void 0 : options.recursive)) {
        await Promise.all([...target.keys()].map(async (child) => {
          await rm(`${path}/${child}`, { recursive: true });
        }));
        parentDir.delete(baseName);
        state.fsStats.delete(path);
        state.fsMap.delete(path);
        for (const listener of listeners) {
          listener({ eventType: "rename", filename: dirName + baseName });
        }
        return;
      }
      throw new FilesystemError("EISDIR", path, "rm");
    },
    /**
     *
     * @throws {"ENOENT" | WatchAbortedError} // TODO: move to lix error classes FileDoesNotExistError
     */
    watch: function(path, options) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const watchName = getBasename(path);
      const watchDir = getDirname(path);
      const watchPath = watchName === "/" ? watchDir : watchDir + watchName;
      if ((options == null ? void 0 : options.persistent) || (options == null ? void 0 : options.encoding)) {
        throw new Error("Some watch opptions not implemented, only 'recursive' allowed");
      }
      const queue = [];
      let handleNext;
      let rejecteNext;
      let changeEvent = new Promise((resolve, reject) => {
        handleNext = resolve;
        rejecteNext = reject;
      });
      const listener = ({ eventType, filename }) => {
        const event = {
          eventType,
          filename
        };
        if (event.filename === null) {
          throw new Error("Internal watcher error: missing filename");
        }
        const changeName = getBasename(event.filename);
        const changeDir = getDirname(event.filename);
        if (event.filename === watchPath) {
          event.filename = changeName;
          queue.push(event);
          setTimeout(() => handleNext(void 0), 0);
        } else if (changeDir === `${watchPath}/`) {
          event.filename = event.filename.replace(`${watchPath}/`, "") || changeName;
          queue.push(event);
          setTimeout(() => handleNext(void 0), 0);
        } else if ((options == null ? void 0 : options.recursive) && event.filename.startsWith(watchPath)) {
          event.filename = event.filename.replace(`${watchPath}/`, "") || changeName;
          queue.push(event);
          setTimeout(() => handleNext(void 0), 0);
        }
      };
      listeners.add(listener);
      if (options == null ? void 0 : options.signal) {
        options.signal.addEventListener("abort", () => {
          var _a;
          listeners.delete(listener);
          try {
            (_a = options.signal) == null ? void 0 : _a.throwIfAborted();
          } catch (err) {
            rejecteNext(err);
          }
        }, { once: true });
      }
      const asyncIterator = async function* () {
        var _a;
        while (!((_a = options == null ? void 0 : options.signal) == null ? void 0 : _a.aborted)) {
          if (queue.length > 0) {
            yield queue.shift();
          } else {
            await changeEvent;
            changeEvent = new Promise((resolve, reject) => {
              handleNext = resolve;
              rejecteNext = reject;
            });
          }
        }
      };
      return asyncIterator();
    },
    rmdir: async function(path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const dirName = getDirname(path);
      const baseName = getBasename(path);
      const target = state.fsMap.get(path);
      const parentDir = state.fsMap.get(dirName);
      if (parentDir === void 0 || target === void 0)
        throw new FilesystemError("ENOENT", path, "rmdir");
      if (parentDir instanceof Uint8Array || target instanceof Uint8Array)
        throw new FilesystemError("ENOTDIR", path, "rmdir");
      if ("placeholder" in parentDir || "placeholder" in target) {
        throw new FilesystemError("ENOTDIR", path, "rmdir");
      }
      if (target.size)
        throw new FilesystemError("ENOTEMPTY", path, "rmdir");
      parentDir.delete(baseName);
      state.fsStats.delete(path);
      state.fsMap.delete(path);
      for (const listener of listeners) {
        listener({ eventType: "rename", filename: dirName + baseName });
      }
    },
    symlink: async function(target, path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const rawTarget = target.startsWith("/") ? target : `${path}/../${target}`;
      const targetWithTrailing = normalizePath(rawTarget, {
        trailingSlash: "always",
        leadingSlash: "always"
      });
      const targetInode = state.fsMap.get(targetWithTrailing);
      const parentDir = state.fsMap.get(getDirname(path));
      if (state.fsMap.get(path)) {
        throw new FilesystemError("EEXIST", path, "symlink", target);
      }
      if (parentDir === void 0) {
        throw new FilesystemError("ENOENT", path, "symlink", target);
      }
      if (parentDir instanceof Uint8Array || "placeholder" in parentDir) {
        throw new FilesystemError("ENOTDIR", path, "symlink", target);
      }
      if (targetInode !== void 0) {
        state.fsMap.set(path, targetInode);
      }
      parentDir.add(getBasename(path));
      newStatEntry({
        path,
        stats: state.fsStats,
        kind: 2,
        modeBits: 511,
        target: rawTarget
      });
    },
    unlink: async function(path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const targetStats = state.fsStats.get(path);
      const target = state.fsMap.get(path);
      const parentDir = state.fsMap.get(getDirname(path));
      if (parentDir === void 0 || target === void 0)
        throw new FilesystemError("ENOENT", path, "unlink");
      if (parentDir instanceof Uint8Array || "placeholder" in parentDir) {
        throw new FilesystemError("ENOTDIR", path, "unlink");
      }
      if (targetStats == null ? void 0 : targetStats.isDirectory()) {
        throw new FilesystemError("EISDIR", path, "unlink");
      }
      parentDir.delete(getBasename(path));
      state.fsStats.delete(path);
      state.fsMap.delete(path);
    },
    readlink: async function(path) {
      path = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
      const linkStats = await lstat(path);
      if (linkStats === void 0) {
        throw new FilesystemError("ENOENT", path, "readlink");
      }
      if (linkStats.symlinkTarget === void 0) {
        throw new FilesystemError("EINVAL", path, "readlink");
      }
      return linkStats.symlinkTarget;
    },
    stat,
    lstat
  };
  function newStatEntry({ path, stats, kind, modeBits, target, oid, rootHash }) {
    const currentTime = Date.now();
    const _kind = kind;
    const targetPath = normalizePath(path, { trailingSlash: "always", leadingSlash: "always" });
    const oldStats = stats.get(targetPath);
    const mtimeMs = Math.floor(currentTime / 1e3) === ((oldStats == null ? void 0 : oldStats.mtimeMs) && Math.floor((oldStats == null ? void 0 : oldStats.mtimeMs) / 1e3)) ? currentTime + 1e3 : currentTime;
    stats.set(targetPath, {
      ctimeMs: (oldStats == null ? void 0 : oldStats.ctimeMs) || currentTime,
      mtimeMs,
      dev: 0,
      ino: (oldStats == null ? void 0 : oldStats.ino) || state.lastIno++,
      mode: (!kind ? 32768 : kind === 1 ? 16384 : 40960) | modeBits,
      uid: 0,
      gid: 0,
      size: -1,
      isFile: () => kind === 0,
      isDirectory: () => kind === 1,
      isSymbolicLink: () => kind === 2,
      // symlinkTarget is only for symlinks, and is not normalized
      symlinkTarget: target,
      _oid: oid,
      _rootHash: rootHash,
      _kind
    });
  }
}
export {
  createNodeishMemoryFs,
  getBasename,
  getDirname,
  normalizePath
};
