export type PathDefinitionTranslations<T extends string = string> = {
    [canonicalPath: `/${string}`]: Record<T, `/${string}`>;
};
type Route = {
    params: RouteParam[];
    pattern: RegExp;
};
export type RouteParam = {
    name: string;
    matcher: string;
    optional: boolean;
    rest: boolean;
    chained: boolean;
};
export type ParamMatcher = (segment: string) => boolean;
/**
 * Creates the regex pattern, extracts parameter names, and generates types for a route
 */
export declare function parseRouteDefinition(id: string): Route;
export declare function exec(match: RegExpMatchArray, params: RouteParam[], matchers: Record<string, ParamMatcher>): Record<string, string> | undefined;
/**
 * Populate a route ID with params to resolve a pathname.
 * @example
 * ```js
 * resolveRoute(
 *   `/blog/[slug]/[...somethingElse]`,
 *   {
 *     slug: 'hello-world',
 *     somethingElse: 'something/else'
 *   }
 * ); // `/blog/hello-world/something/else`
 * ```
 */
export declare function resolveRoute(id: string, params: Record<string, string | undefined>): string;
/**
 * Returns the id and params for the route that best matches the given path.
 * @param canonicalPath Canonical pathname excluding the base and language e.g. /foo/bar
 * @param pathDefinitions An array of pathDefinitions
 * @param matchers A map of param matcher functions
 *
 * @returns undefined if no route matches.
 */
export declare function bestMatch(canonicalPath: string, pathDefinitions: string[], matchers: Record<string, ParamMatcher>): {
    params: Record<string, string>;
    id: string;
} | undefined;
export {};
