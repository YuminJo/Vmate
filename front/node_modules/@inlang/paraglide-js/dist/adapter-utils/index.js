function negotiateLanguagePreferences(accept, availableLanguageTags) {
  accept ||= "*";
  const acceptLanguageSpecs = parseAcceptLanguageHeader(accept);
  const priorities = availableLanguageTags.map(
    (languageTag, index) => getHighestLanguagePriority(languageTag, acceptLanguageSpecs, index)
  );
  return priorities.filter((prio) => prio.quality > 0).sort(bySpecificity).sort(byQuality).map((priority) => priority.languageTag);
}
function parseAcceptLanguageHeader(acceptLanguage) {
  return acceptLanguage.split(",").map((dfn) => dfn.trim()).map((dfn, index) => parseLanguage(dfn, index)).filter((maybeSpec) => Boolean(maybeSpec));
}
function parseLanguage(languageTag, index) {
  const LANGUAGE_REGEXP = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
  const match = LANGUAGE_REGEXP.exec(languageTag);
  if (!match)
    return void 0;
  const [, prefix, suffix, qualityMatch] = match;
  if (!prefix)
    throw new Error(`Invalid language tag: ${languageTag}`);
  const full = suffix ? `${prefix}-${suffix}` : prefix;
  const quality = parseQuality(qualityMatch ?? "") ?? 1;
  return {
    prefix,
    suffix,
    quality,
    index,
    full
  };
}
function parseQuality(qualityMatch) {
  return qualityMatch.split(";").map((param) => param.split("=")).filter((p) => p[0] == "q" && !!p[1]).map(([, value]) => parseFloat(value))[0];
}
function getHighestLanguagePriority(languageTag, acceptableLanguages, index) {
  const priorities = acceptableLanguages.map((spec) => calculatePriority(languageTag, spec, index)).filter((prio) => Boolean(prio));
  const highestPriority = priorities.sort(bySpecificity)[0] || {
    languageTag,
    index: 0,
    order: -1,
    quality: 0,
    specificity: 0
  };
  return highestPriority;
}
function calculatePriority(languageTag, spec, index) {
  const parsed = parseLanguage(languageTag, 0);
  if (!parsed)
    return void 0;
  let specificity = 0;
  if (spec.full.toLowerCase() === parsed.full.toLowerCase()) {
    specificity = 4;
  } else if (spec.prefix.toLowerCase() === parsed.full.toLowerCase()) {
    specificity = 2;
  } else if (spec.full.toLowerCase() === parsed.prefix.toLowerCase()) {
    specificity = 1;
  }
  if (specificity === 0 && spec.full !== "*")
    return void 0;
  return {
    languageTag,
    index,
    order: spec.index,
    quality: spec.quality,
    specificity
  };
}
const byQuality = (a, b) => b.quality - a.quality;
const bySpecificity = (a, b) => b.specificity - a.specificity || a.order - b.order || a.index - b.index;
function detectLanguageFromPath({
  path,
  availableLanguageTags,
  base
}) {
  base ??= "";
  if (base === "/")
    base = "";
  if (!path.startsWith(base))
    return void 0;
  const pathWithoutBase = path.replace(base, "");
  const maybeLang = pathWithoutBase.split("/")[1];
  if (!maybeLang)
    return void 0;
  return availableLanguageTags.map(lower).includes(lower(maybeLang)) ? maybeLang : void 0;
}
const lower = (s) => s.toLowerCase();
const STATIC = 0;
const OPTIONAL = 1;
const REST = 2;
const REQUIRED = 4;
const PART_TYPE = 0;
const PART_CONTENT = 1;
const PART_MATCHED = 2;
function sort_routes(routes) {
  const get_parts = cached(split);
  return routes.sort((route_a, route_b) => {
    var _a, _b, _c, _d, _e, _f;
    const segments_a = split_route_id(route_a).map(get_parts);
    const segments_b = split_route_id(route_b).map(get_parts);
    for (let i = 0; i < Math.max(segments_a.length, segments_b.length); i += 1) {
      const segment_a = segments_a[i];
      const segment_b = segments_b[i];
      if (!segment_a)
        return -1;
      if (!segment_b)
        return 1;
      for (let j = 0; j < Math.max(segment_a.length, segment_b.length); j += 1) {
        const a = segment_a[j];
        const b = segment_b[j];
        const dynamic = (a == null ? void 0 : a[PART_TYPE]) || (b == null ? void 0 : b[PART_TYPE]);
        if (dynamic) {
          if (!a)
            return -1;
          if (!b)
            return 1;
          const next_a = ((_a = segment_a[j + 1]) == null ? void 0 : _a[PART_CONTENT]) || ((_c = (_b = segments_a[i + 1]) == null ? void 0 : _b[0]) == null ? void 0 : _c[PART_CONTENT]);
          const next_b = ((_d = segment_b[j + 1]) == null ? void 0 : _d[PART_CONTENT]) || ((_f = (_e = segments_b[i + 1]) == null ? void 0 : _e[0]) == null ? void 0 : _f[PART_CONTENT]);
          const both_have_next = next_a && next_b;
          const only_a_has_next = next_a && !next_b;
          const only_b_has_next = !next_a && next_b;
          if ((a[PART_TYPE] && b[PART_TYPE]) === REST) {
            if (both_have_next)
              continue;
            if (only_a_has_next)
              return -1;
            if (only_b_has_next)
              return 1;
          }
          if (a[PART_TYPE] === REST)
            return only_a_has_next ? -1 : 1;
          if (b[PART_TYPE] === REST)
            return only_b_has_next ? 1 : -1;
          if (a[PART_MATCHED] !== b[PART_MATCHED])
            return (-1) ** +a[PART_MATCHED];
          if (a[PART_TYPE] !== b[PART_TYPE]) {
            return (-1) ** +(a[PART_TYPE] > b[PART_TYPE]);
          }
        } else if ((a == null ? void 0 : a[PART_CONTENT]) !== (b == null ? void 0 : b[PART_CONTENT])) {
          return sort_static(a[PART_CONTENT], b[PART_CONTENT]);
        }
      }
    }
    return route_a < route_b ? 1 : -1;
  });
}
function cached(fn) {
  const cache = /* @__PURE__ */ new Map();
  return (arg) => {
    if (!cache.has(arg))
      cache.set(arg, fn(arg));
    return cache.get(arg);
  };
}
function split(id) {
  const parts = [];
  let i = 0;
  while (i <= id.length) {
    const start = id.indexOf("[", i);
    const entirelyStatic = start === -1;
    parts.push([STATIC, id.slice(i, entirelyStatic ? void 0 : start), false]);
    if (entirelyStatic)
      break;
    const type = id[start + 1] === "[" ? OPTIONAL : id[start + 1] === "." ? REST : REQUIRED;
    const endBrackets = type === OPTIONAL ? "]]" : "]";
    const endBracketIdx = id.indexOf(endBrackets, start);
    if (endBracketIdx === -1)
      throw new Error(`Invalid route definition ${id}`);
    const content = id.slice(start, i = endBracketIdx + endBrackets.length);
    parts.push([type, content, content.includes("=")]);
  }
  return parts;
}
const split_route_id = (id) => id.replace(/\[\[[^\]]+\]\](?!$)/g, "").split("/").filter(Boolean);
function sort_static(a, b) {
  if (a === b)
    return 0;
  let idx = 0;
  while (a[idx] === b[idx])
    idx++;
  return !a[idx] ? 1 : !b[idx] ? -1 : a[idx] < b[idx] ? -1 : 1;
}
const param_pattern = /^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;
function parseRouteDefinition(id) {
  const params = [];
  const pattern = id === "/" ? /^\/$/ : new RegExp(
    `^${get_route_segments(id).map((segment) => {
      const rest_match = /^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(segment);
      if (rest_match) {
        params.push({
          name: rest_match[1],
          matcher: rest_match[2],
          optional: false,
          rest: true,
          chained: true
        });
        return "(?:/(.*))?";
      }
      const optional_match = /^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(segment);
      if (optional_match) {
        params.push({
          name: optional_match[1],
          matcher: optional_match[2],
          optional: true,
          rest: false,
          chained: true
        });
        return "(?:/([^/]+))?";
      }
      if (!segment) {
        return;
      }
      const parts = segment.split(/\[(.+?)\](?!\])/);
      const result = parts.map((content, i) => {
        if (i % 2) {
          if (content.startsWith("x+")) {
            return escape(String.fromCharCode(parseInt(content.slice(2), 16)));
          }
          if (content.startsWith("u+")) {
            return escape(
              String.fromCharCode(
                ...content.slice(2).split("-").map((code) => parseInt(code, 16))
              )
            );
          }
          const match = (
            /** @type {RegExpExecArray} */
            param_pattern.exec(content)
          );
          if (!match) {
            throw new Error(`Invalid param: ${content}`);
          }
          const [, is_optional, is_rest, name, matcher] = match;
          params.push({
            name,
            matcher,
            optional: !!is_optional,
            rest: !!is_rest,
            chained: is_rest ? i === 1 && parts[0] === "" : false
          });
          return is_rest ? "(.*?)" : is_optional ? "([^/]*)?" : "([^/]+?)";
        }
        return escape(content);
      }).join("");
      return "/" + result;
    }).join("")}/?$`
  );
  return { pattern, params };
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((v) => v !== void 0);
  let buffered = 0;
  for (const [i, param] of params.entries()) {
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s) => s).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (param.matcher && !matchers[param.matcher])
      return void 0;
    const matcher = matchers[param.matcher] ?? (() => true);
    if (matcher(value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function escape(str) {
  return str.normalize().replace(/[[\]]/g, "\\$&").replace(/%/g, "%25").replace(/\//g, "%2[Ff]").replace(/\?/g, "%3[Ff]").replace(/#/g, "%23").replace(/[.*+?^${}()|\\]/g, "\\$&");
}
const basic_param_pattern = /\[(\[)?(\.\.\.)?(\w+?)(?:=(\w+))?\]\]?/g;
function resolveRoute(id, params) {
  return "/" + get_route_segments(id).map(
    (segment) => segment.replace(basic_param_pattern, (_, optional, rest, name) => {
      const param_value = params[name];
      if (!param_value) {
        if (optional || rest && param_value !== void 0)
          return "";
        else
          throw new Error(`Missing parameter '${name}' in route ${id}`);
      }
      if (param_value[0] == "/" || param_value.endsWith("/"))
        throw new Error(`Parameter '${name}' in route ${id} cannot start or end with a slash`);
      return param_value;
    })
  ).filter(Boolean).join("/");
}
function bestMatch(canonicalPath, pathDefinitions, matchers) {
  const sorted = sort_routes(pathDefinitions);
  for (const pathDefinition of sorted) {
    const route = parseRouteDefinition(pathDefinition);
    const match = route.pattern.exec(removeTrailingSlash(canonicalPath));
    if (!match)
      continue;
    const params = exec(match, route.params, matchers);
    if (params)
      return { params, id: pathDefinition };
  }
  return void 0;
}
const removeTrailingSlash = (path) => path.endsWith("/") ? path.slice(0, -1) : path;
const get_route_segments = (route) => route.slice(1).split("/");
function validatePathTranslations(pathTranslations, availableLanguageTags, matchers) {
  const issues = [];
  const expectedLanguages = new Set(availableLanguageTags);
  const availableMatchers = new Set(Object.keys(matchers));
  for (const path in pathTranslations) {
    if (!isValidPath(path)) {
      issues.push({
        path,
        message: "Path must start with a slash."
      });
      continue;
    }
    const { params: expectedParams } = parseRouteDefinition(path);
    const expectedMatchers = expectedParams.map((param) => param.matcher).filter(Boolean);
    for (const matcher of expectedMatchers) {
      if (!availableMatchers.has(matcher)) {
        issues.push({
          path,
          message: `Matcher ${matcher} is used but not available. Did you forget to pass it to createI18n?`
        });
      }
    }
    const translations = pathTranslations[path];
    if (!translations)
      continue;
    for (const [lang, translatedPath] of Object.entries(translations)) {
      if (!isValidPath(translatedPath)) {
        issues.push({
          path,
          message: `The translation for language ${lang} must start with a slash.`
        });
      }
      const { params: actualParams } = parseRouteDefinition(translatedPath);
      let paramsDontMatch = false;
      for (const param of expectedParams) {
        if (!actualParams.some((actualParam) => paramsAreEqual(param, actualParam))) {
          paramsDontMatch = true;
        }
      }
      if (expectedParams.length !== actualParams.length) {
        paramsDontMatch = true;
      }
      if (paramsDontMatch) {
        issues.push({
          path,
          message: `The translation for language ${lang} must have the same parameters as the canonical path.`
        });
      }
    }
    const translatedLanguages = new Set(Object.keys(translations));
    if (!isSubset(expectedLanguages, translatedLanguages)) {
      const missingLanguages = new Set(expectedLanguages);
      for (const lang of translatedLanguages) {
        missingLanguages.delete(lang);
      }
      issues.push({
        path,
        message: `The following languages are missing translations: ${[...missingLanguages].join(
          ", "
        )}`
      });
    }
  }
  return issues;
}
function paramsAreEqual(param1, param2) {
  return param1.chained == param2.chained && param1.matcher == param2.matcher && param1.name == param2.name && param1.optional == param2.optional && param1.rest == param2.rest;
}
function isValidPath(maybePath) {
  return maybePath.startsWith("/");
}
function isSubset(a, b) {
  for (const value of a) {
    if (!b.has(value))
      return false;
  }
  return true;
}
function prettyPrintPathDefinitionIssues(issues) {
  return issues.map((issue) => `${issue.path}: ${issue.message}`).join("\n");
}
const resolveUserPathDefinitions = (userTranslations, availableLanguageTags) => Object.fromEntries(
  Object.entries(userTranslations).map(([path, translation]) => [
    path,
    typeof translation === "object" ? translation : fromMessage(translation, availableLanguageTags)
  ])
);
const fromMessage = (message, availableLanguageTags) => Object.fromEntries(
  availableLanguageTags.map((languageTag) => [languageTag, message({}, { languageTag })])
);
export {
  bestMatch,
  detectLanguageFromPath,
  negotiateLanguagePreferences,
  parseRouteDefinition,
  prettyPrintPathDefinitionIssues,
  resolveRoute,
  resolveUserPathDefinitions,
  validatePathTranslations
};
