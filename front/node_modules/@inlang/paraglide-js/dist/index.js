import dedent from "dedent";
import require$$1 from "tty";
import require$$1$1 from "util";
import require$$0 from "os";
import { PostHog } from "posthog-node";
import nodeFsPromises from "node:fs/promises";
import nodePath__default from "node:path";
import crypto$1 from "node:crypto";
import { colors } from "consola/utils";
import consola from "consola";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var typebox = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = void 0;
  exports.Transform = Symbol.for("TypeBox.Transform");
  exports.Readonly = Symbol.for("TypeBox.Readonly");
  exports.Optional = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}$`;
  exports.PatternStringExact = `^${exports.PatternString}$`;
  var TypeRegistry;
  (function(TypeRegistry2) {
    const map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    TypeRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    TypeRegistry2.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    TypeRegistry2.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    TypeRegistry2.Has = Has;
    function Set2(kind, func) {
      map.set(kind, func);
    }
    TypeRegistry2.Set = Set2;
    function Get(kind) {
      return map.get(kind);
    }
    TypeRegistry2.Get = Get;
  })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));
  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError;
  var FormatRegistry;
  (function(FormatRegistry2) {
    const map = /* @__PURE__ */ new Map();
    function Entries() {
      return new Map(map);
    }
    FormatRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    FormatRegistry2.Clear = Clear;
    function Delete(format) {
      return map.delete(format);
    }
    FormatRegistry2.Delete = Delete;
    function Has(format) {
      return map.has(format);
    }
    FormatRegistry2.Has = Has;
    function Set2(format, func) {
      map.set(format, func);
    }
    FormatRegistry2.Set = Set2;
    function Get(format) {
      return map.get(format);
    }
    FormatRegistry2.Get = Get;
  })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function(ValueGuard2) {
    function IsArray2(value2) {
      return Array.isArray(value2);
    }
    ValueGuard2.IsArray = IsArray2;
    function IsBigInt2(value2) {
      return typeof value2 === "bigint";
    }
    ValueGuard2.IsBigInt = IsBigInt2;
    function IsBoolean2(value2) {
      return typeof value2 === "boolean";
    }
    ValueGuard2.IsBoolean = IsBoolean2;
    function IsDate2(value2) {
      return value2 instanceof globalThis.Date;
    }
    ValueGuard2.IsDate = IsDate2;
    function IsNull2(value2) {
      return value2 === null;
    }
    ValueGuard2.IsNull = IsNull2;
    function IsNumber2(value2) {
      return typeof value2 === "number";
    }
    ValueGuard2.IsNumber = IsNumber2;
    function IsObject2(value2) {
      return typeof value2 === "object" && value2 !== null;
    }
    ValueGuard2.IsObject = IsObject2;
    function IsString2(value2) {
      return typeof value2 === "string";
    }
    ValueGuard2.IsString = IsString2;
    function IsUint8Array2(value2) {
      return value2 instanceof globalThis.Uint8Array;
    }
    ValueGuard2.IsUint8Array = IsUint8Array2;
    function IsUndefined2(value2) {
      return value2 === void 0;
    }
    ValueGuard2.IsUndefined = IsUndefined2;
  })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));
  class TypeGuardUnknownTypeError extends TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function(TypeGuard2) {
    function IsPattern(value2) {
      try {
        new RegExp(value2);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value2) {
      if (!ValueGuard.IsString(value2))
        return false;
      for (let i2 = 0; i2 < value2.length; i2++) {
        const code = value2.charCodeAt(i2);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value2) {
      return IsOptionalBoolean(value2) || TSchema(value2);
    }
    function IsOptionalBigInt(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsBigInt(value2);
    }
    function IsOptionalNumber(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsNumber(value2);
    }
    function IsOptionalBoolean(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsBoolean(value2);
    }
    function IsOptionalString(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2);
    }
    function IsOptionalPattern(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
    }
    function IsOptionalFormat(value2) {
      return ValueGuard.IsUndefined(value2) || ValueGuard.IsString(value2) && IsControlCharacterFree(value2);
    }
    function IsOptionalSchema(value2) {
      return ValueGuard.IsUndefined(value2) || TSchema(value2);
    }
    function TAny2(schema) {
      return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TAny = TAny2;
    function TArray2(schema) {
      return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
    }
    TypeGuard2.TArray = TArray2;
    function TAsyncIterator2(schema) {
      return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TAsyncIterator = TAsyncIterator2;
    function TBigInt2(schema) {
      return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
    }
    TypeGuard2.TBigInt = TBigInt2;
    function TBoolean2(schema) {
      return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TBoolean = TBoolean2;
    function TConstructor2(schema) {
      return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TConstructor = TConstructor2;
    function TDate2(schema) {
      return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
    }
    TypeGuard2.TDate = TDate2;
    function TFunction2(schema) {
      return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TFunction = TFunction2;
    function TInteger2(schema) {
      return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TInteger = TInteger2;
    function TIntersect2(schema) {
      return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
    }
    TypeGuard2.TIntersect = TIntersect2;
    function TIterator2(schema) {
      return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TIterator = TIterator2;
    function TKindOf(schema, kind) {
      return TKind2(schema) && schema[exports.Kind] === kind;
    }
    TypeGuard2.TKindOf = TKindOf;
    function TKind2(schema) {
      return ValueGuard.IsObject(schema) && exports.Kind in schema && ValueGuard.IsString(schema[exports.Kind]);
    }
    TypeGuard2.TKind = TKind2;
    function TLiteralString(schema) {
      return TLiteral2(schema) && ValueGuard.IsString(schema.const);
    }
    TypeGuard2.TLiteralString = TLiteralString;
    function TLiteralNumber(schema) {
      return TLiteral2(schema) && ValueGuard.IsNumber(schema.const);
    }
    TypeGuard2.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema) {
      return TLiteral2(schema) && ValueGuard.IsBoolean(schema.const);
    }
    TypeGuard2.TLiteralBoolean = TLiteralBoolean;
    function TLiteral2(schema) {
      return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
    }
    TypeGuard2.TLiteral = TLiteral2;
    function TNever2(schema) {
      return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
    }
    TypeGuard2.TNever = TNever2;
    function TNot2(schema) {
      return TKindOf(schema, "Not") && TSchema(schema.not);
    }
    TypeGuard2.TNot = TNot2;
    function TNull2(schema) {
      return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TNull = TNull2;
    function TNumber2(schema) {
      return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TNumber = TNumber2;
    function TObject2(schema) {
      return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
    }
    TypeGuard2.TObject = TObject2;
    function TPromise2(schema) {
      return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
    }
    TypeGuard2.TPromise = TPromise2;
    function TRecord2(schema) {
      return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
        const keys = Object.getOwnPropertyNames(schema2.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
      })(schema);
    }
    TypeGuard2.TRecord = TRecord2;
    function TRecursive(schema) {
      return ValueGuard.IsObject(schema) && exports.Hint in schema && schema[exports.Hint] === "Recursive";
    }
    TypeGuard2.TRecursive = TRecursive;
    function TRef2(schema) {
      return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TRef = TRef2;
    function TString2(schema) {
      return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
    }
    TypeGuard2.TString = TString2;
    function TSymbol2(schema) {
      return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TSymbol = TSymbol2;
    function TTemplateLiteral2(schema) {
      return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
    }
    TypeGuard2.TTemplateLiteral = TTemplateLiteral2;
    function TThis2(schema) {
      return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TThis = TThis2;
    function TTransform(schema) {
      return ValueGuard.IsObject(schema) && exports.Transform in schema;
    }
    TypeGuard2.TTransform = TTransform;
    function TTuple2(schema) {
      return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && // empty
      (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
    }
    TypeGuard2.TTuple = TTuple2;
    function TUndefined2(schema) {
      return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUndefined = TUndefined2;
    function TUnionLiteral(schema) {
      return TUnion2(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
    }
    TypeGuard2.TUnionLiteral = TUnionLiteral;
    function TUnion2(schema) {
      return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
    }
    TypeGuard2.TUnion = TUnion2;
    function TUint8Array2(schema) {
      return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    TypeGuard2.TUint8Array = TUint8Array2;
    function TUnknown2(schema) {
      return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUnknown = TUnknown2;
    function TUnsafe(schema) {
      return TKindOf(schema, "Unsafe");
    }
    TypeGuard2.TUnsafe = TUnsafe;
    function TVoid2(schema) {
      return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TVoid = TVoid2;
    function TReadonly(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
    }
    TypeGuard2.TReadonly = TReadonly;
    function TOptional(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
    }
    TypeGuard2.TOptional = TOptional;
    function TSchema(schema) {
      return ValueGuard.IsObject(schema) && (TAny2(schema) || TArray2(schema) || TBoolean2(schema) || TBigInt2(schema) || TAsyncIterator2(schema) || TConstructor2(schema) || TDate2(schema) || TFunction2(schema) || TInteger2(schema) || TIntersect2(schema) || TIterator2(schema) || TLiteral2(schema) || TNever2(schema) || TNot2(schema) || TNull2(schema) || TNumber2(schema) || TObject2(schema) || TPromise2(schema) || TRecord2(schema) || TRef2(schema) || TString2(schema) || TSymbol2(schema) || TTemplateLiteral2(schema) || TThis2(schema) || TTuple2(schema) || TUndefined2(schema) || TUnion2(schema) || TUint8Array2(schema) || TUnknown2(schema) || TUnsafe(schema) || TVoid2(schema) || TKind2(schema) && TypeRegistry.Has(schema[exports.Kind]));
    }
    TypeGuard2.TSchema = TSchema;
  })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function(ExtendsUndefined2) {
    function Check2(schema) {
      return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check2(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check2(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check2(schema.not) : false;
    }
    ExtendsUndefined2.Check = Check2;
  })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));
  class TypeExtendsError extends TypeBoxError {
  }
  exports.TypeExtendsError = TypeExtendsError;
  var TypeExtendsResult;
  (function(TypeExtendsResult2) {
    TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
    TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
    TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
  })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function(TypeExtends2) {
    function IntoBooleanResult(result) {
      return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
    }
    function Throw(message) {
      throw new TypeExtendsError(message);
    }
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    function StructuralRight(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : Throw("StructuralRight");
    }
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TAny2(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TArray2(left, right) {
      return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TAsyncIterator2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TBigInt2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TConstructor2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit2(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.returns, right.returns));
    }
    function TDate2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TFunction2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit2(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.returns, right.returns));
    }
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger2(left, right) {
      return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
    }
    function TIntersectRight(left, right) {
      return right.allOf.every((schema) => Visit2(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect2(left, right) {
      return left.allOf.some((schema) => Visit2(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIterator2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.items, right.items));
    }
    function TLiteral2(left, right) {
      return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeExtendsResult.False;
    }
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    function TNever2(left, right) {
      return TypeExtendsResult.True;
    }
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!TypeGuard.TNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    function TNot2(left, right) {
      return TypeGuard.TNot(left) ? Visit2(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit2(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function TNull2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit2(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit2(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectPromiseLike(schema) {
      const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit2(schema.properties["then"], then)) === TypeExtendsResult.True;
    }
    function Property(left, right) {
      return Visit2(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
        return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeExtendsResult.False;
    }
    function TObject2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties) && !TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.False;
          }
          if (TypeGuard.TOptional(right.properties[key])) {
            return TypeExtendsResult.True;
          }
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })();
    }
    function TPromise2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit2(left.item, right.item));
    }
    function RecordKey(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : exports.PatternStringExact in schema.patternProperties ? exports.Type.String() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : exports.PatternStringExact in schema.patternProperties ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function TRecordRight(left, right) {
      const [Key, Value2] = [RecordKey(right), RecordValue(right)];
      return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit2(left, Value2)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit2(left, Value2) : TypeGuard.TObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value2, left.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })() : TypeExtendsResult.False;
    }
    function TRecord2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit2(RecordValue(left), RecordValue(right));
    }
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TSymbol2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TTemplateLiteral2(left, right) {
      return TypeGuard.TTemplateLiteral(left) ? Visit2(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit2(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== void 0 && left.items.every((schema) => Visit2(schema, right.items) === TypeExtendsResult.True);
    }
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    function TTuple2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit2(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUint8Array2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUndefined2(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnionRight(left, right) {
      return right.anyOf.some((schema) => Visit2(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion2(left, right) {
      return left.anyOf.every((schema) => Visit2(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TUnknown2(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight() : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TString(right) ? TStringRight(left) : TypeGuard.TNumber(right) ? TNumberRight(left) : TypeGuard.TInteger(right) ? TIntegerRight(left) : TypeGuard.TBoolean(right) ? TBooleanRight(left) : TypeGuard.TArray(right) ? TArrayRight(left) : TypeGuard.TTuple(right) ? TTupleRight(left) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid2(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight() : TypeGuard.TAny(right) ? TAnyRight() : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit2(left, right) {
      return (
        // resolvable
        TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral2(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot2(left, right) : (
          // standard
          TypeGuard.TAny(left) ? TAny2(left, right) : TypeGuard.TArray(left) ? TArray2(left, right) : TypeGuard.TBigInt(left) ? TBigInt2(left, right) : TypeGuard.TBoolean(left) ? TBoolean2(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator2(left, right) : TypeGuard.TConstructor(left) ? TConstructor2(left, right) : TypeGuard.TDate(left) ? TDate2(left, right) : TypeGuard.TFunction(left) ? TFunction2(left, right) : TypeGuard.TInteger(left) ? TInteger2(left, right) : TypeGuard.TIntersect(left) ? TIntersect2(left, right) : TypeGuard.TIterator(left) ? TIterator2(left, right) : TypeGuard.TLiteral(left) ? TLiteral2(left, right) : TypeGuard.TNever(left) ? TNever2() : TypeGuard.TNull(left) ? TNull2(left, right) : TypeGuard.TNumber(left) ? TNumber2(left, right) : TypeGuard.TObject(left) ? TObject2(left, right) : TypeGuard.TRecord(left) ? TRecord2(left, right) : TypeGuard.TString(left) ? TString2(left, right) : TypeGuard.TSymbol(left) ? TSymbol2(left, right) : TypeGuard.TTuple(left) ? TTuple2(left, right) : TypeGuard.TPromise(left) ? TPromise2(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array2(left, right) : TypeGuard.TUndefined(left) ? TUndefined2(left, right) : TypeGuard.TUnion(left) ? TUnion2(left, right) : TypeGuard.TUnknown(left) ? TUnknown2(left, right) : TypeGuard.TVoid(left) ? TVoid2(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`)
        )
      );
    }
    function Extends(left, right) {
      return Visit2(left, right);
    }
    TypeExtends2.Extends = Extends;
  })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function(TypeClone2) {
    function ArrayType2(value2) {
      return value2.map((value3) => Visit2(value3));
    }
    function DateType2(value2) {
      return new Date(value2.getTime());
    }
    function Uint8ArrayType2(value2) {
      return new Uint8Array(value2);
    }
    function ObjectType2(value2) {
      const clonedProperties = Object.getOwnPropertyNames(value2).reduce((acc, key) => ({ ...acc, [key]: Visit2(value2[key]) }), {});
      const clonedSymbols = Object.getOwnPropertySymbols(value2).reduce((acc, key) => ({ ...acc, [key]: Visit2(value2[key]) }), {});
      return { ...clonedProperties, ...clonedSymbols };
    }
    function Visit2(value2) {
      return ValueGuard.IsArray(value2) ? ArrayType2(value2) : ValueGuard.IsDate(value2) ? DateType2(value2) : ValueGuard.IsUint8Array(value2) ? Uint8ArrayType2(value2) : ValueGuard.IsObject(value2) ? ObjectType2(value2) : value2;
    }
    function Rest(schemas) {
      return schemas.map((schema) => Type(schema));
    }
    TypeClone2.Rest = Rest;
    function Type(schema, options = {}) {
      return { ...Visit2(schema), ...options };
    }
    TypeClone2.Type = Type;
  })(TypeClone || (exports.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function(IndexedAccessor2) {
    function OptionalUnwrap(schema) {
      return schema.map((schema2) => {
        const { [exports.Optional]: _, ...clone2 } = TypeClone.Type(schema2);
        return clone2;
      });
    }
    function IsIntersectOptional(schema) {
      return schema.every((schema2) => TypeGuard.TOptional(schema2));
    }
    function IsUnionOptional(schema) {
      return schema.some((schema2) => TypeGuard.TOptional(schema2));
    }
    function ResolveIntersect(schema) {
      return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    function ResolveUnion(schema) {
      return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    function ResolveOptional(schema) {
      return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
    }
    function TIntersect2(schema, key) {
      const resolved = schema.allOf.reduce((acc, schema2) => {
        const indexed = Visit2(schema2, key);
        return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports.Type.Intersect(resolved));
    }
    function TUnion2(schema, key) {
      const resolved = schema.anyOf.map((schema2) => Visit2(schema2, key));
      return ResolveOptional(exports.Type.Union(resolved));
    }
    function TObject2(schema, key) {
      const property = schema.properties[key];
      return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    function TTuple2(schema, key) {
      const items = schema.items;
      if (ValueGuard.IsUndefined(items))
        return exports.Type.Never();
      const element = items[key];
      if (ValueGuard.IsUndefined(element))
        return exports.Type.Never();
      return element;
    }
    function Visit2(schema, key) {
      return schema[exports.Kind] === "Intersect" ? TIntersect2(schema, key) : schema[exports.Kind] === "Union" ? TUnion2(schema, key) : schema[exports.Kind] === "Object" ? TObject2(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple2(schema, key) : exports.Type.Never();
    }
    function Resolve(schema, keys, options = {}) {
      const resolved = keys.map((key) => Visit2(schema, key.toString()));
      return ResolveOptional(exports.Type.Union(resolved, options));
    }
    IndexedAccessor2.Resolve = Resolve;
  })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
  var Intrinsic;
  (function(Intrinsic2) {
    function Uncapitalize(value2) {
      const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
      return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value2) {
      const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
      return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value2) {
      return value2.toUpperCase();
    }
    function Lowercase(value2) {
      return value2.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema, mode) {
      const expression = TemplateLiteralParser.ParseExact(schema.pattern);
      const finite = TemplateLiteralFinite.Check(expression);
      if (!finite)
        return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
      const strings = [...TemplateLiteralGenerator.Generate(expression)];
      const literals = strings.map((value2) => exports.Type.Literal(value2));
      const mapped = IntrinsicRest(literals, mode);
      const union = exports.Type.Union(mapped);
      return exports.Type.TemplateLiteral([union]);
    }
    function IntrinsicLiteral(value2, mode) {
      return typeof value2 === "string" ? mode === "Uncapitalize" ? Uncapitalize(value2) : mode === "Capitalize" ? Capitalize(value2) : mode === "Uppercase" ? Uppercase(value2) : mode === "Lowercase" ? Lowercase(value2) : value2 : value2.toString();
    }
    function IntrinsicRest(schema, mode) {
      if (schema.length === 0)
        return [];
      const [L, ...R] = schema;
      return [Map2(L, mode), ...IntrinsicRest(R, mode)];
    }
    function Visit2(schema, mode) {
      return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
    }
    function Map2(schema, mode) {
      return Visit2(schema, mode);
    }
    Intrinsic2.Map = Map2;
  })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
  var ObjectMap;
  (function(ObjectMap2) {
    function TIntersect2(schema, callback) {
      return exports.Type.Intersect(schema.allOf.map((inner) => Visit2(inner, callback)), { ...schema });
    }
    function TUnion2(schema, callback) {
      return exports.Type.Union(schema.anyOf.map((inner) => Visit2(inner, callback)), { ...schema });
    }
    function TObject2(schema, callback) {
      return callback(schema);
    }
    function Visit2(schema, callback) {
      return schema[exports.Kind] === "Intersect" ? TIntersect2(schema, callback) : schema[exports.Kind] === "Union" ? TUnion2(schema, callback) : schema[exports.Kind] === "Object" ? TObject2(schema, callback) : schema;
    }
    function Map2(schema, callback, options) {
      return { ...Visit2(TypeClone.Type(schema), callback), ...options };
    }
    ObjectMap2.Map = Map2;
  })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function(KeyResolver2) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect2(schema, options) {
      return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit2(schema2, options)], []);
    }
    function TUnion2(schema, options) {
      const sets = schema.anyOf.map((inner) => Visit2(inner, options));
      return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], /* @__PURE__ */ new Set())];
    }
    function TObject2(schema, options) {
      return Object.getOwnPropertyNames(schema.properties);
    }
    function TRecord2(schema, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    function Visit2(schema, options) {
      return TypeGuard.TIntersect(schema) ? TIntersect2(schema, options) : TypeGuard.TUnion(schema) ? TUnion2(schema, options) : TypeGuard.TObject(schema) ? TObject2(schema) : TypeGuard.TRecord(schema) ? TRecord2(schema, options) : [];
    }
    function ResolveKeys(schema, options) {
      return [...new Set(Visit2(schema, options))];
    }
    KeyResolver2.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema) {
      const keys = ResolveKeys(schema, { includePatterns: true });
      const pattern2 = keys.map((key) => `(${UnwrapPattern(key)})`);
      return `^(${pattern2.join("|")})$`;
    }
    KeyResolver2.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));
  class KeyArrayResolverError extends TypeBoxError {
  }
  exports.KeyArrayResolverError = KeyArrayResolverError;
  var KeyArrayResolver;
  (function(KeyArrayResolver2) {
    function Resolve(schema) {
      return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      })() : [];
    }
    KeyArrayResolver2.Resolve = Resolve;
  })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function(UnionResolver2) {
    function* TUnion2(union) {
      for (const schema of union.anyOf) {
        if (schema[exports.Kind] === "Union") {
          yield* TUnion2(schema);
        } else {
          yield schema;
        }
      }
    }
    function Resolve(union) {
      return exports.Type.Union([...TUnion2(union)], { ...union });
    }
    UnionResolver2.Resolve = Resolve;
  })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));
  class TemplateLiteralPatternError extends TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  var TemplateLiteralPattern;
  (function(TemplateLiteralPattern2) {
    function Throw(message) {
      throw new TemplateLiteralPatternError(message);
    }
    function Escape(value2) {
      return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit2(schema, acc) {
      return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
    }
    function Create2(kinds) {
      return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
    }
    TemplateLiteralPattern2.Create = Create2;
  })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function(TemplateLiteralResolver2) {
    function Resolve(template) {
      const expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression))
        return exports.Type.String();
      const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value2) => exports.Type.Literal(value2));
      return exports.Type.Union(literals);
    }
    TemplateLiteralResolver2.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));
  class TemplateLiteralParserError extends TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function(TemplateLiteralParser2) {
    function IsNonEscaped(pattern2, index, char) {
      return pattern2[index] === char && pattern2.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern2, index) {
      return IsNonEscaped(pattern2, index, "(");
    }
    function IsCloseParen(pattern2, index) {
      return IsNonEscaped(pattern2, index, ")");
    }
    function IsSeparator(pattern2, index) {
      return IsNonEscaped(pattern2, index, "|");
    }
    function IsGroup(pattern2) {
      if (!(IsOpenParen(pattern2, 0) && IsCloseParen(pattern2, pattern2.length - 1)))
        return false;
      let count = 0;
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (count === 0 && index !== pattern2.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern2) {
      return pattern2.slice(1, pattern2.length - 1);
    }
    function IsPrecedenceOr(pattern2) {
      let count = 0;
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (IsSeparator(pattern2, index) && count === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern2) {
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          return true;
      }
      return false;
    }
    function Or(pattern2) {
      let [count, start] = [0, 0];
      const expressions = [];
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index))
          count += 1;
        if (IsCloseParen(pattern2, index))
          count -= 1;
        if (IsSeparator(pattern2, index) && count === 0) {
          const range2 = pattern2.slice(start, index);
          if (range2.length > 0)
            expressions.push(Parse(range2));
          start = index + 1;
        }
      }
      const range = pattern2.slice(start);
      if (range.length > 0)
        expressions.push(Parse(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And(pattern2) {
      function Group(value2, index) {
        if (!IsOpenParen(value2, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index; scan < value2.length; scan++) {
          if (IsOpenParen(value2, scan))
            count += 1;
          if (IsCloseParen(value2, scan))
            count -= 1;
          if (count === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern3, index) {
        for (let scan = index; scan < pattern3.length; scan++) {
          if (IsOpenParen(pattern3, scan))
            return [index, scan];
        }
        return [index, pattern3.length];
      }
      const expressions = [];
      for (let index = 0; index < pattern2.length; index++) {
        if (IsOpenParen(pattern2, index)) {
          const [start, end] = Group(pattern2, index);
          const range = pattern2.slice(start, end + 1);
          expressions.push(Parse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern2, index);
          const range = pattern2.slice(start, end);
          if (range.length > 0)
            expressions.push(Parse(range));
          index = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function Parse(pattern2) {
      return IsGroup(pattern2) ? Parse(InGroup(pattern2)) : IsPrecedenceOr(pattern2) ? Or(pattern2) : IsPrecedenceAnd(pattern2) ? And(pattern2) : { type: "const", const: pattern2 };
    }
    TemplateLiteralParser2.Parse = Parse;
    function ParseExact(pattern2) {
      return Parse(pattern2.slice(1, pattern2.length - 1));
    }
    TemplateLiteralParser2.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));
  class TemplateLiteralFiniteError extends TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  var TemplateLiteralFinite;
  (function(TemplateLiteralFinite2) {
    function Throw(message) {
      throw new TemplateLiteralFiniteError(message);
    }
    function IsNumber2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBoolean2(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsString2(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function Check2(expression) {
      return IsBoolean2(expression) ? true : IsNumber2(expression) || IsString2(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check2(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check2(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
    }
    TemplateLiteralFinite2.Check = Check2;
  })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));
  class TemplateLiteralGeneratorError extends TypeBoxError {
  }
  exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
  var TemplateLiteralGenerator;
  (function(TemplateLiteralGenerator2) {
    function* Reduce(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of Reduce(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* And(expression) {
      return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
      for (const expr of expression.expr)
        yield* Generate(expr);
    }
    function* Const(expression) {
      return yield expression.const;
    }
    function* Generate(expression) {
      return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
        throw new TemplateLiteralGeneratorError("Unknown expression");
      })();
    }
    TemplateLiteralGenerator2.Generate = Generate;
  })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function(TemplateLiteralDslParser2) {
    function* ParseUnion(template) {
      const trim = template.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      })();
    }
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        const L = exports.Type.Literal("$");
        const R = ParseLiteral(template.slice(1));
        return yield* [L, ...R];
      }
      for (let i2 = 2; i2 < template.length; i2++) {
        if (template[i2] === "}") {
          const L = ParseUnion(template.slice(2, i2));
          const R = ParseLiteral(template.slice(i2 + 1));
          return yield* [...L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function* ParseLiteral(template) {
      for (let i2 = 0; i2 < template.length; i2++) {
        if (template[i2] === "$") {
          const L = exports.Type.Literal(template.slice(0, i2));
          const R = ParseTerminal(template.slice(i2));
          return yield* [L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser2.Parse = Parse;
  })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));
  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;
  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    Encode(encode) {
      const schema = TypeClone.Type(this.schema);
      return TypeGuard.TTransform(schema) ? (() => {
        const Encode = (value2) => schema[exports.Transform].Encode(encode(value2));
        const Decode = (value2) => this.decode(schema[exports.Transform].Decode(value2));
        const Codec = { Encode, Decode };
        return { ...schema, [exports.Transform]: Codec };
      })() : (() => {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [exports.Transform]: Codec };
      })();
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  let TypeOrdinal = 0;
  class TypeBuilderError extends TypeBoxError {
  }
  exports.TypeBuilderError = TypeBuilderError;
  class TypeBuilder {
    /** `[Internal]` Creates a schema without `static` and `params` types */
    Create(schema) {
      return schema;
    }
    /** `[Internal]` Throws a TypeBuilder error with the given message */
    Throw(message) {
      throw new TypeBuilderError(message);
    }
    /** `[Internal]` Discards property keys from the given record type */
    Discard(record, keys) {
      return keys.reduce((acc, key) => {
        const { [key]: _, ...rest } = acc;
        return rest;
      }, record);
    }
    /** `[Json]` Omits compositing symbols from this schema */
    Strict(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
  exports.TypeBuilder = TypeBuilder;
  class JsonTypeBuilder extends TypeBuilder {
    // ------------------------------------------------------------------------
    // Modifiers
    // ------------------------------------------------------------------------
    /** `[Json]` Creates a Readonly and Optional property */
    ReadonlyOptional(schema) {
      return this.Readonly(this.Optional(schema));
    }
    /** `[Json]` Creates a Readonly property */
    Readonly(schema) {
      return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
    }
    /** `[Json]` Creates an Optional property */
    Optional(schema) {
      return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
    }
    // ------------------------------------------------------------------------
    // Types
    // ------------------------------------------------------------------------
    /** `[Json]` Creates an Any type */
    Any(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Any" });
    }
    /** `[Json]` Creates an Array type */
    Array(schema, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
    }
    /** `[Json]` Creates a Boolean type */
    Boolean(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
    }
    /** `[Json]` Intrinsic function to Capitalize LiteralString types */
    Capitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
    }
    /** `[Json]` Creates a Composite object type */
    Composite(objects, options) {
      const intersect = exports.Type.Intersect(objects, {});
      const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
      const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
      return exports.Type.Object(properties, options);
    }
    /** `[Json]` Creates a Enum type */
    Enum(item, options = {}) {
      if (ValueGuard.IsUndefined(item))
        return this.Throw("Enum undefined or empty");
      const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value2) => exports.Type.Literal(value2));
      return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
    }
    /** `[Json]` Creates a Conditional type */
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Type(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Type(falseType, options);
      }
    }
    /** `[Json]` Constructs a type by excluding from unionType all union members that are assignable to excludedMembers */
    Exclude(unionType, excludedMembers, options = {}) {
      return TypeGuard.TTemplateLiteral(unionType) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType) ? (() => {
        const narrowed = unionType.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(unionType, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType, options);
    }
    /** `[Json]` Constructs a type by extracting from type all union members that are assignable to union */
    Extract(type, union, options = {}) {
      return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
        const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
    }
    /** `[Json]` Returns an Indexed property type for the given keys */
    Index(schema, unresolved, options = {}) {
      return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        return TypeClone.Type(schema.items, options);
      })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const cloned = items.map((schema2) => TypeClone.Type(schema2));
        return this.Union(cloned, options);
      })() : (() => {
        const keys = KeyArrayResolver.Resolve(unresolved);
        const clone2 = TypeClone.Type(schema);
        return IndexedAccessor.Resolve(clone2, keys, options);
      })();
    }
    /** `[Json]` Creates an Integer type */
    Integer(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
    }
    /** `[Json]` Creates an Intersect type */
    Intersect(allOf, options = {}) {
      if (allOf.length === 0)
        return exports.Type.Never();
      if (allOf.length === 1)
        return TypeClone.Type(allOf[0], options);
      if (allOf.some((schema) => TypeGuard.TTransform(schema)))
        this.Throw("Cannot intersect transform types");
      const objects = allOf.every((schema) => TypeGuard.TObject(schema));
      const cloned = TypeClone.Rest(allOf);
      const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
    }
    /** `[Json]` Creates a KeyOf type */
    KeyOf(schema, options = {}) {
      return TypeGuard.TRecord(schema) ? (() => {
        const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
        return pattern2 === exports.PatternNumberExact ? this.Number(options) : pattern2 === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : TypeGuard.TTuple(schema) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
        return this.Union(literals, options);
      })() : TypeGuard.TArray(schema) ? (() => {
        return this.Number(options);
      })() : (() => {
        const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
        if (keys.length === 0)
          return this.Never(options);
        const literals = keys.map((key) => this.Literal(key));
        return this.Union(literals, options);
      })();
    }
    /** `[Json]` Creates a Literal type */
    Literal(value2, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Literal", const: value2, type: typeof value2 });
    }
    /** `[Json]` Intrinsic function to Lowercase LiteralString types */
    Lowercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
    }
    /** `[Json]` Creates a Never type */
    Never(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
    }
    /** `[Json]` Creates a Not type */
    Not(schema, options) {
      return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
    }
    /** `[Json]` Creates a Null type */
    Null(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
    }
    /** `[Json]` Creates a Number type */
    Number(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
    }
    /** `[Json]` Creates an Object type */
    Object(properties, options = {}) {
      const propertyKeys = Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
      const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
      const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
      const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
      return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
    }
    /** `[Json]` Constructs a type whose keys are omitted from the given type */
    Omit(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => !keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    /** `[Json]` Constructs a type where all properties are optional */
    Partial(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Optional(object.properties[key]) };
        }, {});
        return this.Object(
          properties,
          this.Discard(object, ["required"])
          /* object used as options to retain other constraints */
        );
      }, options);
    }
    /** `[Json]` Constructs a type whose keys are picked from the given type */
    Pick(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (!keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    /** `[Json]` Creates a Record type */
    Record(key, schema, options = {}) {
      return TypeGuard.TTemplateLiteral(key) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
      })() : TypeGuard.TUnion(key) ? (() => {
        const union = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union)) {
          const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
          return this.Object(properties, { ...options, [exports.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : TypeGuard.TLiteral(key) ? (() => {
        return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
      })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
      })() : TypeGuard.TString(key) ? (() => {
        const pattern2 = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern2]: TypeClone.Type(schema) } });
      })() : this.Never();
    }
    /** `[Json]` Creates a Recursive type */
    Recursive(callback, options = {}) {
      if (ValueGuard.IsUndefined(options.$id))
        options.$id = `T${TypeOrdinal++}`;
      const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
    }
    /** `[Json]` Creates a Ref type. */
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved))
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
      if (ValueGuard.IsUndefined(unresolved.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
    }
    /** `[Json]` Constructs a type where all properties are required */
    Required(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
        }, {});
        return this.Object(
          properties,
          object
          /* object used as options to retain other constraints  */
        );
      }, options);
    }
    /** `[Json]` Extracts interior Rest elements from Tuple, Intersect and Union types */
    Rest(schema) {
      return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
    }
    /** `[Json]` Creates a String type */
    String(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
    }
    /** `[Json]` Creates a TemplateLiteral type */
    TemplateLiteral(unresolved, options = {}) {
      const pattern2 = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern: pattern2 });
    }
    /** `[Json]` Creates a Transform type */
    Transform(schema) {
      return new TransformDecodeBuilder(schema);
    }
    /** `[Json]` Creates a Tuple type */
    Tuple(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      const clonedItems = TypeClone.Rest(items);
      const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
      return this.Create(schema);
    }
    /** `[Json]` Intrinsic function to Uncapitalize LiteralString types */
    Uncapitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
    }
    /** `[Json]` Creates a Union type */
    Union(union, options = {}) {
      return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
        const anyOf = union;
        if (anyOf.length === 0)
          return this.Never(options);
        if (anyOf.length === 1)
          return this.Create(TypeClone.Type(anyOf[0], options));
        const clonedAnyOf = TypeClone.Rest(anyOf);
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
      })();
    }
    /** `[Json]` Creates an Unknown type */
    Unknown(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Unknown" });
    }
    /** `[Json]` Creates a Unsafe type that will infers as the generic argument T */
    Unsafe(options = {}) {
      return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
    }
    /** `[Json]` Intrinsic function to Uppercase LiteralString types */
    Uppercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;
  class JavaScriptTypeBuilder extends JsonTypeBuilder {
    /** `[JavaScript]` Creates a AsyncIterator type */
    AsyncIterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
    }
    /** `[JavaScript]` Constructs a type by recursively unwrapping Promise types */
    Awaited(schema, options = {}) {
      const Unwrap = (rest) => rest.length > 0 ? (() => {
        const [L, ...R] = rest;
        return [this.Awaited(L), ...Unwrap(R)];
      })() : rest;
      return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
    }
    /** `[JavaScript]` Creates a BigInt type */
    BigInt(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
    }
    /** `[JavaScript]` Extracts the ConstructorParameters from the given Constructor type */
    ConstructorParameters(schema, options = {}) {
      return this.Tuple([...schema.parameters], { ...options });
    }
    /** `[JavaScript]` Creates a Constructor type */
    Constructor(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[JavaScript]` Creates a Date type */
    Date(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
    }
    /** `[JavaScript]` Creates a Function type */
    Function(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
    }
    /** `[JavaScript]` Extracts the InstanceType from the given Constructor type */
    InstanceType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    /** `[JavaScript]` Creates an Iterator type */
    Iterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
    }
    /** `[JavaScript]` Extracts the Parameters from the given Function type */
    Parameters(schema, options = {}) {
      return this.Tuple(schema.parameters, { ...options });
    }
    /** `[JavaScript]` Creates a Promise type */
    Promise(item, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
    }
    /** `[Extended]` Creates a String type */
    RegExp(unresolved, options = {}) {
      const pattern2 = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern: pattern2 });
    }
    /**
     * @deprecated Use `Type.RegExp`
     */
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    /** `[JavaScript]` Extracts the ReturnType from the given Function type */
    ReturnType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    /** `[JavaScript]` Creates a Symbol type */
    Symbol(options) {
      return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
    }
    /** `[JavaScript]` Creates a Undefined type */
    Undefined(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
    }
    /** `[JavaScript]` Creates a Uint8Array type */
    Uint8Array(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    /** `[JavaScript]` Creates a Void type */
    Void(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  exports.JsonType = new JsonTypeBuilder();
  exports.Type = new JavaScriptTypeBuilder();
})(typebox);
const pattern$1 = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
const LanguageTag$1 = typebox.Type.String({
  pattern: pattern$1,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"]
});
function lookup(languageTag, options) {
  const fallbackLanguages = [];
  const languageTagParts = languageTag.split("-").filter(Boolean);
  for (let i2 = languageTagParts.length; i2 > 0; i2--) {
    if (languageTagParts[i2 - 1] === "x")
      continue;
    const fallbackLanguageTag = languageTagParts.slice(0, i2).join("-");
    if (!options.languageTags.includes(fallbackLanguageTag))
      continue;
    fallbackLanguages.push(fallbackLanguageTag);
  }
  return fallbackLanguages[0] ?? options.defaultLanguageTag;
}
const Translatable = (type) => typebox.Type.Union([type, typebox.Type.Intersect([typebox.Type.Object({ en: type }), typebox.Type.Record(LanguageTag$1, type)])]);
const JSONValue1 = typebox.Type.Union([typebox.Type.String(), typebox.Type.Number(), typebox.Type.Boolean(), typebox.Type.Null()]);
const JSONArray1 = typebox.Type.Array(JSONValue1);
const JSONObject1 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONArray1, JSONValue1]));
const JSONValue2 = typebox.Type.Union([JSONValue1, JSONObject1]);
const JSONArray2 = typebox.Type.Array(JSONValue2);
const JSONObject2 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue2, JSONArray2]));
const JSONValue3 = typebox.Type.Union([JSONValue2, JSONObject2]);
const JSONArray3 = typebox.Type.Array(JSONValue3);
const JSONObject3 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue3, JSONArray3]));
const JSONValue4 = typebox.Type.Union([JSONValue3, JSONObject3]);
const JSONArray4 = typebox.Type.Array(JSONValue4);
const JSONObject4 = typebox.Type.Record(typebox.Type.String(), typebox.Type.Union([JSONValue4, JSONArray4]));
const JSON$1 = typebox.Type.Union([JSONObject4, JSONValue4, JSONArray4]);
const _MessageLintRuleId = typebox.Type.String({
  pattern: "^messageLintRule\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
  description: "The key must be conform to `messageLintRule.{namespace}.{id}` pattern.",
  examples: [
    "messageLintRule.namespace.patternInvalid",
    "messageLintRule.namespace.missingTranslation"
  ]
});
const _MessageLintRuleLevel = typebox.Type.Union([typebox.Type.Literal("error"), typebox.Type.Literal("warning")]);
const SourceLanguageTag = LanguageTag$1;
SourceLanguageTag.title = "Source language tag";
SourceLanguageTag.description = "Set the reference language for your project. It needs to be a valid BCP-47 language tag.";
const InternalProjectSettings = typebox.Type.Object({
  $schema: typebox.Type.Optional(typebox.Type.Literal("https://inlang.com/schema/project-settings")),
  sourceLanguageTag: SourceLanguageTag,
  languageTags: typebox.Type.Array(LanguageTag$1, {
    uniqueItems: true,
    title: "Language tags",
    description: "Set the languages that are available in your project. All language tags needs to be a valid BCP-47 language tag. Needs to include the source language tag."
  }),
  /**
   * The modules to load.
   *
   * @example
   *  modules: [
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
   * 	  "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
   *  ]
   */
  modules: typebox.Type.Array(typebox.Type.Intersect([
    typebox.Type.String({
      pattern: "(?:[A-Za-z][A-Za-z0-9+.-]*:/{2})?(?:(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})+(?::([A-Za-z0-9-._~]?|[%][A-Fa-f0-9]{2})+)?@)?(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\.){1,126}[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?(?::[0-9]+)?(?:/(?:[A-Za-z0-9-._~]|%[A-Fa-f0-9]{2})*)*(?:\\?(?:[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)(?:&|;[A-Za-z0-9-._~]+(?:=(?:[A-Za-z0-9-._~+]|%[A-Fa-f0-9]{2})+)?)*)?",
      description: "The module must be a valid URI according to RFC 3986."
    }),
    typebox.Type.String({
      pattern: ".*\\.js$",
      description: "The module must end with `.js`."
    }),
    typebox.Type.String({
      pattern: "^(?!.*@\\d\\.)[^]*$",
      description: "The module can only contain a major version number."
    })
  ]), {
    uniqueItems: true,
    description: "The modules to load. Must be a valid URI but can be relative.",
    examples: [
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-i18next@3/dist/index.js",
      "https://cdn.jsdelivr.net/npm/@inlang/plugin-csv@1/dist/index.js",
      "./local-testing-plugin.js"
    ]
  }),
  messageLintRuleLevels: typebox.Type.Optional(typebox.Type.Record(_MessageLintRuleId, _MessageLintRuleLevel, {
    title: "Levels for lint rules",
    description: "Adjust the lint rule levels in your project to choose between 'warning' and 'error'. If set to 'error', you can configure a CI process to prevent merging with existing reports. (When you want to configure your lint rules visit inlang.com/c/lint-rules)",
    examples: [
      {
        "messageLintRule.inlang.missingTranslation": "error",
        "messageLintRule.inlang.patternInvalid": "warning"
      }
    ]
  })),
  experimental: typebox.Type.Optional(typebox.Type.Record(typebox.Type.String(), typebox.Type.Literal(true), {
    title: "Experimental settings",
    description: "Experimental settings that are used for product development."
  }))
});
const ExternalProjectSettings = typebox.Type.Record(
  typebox.Type.String({
    // pattern includes ProjectSettings keys
    pattern: `^((messageLintRule|plugin|app|library)\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)|\\$schema|${Object.keys(InternalProjectSettings.properties).map((key) => key.replaceAll(".", "\\.")).join("|")})$`,
    description: "The key must be conform to `{type:app|plugin|messageLintRule}.{namespace:string}.{id:string}`.",
    examples: ["plugin.publisher.sqlite", "messageLintRule.inlang.missingTranslation"]
  }),
  // Using JSON (array and object) as a workaround to make the
  // intersection between `InternalSettings`, which contains an array,
  // and `ExternalSettings` which are objects possible
  JSON$1,
  { description: "Settings defined by apps, plugins, etc." }
);
const ProjectSettings = typebox.Type.Intersect([InternalProjectSettings, ExternalProjectSettings]);
const MessageLintRule = typebox.Type.Object({
  id: _MessageLintRuleId,
  displayName: Translatable(typebox.Type.String()),
  description: Translatable(typebox.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: typebox.Type.Optional(typebox.Type.Object({}, { additionalProperties: true }))
});
const MessageReferenceMatch = typebox.Type.Object({
  /**
   * The messages id.
   */
  messageId: typebox.Type.String(),
  /**
   * The position from where to where the reference can be found.
   */
  position: typebox.Type.Object({
    start: typebox.Type.Object({
      line: typebox.Type.Number(),
      character: typebox.Type.Number()
    }),
    end: typebox.Type.Object({
      line: typebox.Type.Number(),
      character: typebox.Type.Number()
    })
  })
});
typebox.Type.Object({
  /**
   * Defines matchers for message references inside the code.
   *
   * @param args represents the data to conduct the search on
   * @returns a promise with matched message references
   */
  messageReferenceMatchers: typebox.Type.Array(typebox.Type.Function([
    typebox.Type.Object({
      documentText: typebox.Type.String()
    })
  ], typebox.Type.Promise(typebox.Type.Array(MessageReferenceMatch)))),
  /**
   * Defines the options to extract messages.
   */
  extractMessageOptions: typebox.Type.Array(typebox.Type.Object({
    /**
     * Function which is called, when the user finished the message extraction command.
     *
     * @param messageId is the message identifier entered by the user
     * @param selection is the text which was extracted
     * @returns the code which is inserted into the document
     */
    callback: typebox.Type.Function([
      typebox.Type.Object({
        messageId: typebox.Type.String(),
        selection: typebox.Type.String()
      })
    ], typebox.Type.Object({
      messageId: typebox.Type.String(),
      messageReplacement: typebox.Type.String()
    }))
  })),
  /**
   * An array of Visual Studio Code DocumentSelectors.
   *
   * The document selectors specify for which files/programming languages
   * (typescript, svelte, etc.) the extension should be activated.
   *
   * See https://code.visualstudio.com/api/references/document-selector
   */
  documentSelectors: typebox.Type.Optional(typebox.Type.Array(typebox.Type.Object({
    language: typebox.Type.Optional(typebox.Type.String())
  })))
});
const Plugin = typebox.Type.Object({
  id: typebox.Type.String({
    pattern: "^plugin\\.([a-z][a-zA-Z0-9]*)\\.([a-z][a-zA-Z0-9]*(?:[A-Z][a-z0-9]*)*)$",
    examples: ["plugin.namespace.id"]
  }),
  displayName: Translatable(typebox.Type.String()),
  description: Translatable(typebox.Type.String()),
  /**
   * Tyepbox is must be used to validate the Json Schema.
   * Github discussion to upvote a plain Json Schema validator and read the benefits of Typebox
   * https://github.com/opral/monorepo/discussions/1503
   */
  settingsSchema: typebox.Type.Optional(typebox.Type.Object({}, { additionalProperties: true })),
  loadMessages: typebox.Type.Optional(typebox.Type.Any()),
  saveMessages: typebox.Type.Optional(typebox.Type.Any()),
  /**
   * @deprecated removed
   */
  detectedLanguageTags: typebox.Type.Optional(typebox.Type.Any()),
  addCustomApi: typebox.Type.Optional(typebox.Type.Any())
});
const Text$1 = typebox.Type.Object({
  type: typebox.Type.Literal("Text"),
  value: typebox.Type.String()
});
const VariableReference$1 = typebox.Type.Object({
  type: typebox.Type.Literal("VariableReference"),
  name: typebox.Type.String()
});
const Expression$1 = typebox.Type.Union([VariableReference$1]);
const Pattern$1 = typebox.Type.Array(typebox.Type.Union([Text$1, Expression$1]));
const Variant$1 = typebox.Type.Object({
  languageTag: LanguageTag$1,
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: typebox.Type.Array(typebox.Type.String()),
  pattern: Pattern$1
});
typebox.Type.Object({
  id: typebox.Type.String(),
  alias: typebox.Type.Record(typebox.Type.String(), typebox.Type.String()),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: typebox.Type.Array(Expression$1),
  variants: typebox.Type.Array(Variant$1)
});
const InlangModule = typebox.Type.Object({
  default: typebox.Type.Union([Plugin, MessageLintRule])
});
class PluginHasInvalidIdError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" has an invalid id. The id must:
1) Start with "plugin."
2) camelCase
3) Contain a namespace.
An example would be "plugin.namespace.myPlugin".`);
    this.name = "PluginHasInvalidIdError";
  }
}
class PluginHasInvalidSchemaError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" has an invalid schema:

${options.errors.map((error) => `Path "${error.path}" with value "${error.value}": "${error.message}"`).join("\n")})}

Please refer to the documentation for the correct schema.`);
    this.name = "PluginHasInvalidSchemaError";
  }
}
class PluginLoadMessagesFunctionAlreadyDefinedError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" defines the \`loadMessages()\` function, but it was already defined by another plugin.

Inlang only allows one plugin to define the \`loadMessages()\` function.`);
    this.name = "PluginLoadMessagesFunctionAlreadyDefinedError";
  }
}
class PluginSaveMessagesFunctionAlreadyDefinedError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" defines the \`saveMessages()\` function, but it was already defined by another plugin.

Inlang only allows one plugin to define the \`saveMessages()\` function.`);
    this.name = "PluginSaveMessagesFunctionAlreadyDefinedError";
  }
}
class PluginReturnedInvalidCustomApiError extends Error {
  constructor(options) {
    super(`Plugin "${options.id}" returned an invalid custom API:

${options.cause}`, options);
    this.name = "PluginReturnedInvalidCustomApiError";
  }
}
class PluginsDoNotProvideLoadOrSaveMessagesError extends Error {
  constructor() {
    super(`No plugin provides a \`loadMessages()\` or \`saveMessages()\` function

In case no plugin threw an error, you likely forgot to add a plugin that handles the loading and saving of messages. Refer to the marketplace for available plugins https://inlang.com/marketplace.`);
    this.name = "PluginsDoNotProvideLoadOrSaveMessagesError";
  }
}
class MessageLintRuleIsInvalidError extends Error {
  constructor(options) {
    super(`The message lint rule "${options.id}" is invalid:

${options.errors.join("\n")}`);
    this.name = "MessageLintRuleIsInvalidError";
  }
}
class ModuleError extends Error {
  module;
  constructor(message, options) {
    super(message);
    this.name = "ModuleError";
    this.module = options.module;
    this.cause = options.cause;
  }
}
class ModuleHasNoExportsError extends ModuleError {
  constructor(options) {
    super(`Module "${options.module}" has no exports. Every module must have an "export default".`, options);
    this.name = "ModuleHasNoExportsError";
  }
}
class ModuleImportError extends ModuleError {
  constructor(options) {
    super(`Couldn't import the plugin "${options.module}":

${options.cause}`, options);
    this.name = "ModuleImportError";
  }
}
class ModuleExportIsInvalidError extends ModuleError {
  constructor(options) {
    super(`The export(s) of "${options.module}" are invalid:

${options.errors.map((error) => `"${error.path}" "${JSON.stringify(error.value, void 0, 2)}": "${error.message}"`).join("\n")}`, options);
    this.name = "ModuleExportIsInvalidError";
  }
}
class ModuleSettingsAreInvalidError extends ModuleError {
  constructor(options) {
    super(`The settings are invalid of "${options.module}" are invalid:

${options.errors.map((error) => `Path "${error.path}" with value "${JSON.stringify(error.value, void 0, 2)}": "${error.message}"`).join("\n")}`, options);
    this.name = "ModuleSettingsAreInvalidError";
  }
}
function tryCatch(callback) {
  try {
    const callbackResult = callback();
    if (isAsync(callbackResult)) {
      return callbackResult.then((data) => ({ data })).catch(getErrorResponse);
    }
    return { data: callbackResult };
  } catch (e) {
    return getErrorResponse(e);
  }
}
const getErrorResponse = (error) => {
  if (error instanceof Error) {
    return { error };
  }
  return { error: new Error(`Unknown error has been caught: ${error}`, { cause: error }) };
};
const isAsync = (p) => !!p && typeof p === "object" && typeof p.then === "function";
var value$1 = {};
var errors$1 = {};
var errors = {};
var guard = {};
Object.defineProperty(guard, "__esModule", { value: true });
guard.IsValueType = guard.IsSymbol = guard.IsFunction = guard.IsString = guard.IsBigInt = guard.IsInteger = guard.IsNumber = guard.IsBoolean = guard.IsNull = guard.IsUndefined = guard.IsArray = guard.IsObject = guard.IsPlainObject = guard.HasPropertyKey = guard.IsDate = guard.IsUint8Array = guard.IsPromise = guard.IsTypedArray = guard.IsIterator = guard.IsAsyncIterator = void 0;
function IsAsyncIterator(value2) {
  return IsObject(value2) && Symbol.asyncIterator in value2;
}
guard.IsAsyncIterator = IsAsyncIterator;
function IsIterator(value2) {
  return IsObject(value2) && Symbol.iterator in value2;
}
guard.IsIterator = IsIterator;
function IsTypedArray(value2) {
  return ArrayBuffer.isView(value2);
}
guard.IsTypedArray = IsTypedArray;
function IsPromise(value2) {
  return value2 instanceof Promise;
}
guard.IsPromise = IsPromise;
function IsUint8Array(value2) {
  return value2 instanceof Uint8Array;
}
guard.IsUint8Array = IsUint8Array;
function IsDate(value2) {
  return value2 instanceof Date && Number.isFinite(value2.getTime());
}
guard.IsDate = IsDate;
function HasPropertyKey(value2, key) {
  return key in value2;
}
guard.HasPropertyKey = HasPropertyKey;
function IsPlainObject(value2) {
  return IsObject(value2) && IsFunction(value2.constructor) && value2.constructor.name === "Object";
}
guard.IsPlainObject = IsPlainObject;
function IsObject(value2) {
  return value2 !== null && typeof value2 === "object";
}
guard.IsObject = IsObject;
function IsArray(value2) {
  return Array.isArray(value2) && !ArrayBuffer.isView(value2);
}
guard.IsArray = IsArray;
function IsUndefined(value2) {
  return value2 === void 0;
}
guard.IsUndefined = IsUndefined;
function IsNull(value2) {
  return value2 === null;
}
guard.IsNull = IsNull;
function IsBoolean(value2) {
  return typeof value2 === "boolean";
}
guard.IsBoolean = IsBoolean;
function IsNumber(value2) {
  return typeof value2 === "number";
}
guard.IsNumber = IsNumber;
function IsInteger(value2) {
  return IsNumber(value2) && Number.isInteger(value2);
}
guard.IsInteger = IsInteger;
function IsBigInt(value2) {
  return typeof value2 === "bigint";
}
guard.IsBigInt = IsBigInt;
function IsString(value2) {
  return typeof value2 === "string";
}
guard.IsString = IsString;
function IsFunction(value2) {
  return typeof value2 === "function";
}
guard.IsFunction = IsFunction;
function IsSymbol(value2) {
  return typeof value2 === "symbol";
}
guard.IsSymbol = IsSymbol;
function IsValueType(value2) {
  return IsBigInt(value2) || IsBoolean(value2) || IsNull(value2) || IsNumber(value2) || IsString(value2) || IsSymbol(value2) || IsUndefined(value2);
}
guard.IsValueType = IsValueType;
var system$1 = {};
var hasRequiredSystem;
function requireSystem() {
  if (hasRequiredSystem)
    return system$1;
  hasRequiredSystem = 1;
  Object.defineProperty(system$1, "__esModule", { value: true });
  system$1.DefaultErrorFunction = system$1.TypeSystemPolicy = system$1.TypeSystemErrorFunction = system$1.TypeSystem = system$1.TypeSystemDuplicateFormat = system$1.TypeSystemDuplicateTypeKind = void 0;
  const guard_12 = guard;
  const errors_12 = requireErrors();
  const Types2 = typebox;
  class TypeSystemDuplicateTypeKind extends Types2.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  system$1.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
  class TypeSystemDuplicateFormat extends Types2.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  system$1.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check2) {
      if (Types2.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      Types2.TypeRegistry.Set(kind, check2);
      return (options = {}) => Types2.Type.Unsafe({ ...options, [Types2.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check2) {
      if (Types2.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      Types2.FormatRegistry.Set(format, check2);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (system$1.TypeSystem = TypeSystem = {}));
  var TypeSystemErrorFunction;
  (function(TypeSystemErrorFunction2) {
    let errorMessageFunction = DefaultErrorFunction;
    function Reset() {
      errorMessageFunction = DefaultErrorFunction;
    }
    TypeSystemErrorFunction2.Reset = Reset;
    function Set2(callback) {
      errorMessageFunction = callback;
    }
    TypeSystemErrorFunction2.Set = Set2;
    function Get() {
      return errorMessageFunction;
    }
    TypeSystemErrorFunction2.Get = Get;
  })(TypeSystemErrorFunction || (system$1.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value2, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value2 : value2[key] !== void 0;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value2) {
      const isObject = (0, guard_12.IsObject)(value2);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, guard_12.IsArray)(value2);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value2) {
      return IsObjectLike(value2) && !(value2 instanceof Date) && !(value2 instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value2) {
      const isNumber = (0, guard_12.IsNumber)(value2);
      return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value2);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value2) {
      const isUndefined = (0, guard_12.IsUndefined)(value2);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value2 === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (system$1.TypeSystemPolicy = TypeSystemPolicy = {}));
  function DefaultErrorFunction(schema, errorType) {
    switch (errorType) {
      case errors_12.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_12.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${schema.maxContains} matching values`;
      case errors_12.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${schema.minContains} matching values`;
      case errors_12.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${schema.maxItems}`;
      case errors_12.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${schema.minItems}`;
      case errors_12.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_12.ValueErrorType.Array:
        return "Expected array";
      case errors_12.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_12.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_12.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_12.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
      case errors_12.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
      case errors_12.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
      case errors_12.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
      case errors_12.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
      case errors_12.ValueErrorType.Date:
        return "Expected Date";
      case errors_12.ValueErrorType.Function:
        return "Expected function";
      case errors_12.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Integer:
        return "Expected integer";
      case errors_12.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_12.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_12.ValueErrorType.Literal:
        return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
      case errors_12.ValueErrorType.Never:
        return "Never";
      case errors_12.ValueErrorType.Not:
        return "Value should not match";
      case errors_12.ValueErrorType.Null:
        return "Expected null";
      case errors_12.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${schema.exclusiveMaximum}`;
      case errors_12.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${schema.exclusiveMinimum}`;
      case errors_12.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${schema.maximum}`;
      case errors_12.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${schema.minimum}`;
      case errors_12.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${schema.multipleOf}`;
      case errors_12.ValueErrorType.Number:
        return "Expected number";
      case errors_12.ValueErrorType.Object:
        return "Expected object";
      case errors_12.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_12.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${schema.maxProperties} properties`;
      case errors_12.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${schema.minProperties} properties`;
      case errors_12.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_12.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_12.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${schema.format}'`;
      case errors_12.ValueErrorType.StringFormat:
        return `Expected string to match '${schema.format}' format`;
      case errors_12.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${schema.maxLength}`;
      case errors_12.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${schema.minLength}`;
      case errors_12.ValueErrorType.StringPattern:
        return `Expected string to match '${schema.pattern}'`;
      case errors_12.ValueErrorType.String:
        return "Expected string";
      case errors_12.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_12.ValueErrorType.TupleLength:
        return `Expected tuple to have ${schema.maxItems || 0} elements`;
      case errors_12.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_12.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${schema.maxByteLength}`;
      case errors_12.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${schema.minByteLength}`;
      case errors_12.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_12.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_12.ValueErrorType.Union:
        return "Expected union value";
      case errors_12.ValueErrorType.Void:
        return "Expected void";
      case errors_12.ValueErrorType.Kind:
        return `Expected kind '${schema[Types2.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  system$1.DefaultErrorFunction = DefaultErrorFunction;
  return system$1;
}
var deref = {};
Object.defineProperty(deref, "__esModule", { value: true });
deref.Deref = deref.TypeDereferenceError = void 0;
const typebox_1 = typebox;
class TypeDereferenceError extends typebox_1.TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
}
deref.TypeDereferenceError = TypeDereferenceError;
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}
deref.Deref = Deref;
var hash$1 = {};
Object.defineProperty(hash$1, "__esModule", { value: true });
hash$1.Hash = hash$1.ByteMarker = hash$1.ValueHashError = void 0;
const guard_1$9 = guard;
class ValueHashError extends Error {
  constructor(value2) {
    super(`Unable to hash value`);
    this.value = value2;
  }
}
hash$1.ValueHashError = ValueHashError;
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (hash$1.ByteMarker = ByteMarker = {}));
let Accumulator = BigInt("14695981039346656037");
const [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
const Bytes = Array.from({ length: 256 }).map((_, i2) => BigInt(i2));
const F64 = new Float64Array(1);
const F64In = new DataView(F64.buffer);
const F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value2) {
  const byteCount = value2 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value2) + 1) / 8);
  for (let i2 = 0; i2 < byteCount; i2++) {
    yield value2 >> 8 * (byteCount - 1 - i2) & 255;
  }
}
function ArrayType$3(value2) {
  FNV1A64(ByteMarker.Array);
  for (const item of value2) {
    Visit$5(item);
  }
}
function BooleanType(value2) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value2 ? 1 : 0);
}
function BigIntType(value2) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value2);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType$2(value2) {
  FNV1A64(ByteMarker.Date);
  Visit$5(value2.getTime());
}
function NullType(value2) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value2) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value2);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType$3(value2) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value2).sort()) {
    Visit$5(key);
    Visit$5(value2[key]);
  }
}
function StringType(value2) {
  FNV1A64(ByteMarker.String);
  for (let i2 = 0; i2 < value2.length; i2++) {
    for (const byte of NumberToBytes(value2.charCodeAt(i2))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value2) {
  FNV1A64(ByteMarker.Symbol);
  Visit$5(value2.description);
}
function Uint8ArrayType(value2) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i2 = 0; i2 < value2.length; i2++) {
    FNV1A64(value2[i2]);
  }
}
function UndefinedType(value2) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit$5(value2) {
  if ((0, guard_1$9.IsArray)(value2))
    return ArrayType$3(value2);
  if ((0, guard_1$9.IsBoolean)(value2))
    return BooleanType(value2);
  if ((0, guard_1$9.IsBigInt)(value2))
    return BigIntType(value2);
  if ((0, guard_1$9.IsDate)(value2))
    return DateType$2(value2);
  if ((0, guard_1$9.IsNull)(value2))
    return NullType();
  if ((0, guard_1$9.IsNumber)(value2))
    return NumberType(value2);
  if ((0, guard_1$9.IsPlainObject)(value2))
    return ObjectType$3(value2);
  if ((0, guard_1$9.IsString)(value2))
    return StringType(value2);
  if ((0, guard_1$9.IsSymbol)(value2))
    return SymbolType(value2);
  if ((0, guard_1$9.IsUint8Array)(value2))
    return Uint8ArrayType(value2);
  if ((0, guard_1$9.IsUndefined)(value2))
    return UndefinedType();
  throw new ValueHashError(value2);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value2) {
  Accumulator = BigInt("14695981039346656037");
  Visit$5(value2);
  return Accumulator;
}
hash$1.Hash = Hash;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors)
    return errors;
  hasRequiredErrors = 1;
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.Errors = errors.ValueErrorIterator = errors.EscapeKey = errors.ValueErrorsUnknownTypeError = errors.ValueErrorType = void 0;
  const guard_12 = guard;
  const system_1 = requireSystem();
  const deref_12 = deref;
  const hash_12 = hash$1;
  const Types2 = typebox;
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
  })(ValueErrorType || (errors.ValueErrorType = ValueErrorType = {}));
  class ValueErrorsUnknownTypeError extends Types2.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  errors.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  errors.EscapeKey = EscapeKey;
  function IsDefined2(value2) {
    return value2 !== void 0;
  }
  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    /** Returns the first value error or undefined if no errors */
    First() {
      const next = this.iterator.next();
      return next.done ? void 0 : next.value;
    }
  }
  errors.ValueErrorIterator = ValueErrorIterator;
  function Create2(type, schema, path, value2) {
    return { type, schema, path, value: value2, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };
  }
  function* TAny2(schema, references, path, value2) {
  }
  function* TArray2(schema, references, path, value2) {
    if (!(0, guard_12.IsArray)(value2)) {
      return yield Create2(ValueErrorType.Array, schema, path, value2);
    }
    if (IsDefined2(schema.minItems) && !(value2.length >= schema.minItems)) {
      yield Create2(ValueErrorType.ArrayMinItems, schema, path, value2);
    }
    if (IsDefined2(schema.maxItems) && !(value2.length <= schema.maxItems)) {
      yield Create2(ValueErrorType.ArrayMaxItems, schema, path, value2);
    }
    for (let i2 = 0; i2 < value2.length; i2++) {
      yield* Visit2(schema.items, references, `${path}/${i2}`, value2[i2]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = /* @__PURE__ */ new Set();
      for (const element of value2) {
        const hashed = (0, hash_12.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create2(ValueErrorType.ArrayUniqueItems, schema, path, value2);
    }
    if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined2(schema.contains) ? schema.contains : Types2.Type.Never();
    const containsCount = value2.reduce((acc, value3, index) => Visit2(containsSchema, references, `${path}${index}`, value3).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create2(ValueErrorType.ArrayContains, schema, path, value2);
    }
    if ((0, guard_12.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create2(ValueErrorType.ArrayMinContains, schema, path, value2);
    }
    if ((0, guard_12.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create2(ValueErrorType.ArrayMaxContains, schema, path, value2);
    }
  }
  function* TAsyncIterator2(schema, references, path, value2) {
    if (!(0, guard_12.IsAsyncIterator)(value2))
      yield Create2(ValueErrorType.AsyncIterator, schema, path, value2);
  }
  function* TBigInt2(schema, references, path, value2) {
    if (!(0, guard_12.IsBigInt)(value2))
      return yield Create2(ValueErrorType.BigInt, schema, path, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.BigIntExclusiveMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.BigIntExclusiveMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.BigIntMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.BigIntMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === BigInt(0))) {
      yield Create2(ValueErrorType.BigIntMultipleOf, schema, path, value2);
    }
  }
  function* TBoolean2(schema, references, path, value2) {
    if (!(0, guard_12.IsBoolean)(value2))
      yield Create2(ValueErrorType.Boolean, schema, path, value2);
  }
  function* TConstructor2(schema, references, path, value2) {
    yield* Visit2(schema.returns, references, path, value2.prototype);
  }
  function* TDate2(schema, references, path, value2) {
    if (!(0, guard_12.IsDate)(value2))
      return yield Create2(ValueErrorType.Date, schema, path, value2);
    if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value2.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create2(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value2);
    }
    if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value2.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create2(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value2);
    }
    if (IsDefined2(schema.maximumTimestamp) && !(value2.getTime() <= schema.maximumTimestamp)) {
      yield Create2(ValueErrorType.DateMaximumTimestamp, schema, path, value2);
    }
    if (IsDefined2(schema.minimumTimestamp) && !(value2.getTime() >= schema.minimumTimestamp)) {
      yield Create2(ValueErrorType.DateMinimumTimestamp, schema, path, value2);
    }
    if (IsDefined2(schema.multipleOfTimestamp) && !(value2.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create2(ValueErrorType.DateMultipleOfTimestamp, schema, path, value2);
    }
  }
  function* TFunction2(schema, references, path, value2) {
    if (!(0, guard_12.IsFunction)(value2))
      yield Create2(ValueErrorType.Function, schema, path, value2);
  }
  function* TInteger2(schema, references, path, value2) {
    if (!(0, guard_12.IsInteger)(value2))
      return yield Create2(ValueErrorType.Integer, schema, path, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.IntegerExclusiveMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.IntegerExclusiveMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.IntegerMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.IntegerMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
      yield Create2(ValueErrorType.IntegerMultipleOf, schema, path, value2);
    }
  }
  function* TIntersect2(schema, references, path, value2) {
    for (const inner of schema.allOf) {
      const next = Visit2(inner, references, path, value2).next();
      if (!next.done) {
        yield Create2(ValueErrorType.Intersect, schema, path, value2);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          yield Create2(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value2);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp(Types2.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value2)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit2(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value2[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* TIterator2(schema, references, path, value2) {
    if (!(0, guard_12.IsIterator)(value2))
      yield Create2(ValueErrorType.Iterator, schema, path, value2);
  }
  function* TLiteral2(schema, references, path, value2) {
    if (!(value2 === schema.const))
      yield Create2(ValueErrorType.Literal, schema, path, value2);
  }
  function* TNever2(schema, references, path, value2) {
    yield Create2(ValueErrorType.Never, schema, path, value2);
  }
  function* TNot2(schema, references, path, value2) {
    if (Visit2(schema.not, references, path, value2).next().done === true)
      yield Create2(ValueErrorType.Not, schema, path, value2);
  }
  function* TNull2(schema, references, path, value2) {
    if (!(0, guard_12.IsNull)(value2))
      yield Create2(ValueErrorType.Null, schema, path, value2);
  }
  function* TNumber2(schema, references, path, value2) {
    if (!system_1.TypeSystemPolicy.IsNumberLike(value2))
      return yield Create2(ValueErrorType.Number, schema, path, value2);
    if (IsDefined2(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
      yield Create2(ValueErrorType.NumberExclusiveMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
      yield Create2(ValueErrorType.NumberExclusiveMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.maximum) && !(value2 <= schema.maximum)) {
      yield Create2(ValueErrorType.NumberMaximum, schema, path, value2);
    }
    if (IsDefined2(schema.minimum) && !(value2 >= schema.minimum)) {
      yield Create2(ValueErrorType.NumberMinimum, schema, path, value2);
    }
    if (IsDefined2(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
      yield Create2(ValueErrorType.NumberMultipleOf, schema, path, value2);
    }
  }
  function* TObject2(schema, references, path, value2) {
    if (!system_1.TypeSystemPolicy.IsObjectLike(value2))
      return yield Create2(ValueErrorType.Object, schema, path, value2);
    if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
      yield Create2(ValueErrorType.ObjectMinProperties, schema, path, value2);
    }
    if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
      yield Create2(ValueErrorType.ObjectMaxProperties, schema, path, value2);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value2);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create2(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, void 0);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create2(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value2[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit2(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value2[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit2(property, references, `${path}/${EscapeKey(knownKey)}`, value2[knownKey]);
        if (Types2.ExtendsUndefined.Check(schema) && !(knownKey in value2)) {
          yield Create2(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, void 0);
        }
      } else {
        if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey)) {
          yield* Visit2(property, references, `${path}/${EscapeKey(knownKey)}`, value2[knownKey]);
        }
      }
    }
  }
  function* TPromise2(schema, references, path, value2) {
    if (!(0, guard_12.IsPromise)(value2))
      yield Create2(ValueErrorType.Promise, schema, path, value2);
  }
  function* TRecord2(schema, references, path, value2) {
    if (!system_1.TypeSystemPolicy.IsRecordLike(value2))
      return yield Create2(ValueErrorType.Object, schema, path, value2);
    if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
      yield Create2(ValueErrorType.ObjectMinProperties, schema, path, value2);
    }
    if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
      yield Create2(ValueErrorType.ObjectMaxProperties, schema, path, value2);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value2)) {
      if (regex.test(propertyKey))
        yield* Visit2(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (!regex.test(propertyKey))
          yield* Visit2(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value2)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create2(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* TRef2(schema, references, path, value2) {
    yield* Visit2((0, deref_12.Deref)(schema, references), references, path, value2);
  }
  function* TString2(schema, references, path, value2) {
    if (!(0, guard_12.IsString)(value2))
      return yield Create2(ValueErrorType.String, schema, path, value2);
    if (IsDefined2(schema.minLength) && !(value2.length >= schema.minLength)) {
      yield Create2(ValueErrorType.StringMinLength, schema, path, value2);
    }
    if (IsDefined2(schema.maxLength) && !(value2.length <= schema.maxLength)) {
      yield Create2(ValueErrorType.StringMaxLength, schema, path, value2);
    }
    if ((0, guard_12.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value2)) {
        yield Create2(ValueErrorType.StringPattern, schema, path, value2);
      }
    }
    if ((0, guard_12.IsString)(schema.format)) {
      if (!Types2.FormatRegistry.Has(schema.format)) {
        yield Create2(ValueErrorType.StringFormatUnknown, schema, path, value2);
      } else {
        const format = Types2.FormatRegistry.Get(schema.format);
        if (!format(value2)) {
          yield Create2(ValueErrorType.StringFormat, schema, path, value2);
        }
      }
    }
  }
  function* TSymbol2(schema, references, path, value2) {
    if (!(0, guard_12.IsSymbol)(value2))
      yield Create2(ValueErrorType.Symbol, schema, path, value2);
  }
  function* TTemplateLiteral2(schema, references, path, value2) {
    if (!(0, guard_12.IsString)(value2))
      return yield Create2(ValueErrorType.String, schema, path, value2);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value2)) {
      yield Create2(ValueErrorType.StringPattern, schema, path, value2);
    }
  }
  function* TThis2(schema, references, path, value2) {
    yield* Visit2((0, deref_12.Deref)(schema, references), references, path, value2);
  }
  function* TTuple2(schema, references, path, value2) {
    if (!(0, guard_12.IsArray)(value2))
      return yield Create2(ValueErrorType.Tuple, schema, path, value2);
    if (schema.items === void 0 && !(value2.length === 0)) {
      return yield Create2(ValueErrorType.TupleLength, schema, path, value2);
    }
    if (!(value2.length === schema.maxItems)) {
      return yield Create2(ValueErrorType.TupleLength, schema, path, value2);
    }
    if (!schema.items) {
      return;
    }
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      yield* Visit2(schema.items[i2], references, `${path}/${i2}`, value2[i2]);
    }
  }
  function* TUndefined2(schema, references, path, value2) {
    if (!(0, guard_12.IsUndefined)(value2))
      yield Create2(ValueErrorType.Undefined, schema, path, value2);
  }
  function* TUnion2(schema, references, path, value2) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors2 = [...Visit2(subschema, references, path, value2)];
      if (errors2.length === 0)
        return;
      count += errors2.length;
    }
    if (count > 0) {
      yield Create2(ValueErrorType.Union, schema, path, value2);
    }
  }
  function* TUint8Array2(schema, references, path, value2) {
    if (!(0, guard_12.IsUint8Array)(value2))
      return yield Create2(ValueErrorType.Uint8Array, schema, path, value2);
    if (IsDefined2(schema.maxByteLength) && !(value2.length <= schema.maxByteLength)) {
      yield Create2(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value2);
    }
    if (IsDefined2(schema.minByteLength) && !(value2.length >= schema.minByteLength)) {
      yield Create2(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value2);
    }
  }
  function* TUnknown2(schema, references, path, value2) {
  }
  function* TVoid2(schema, references, path, value2) {
    if (!system_1.TypeSystemPolicy.IsVoidLike(value2))
      yield Create2(ValueErrorType.Void, schema, path, value2);
  }
  function* TKind2(schema, references, path, value2) {
    const check2 = Types2.TypeRegistry.Get(schema[Types2.Kind]);
    if (!check2(schema, value2))
      yield Create2(ValueErrorType.Kind, schema, path, value2);
  }
  function* Visit2(schema, references, path, value2) {
    const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types2.Kind]) {
      case "Any":
        return yield* TAny2();
      case "Array":
        return yield* TArray2(schema_, references_, path, value2);
      case "AsyncIterator":
        return yield* TAsyncIterator2(schema_, references_, path, value2);
      case "BigInt":
        return yield* TBigInt2(schema_, references_, path, value2);
      case "Boolean":
        return yield* TBoolean2(schema_, references_, path, value2);
      case "Constructor":
        return yield* TConstructor2(schema_, references_, path, value2);
      case "Date":
        return yield* TDate2(schema_, references_, path, value2);
      case "Function":
        return yield* TFunction2(schema_, references_, path, value2);
      case "Integer":
        return yield* TInteger2(schema_, references_, path, value2);
      case "Intersect":
        return yield* TIntersect2(schema_, references_, path, value2);
      case "Iterator":
        return yield* TIterator2(schema_, references_, path, value2);
      case "Literal":
        return yield* TLiteral2(schema_, references_, path, value2);
      case "Never":
        return yield* TNever2(schema_, references_, path, value2);
      case "Not":
        return yield* TNot2(schema_, references_, path, value2);
      case "Null":
        return yield* TNull2(schema_, references_, path, value2);
      case "Number":
        return yield* TNumber2(schema_, references_, path, value2);
      case "Object":
        return yield* TObject2(schema_, references_, path, value2);
      case "Promise":
        return yield* TPromise2(schema_, references_, path, value2);
      case "Record":
        return yield* TRecord2(schema_, references_, path, value2);
      case "Ref":
        return yield* TRef2(schema_, references_, path, value2);
      case "String":
        return yield* TString2(schema_, references_, path, value2);
      case "Symbol":
        return yield* TSymbol2(schema_, references_, path, value2);
      case "TemplateLiteral":
        return yield* TTemplateLiteral2(schema_, references_, path, value2);
      case "This":
        return yield* TThis2(schema_, references_, path, value2);
      case "Tuple":
        return yield* TTuple2(schema_, references_, path, value2);
      case "Undefined":
        return yield* TUndefined2(schema_, references_, path, value2);
      case "Union":
        return yield* TUnion2(schema_, references_, path, value2);
      case "Uint8Array":
        return yield* TUint8Array2(schema_, references_, path, value2);
      case "Unknown":
        return yield* TUnknown2();
      case "Void":
        return yield* TVoid2(schema_, references_, path, value2);
      default:
        if (!Types2.TypeRegistry.Has(schema_[Types2.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind2(schema_, references_, path, value2);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit2(args[0], args[1], "", args[2]) : Visit2(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
  errors.Errors = Errors;
  return errors;
}
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(requireErrors(), exports);
})(errors$1);
var delta = {};
var pointer = {};
Object.defineProperty(pointer, "__esModule", { value: true });
pointer.ValuePointer = pointer.ValuePointerRootDeleteError = pointer.ValuePointerRootSetError = void 0;
class ValuePointerRootSetError extends Error {
  constructor(value2, path, update) {
    super("Cannot set root value");
    this.value = value2;
    this.path = path;
    this.update = update;
  }
}
pointer.ValuePointerRootSetError = ValuePointerRootSetError;
class ValuePointerRootDeleteError extends Error {
  constructor(value2, path) {
    super("Cannot delete root value");
    this.value = value2;
    this.path = path;
  }
}
pointer.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
var ValuePointer;
(function(ValuePointer2) {
  function Escape(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format(pointer2) {
    if (pointer2 === "")
      return;
    let [start, end] = [0, 0];
    for (let i2 = 0; i2 < pointer2.length; i2++) {
      const char = pointer2.charAt(i2);
      if (char === "/") {
        if (i2 === 0) {
          start = i2 + 1;
        } else {
          end = i2;
          yield Escape(pointer2.slice(start, end));
          start = i2 + 1;
        }
      } else {
        end = i2;
      }
    }
    yield Escape(pointer2.slice(start));
  }
  ValuePointer2.Format = Format;
  function Set2(value2, pointer2, update) {
    if (pointer2 === "")
      throw new ValuePointerRootSetError(value2, pointer2, update);
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  }
  ValuePointer2.Set = Set2;
  function Delete(value2, pointer2) {
    if (pointer2 === "")
      throw new ValuePointerRootDeleteError(value2, pointer2);
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0 || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  ValuePointer2.Delete = Delete;
  function Has(value2, pointer2) {
    if (pointer2 === "")
      return true;
    let [owner, next, key] = [null, value2, ""];
    for (const component of Format(pointer2)) {
      if (next[component] === void 0)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  ValuePointer2.Has = Has;
  function Get(value2, pointer2) {
    if (pointer2 === "")
      return value2;
    let current = value2;
    for (const component of Format(pointer2)) {
      if (current[component] === void 0)
        return void 0;
      current = current[component];
    }
    return current;
  }
  ValuePointer2.Get = Get;
})(ValuePointer || (pointer.ValuePointer = ValuePointer = {}));
var clone = {};
Object.defineProperty(clone, "__esModule", { value: true });
clone.Clone = void 0;
const guard_1$8 = guard;
function ObjectType$2(value2) {
  const keys = [...Object.getOwnPropertyNames(value2), ...Object.getOwnPropertySymbols(value2)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value2[key]) }), {});
}
function ArrayType$2(value2) {
  return value2.map((element) => Clone(element));
}
function TypedArrayType$2(value2) {
  return value2.slice();
}
function DateType$1(value2) {
  return new Date(value2.toISOString());
}
function ValueType$2(value2) {
  return value2;
}
function Clone(value2) {
  if ((0, guard_1$8.IsArray)(value2))
    return ArrayType$2(value2);
  if ((0, guard_1$8.IsDate)(value2))
    return DateType$1(value2);
  if ((0, guard_1$8.IsPlainObject)(value2))
    return ObjectType$2(value2);
  if ((0, guard_1$8.IsTypedArray)(value2))
    return TypedArrayType$2(value2);
  if ((0, guard_1$8.IsValueType)(value2))
    return ValueType$2(value2);
  throw new Error("ValueClone: Unable to clone value");
}
clone.Clone = Clone;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = void 0;
  const guard_12 = guard;
  const typebox_12 = typebox;
  const pointer_12 = pointer;
  const clone_12 = clone;
  exports.Insert = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("insert"),
    path: typebox_12.Type.String(),
    value: typebox_12.Type.Unknown()
  });
  exports.Update = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("update"),
    path: typebox_12.Type.String(),
    value: typebox_12.Type.Unknown()
  });
  exports.Delete = typebox_12.Type.Object({
    type: typebox_12.Type.Literal("delete"),
    path: typebox_12.Type.String()
  });
  exports.Edit = typebox_12.Type.Union([exports.Insert, exports.Update, exports.Delete]);
  class ValueDeltaObjectWithSymbolKeyError extends Error {
    constructor(key) {
      super("Cannot diff objects with symbol keys");
      this.key = key;
    }
  }
  exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;
  class ValueDeltaUnableToDiffUnknownValue extends Error {
    constructor(value2) {
      super("Unable to create diff edits for unknown value");
      this.value = value2;
    }
  }
  exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
  function CreateUpdate(path, value2) {
    return { type: "update", path, value: value2 };
  }
  function CreateInsert(path, value2) {
    return { type: "insert", path, value: value2 };
  }
  function CreateDelete(path) {
    return { type: "delete", path };
  }
  function* ObjectType2(path, current, next) {
    if (!(0, guard_12.IsPlainObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${String(key)}`, void 0);
    }
    for (const key of nextKeys) {
      if ((0, guard_12.IsUndefined)(current[key]) || (0, guard_12.IsUndefined)(next[key]))
        continue;
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      yield* Visit2(`${path}/${String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, guard_12.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_12.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${String(key)}`);
    }
  }
  function* ArrayType2(path, current, next) {
    if (!(0, guard_12.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit2(`${path}/${i2}`, current[i2], next[i2]);
    }
    for (let i2 = 0; i2 < next.length; i2++) {
      if (i2 < current.length)
        continue;
      yield CreateInsert(`${path}/${i2}`, next[i2]);
    }
    for (let i2 = current.length - 1; i2 >= 0; i2--) {
      if (i2 < next.length)
        continue;
      yield CreateDelete(`${path}/${i2}`);
    }
  }
  function* TypedArrayType2(path, current, next) {
    if (!(0, guard_12.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i2 = 0; i2 < Math.min(current.length, next.length); i2++) {
      yield* Visit2(`${path}/${i2}`, current[i2], next[i2]);
    }
  }
  function* ValueType2(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit2(path, current, next) {
    if ((0, guard_12.IsPlainObject)(current))
      return yield* ObjectType2(path, current, next);
    if ((0, guard_12.IsArray)(current))
      return yield* ArrayType2(path, current, next);
    if ((0, guard_12.IsTypedArray)(current))
      return yield* TypedArrayType2(path, current, next);
    if ((0, guard_12.IsValueType)(current))
      return yield* ValueType2(path, current, next);
    throw new ValueDeltaUnableToDiffUnknownValue(current);
  }
  function Diff(current, next) {
    return [...Visit2("", current, next)];
  }
  exports.Diff = Diff;
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, clone_12.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, clone_12.Clone)(current);
    }
    const clone2 = (0, clone_12.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          pointer_12.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "update": {
          pointer_12.ValuePointer.Set(clone2, edit.path, edit.value);
          break;
        }
        case "delete": {
          pointer_12.ValuePointer.Delete(clone2, edit.path);
          break;
        }
      }
    }
    return clone2;
  }
  exports.Patch = Patch;
})(delta);
var value = {};
var mutate = {};
Object.defineProperty(mutate, "__esModule", { value: true });
mutate.Mutate = mutate.ValueMutateInvalidRootMutationError = mutate.ValueMutateTypeMismatchError = void 0;
const guard_1$7 = guard;
const pointer_1 = pointer;
const clone_1$2 = clone;
class ValueMutateTypeMismatchError extends Error {
  constructor() {
    super("Cannot assign due type mismatch of assignable values");
  }
}
mutate.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;
class ValueMutateInvalidRootMutationError extends Error {
  constructor() {
    super("Only object and array types can be mutated at the root level");
  }
}
mutate.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
function ObjectType$1(root, path, current, next) {
  if (!(0, guard_1$7.IsPlainObject)(current)) {
    pointer_1.ValuePointer.Set(root, path, (0, clone_1$2.Clone)(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit$4(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType$1(root, path, current, next) {
  if (!(0, guard_1$7.IsArray)(current)) {
    pointer_1.ValuePointer.Set(root, path, (0, clone_1$2.Clone)(next));
  } else {
    for (let index = 0; index < next.length; index++) {
      Visit$4(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType$1(root, path, current, next) {
  if ((0, guard_1$7.IsTypedArray)(current) && current.length === next.length) {
    for (let i2 = 0; i2 < current.length; i2++) {
      current[i2] = next[i2];
    }
  } else {
    pointer_1.ValuePointer.Set(root, path, (0, clone_1$2.Clone)(next));
  }
}
function ValueType$1(root, path, current, next) {
  if (current === next)
    return;
  pointer_1.ValuePointer.Set(root, path, next);
}
function Visit$4(root, path, current, next) {
  if ((0, guard_1$7.IsArray)(next))
    return ArrayType$1(root, path, current, next);
  if ((0, guard_1$7.IsTypedArray)(next))
    return TypedArrayType$1(root, path, current, next);
  if ((0, guard_1$7.IsPlainObject)(next))
    return ObjectType$1(root, path, current, next);
  if ((0, guard_1$7.IsValueType)(next))
    return ValueType$1(root, path, current, next);
}
function IsNonMutableValue(value2) {
  return (0, guard_1$7.IsTypedArray)(value2) || (0, guard_1$7.IsValueType)(value2);
}
function IsMismatchedValue(current, next) {
  return (0, guard_1$7.IsPlainObject)(current) && (0, guard_1$7.IsArray)(next) || (0, guard_1$7.IsArray)(current) && (0, guard_1$7.IsPlainObject)(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateInvalidRootMutationError();
  if (IsMismatchedValue(current, next))
    throw new ValueMutateTypeMismatchError();
  Visit$4(current, "", current, next);
}
mutate.Mutate = Mutate;
var equal = {};
Object.defineProperty(equal, "__esModule", { value: true });
equal.Equal = void 0;
const guard_1$6 = guard;
function ObjectType(left, right) {
  if (!(0, guard_1$6.IsPlainObject)(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType(left, right) {
  return (0, guard_1$6.IsDate)(right) && left.getTime() === right.getTime();
}
function ArrayType(left, right) {
  if (!(0, guard_1$6.IsArray)(right) || left.length !== right.length)
    return false;
  return left.every((value2, index) => Equal(value2, right[index]));
}
function TypedArrayType(left, right) {
  if (!(0, guard_1$6.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value2, index) => Equal(value2, right[index]));
}
function ValueType(left, right) {
  return left === right;
}
function Equal(left, right) {
  if ((0, guard_1$6.IsPlainObject)(left))
    return ObjectType(left, right);
  if ((0, guard_1$6.IsDate)(left))
    return DateType(left, right);
  if ((0, guard_1$6.IsTypedArray)(left))
    return TypedArrayType(left, right);
  if ((0, guard_1$6.IsArray)(left))
    return ArrayType(left, right);
  if ((0, guard_1$6.IsValueType)(left))
    return ValueType(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
equal.Equal = Equal;
var cast = {};
var create = {};
var check = {};
var system = {};
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorType = void 0;
  var errors_12 = requireErrors();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return errors_12.ValueErrorType;
  } });
  __exportStar(requireSystem(), exports);
})(system);
Object.defineProperty(check, "__esModule", { value: true });
check.Check = check.ValueCheckUnknownTypeError = void 0;
const guard_1$5 = guard;
const index_1$1 = system;
const deref_1$5 = deref;
const hash_1$1 = hash$1;
const Types$5 = typebox;
class ValueCheckUnknownTypeError extends Types$5.TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
check.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
function IsAnyOrUnknown(schema) {
  return schema[Types$5.Kind] === "Any" || schema[Types$5.Kind] === "Unknown";
}
function IsDefined(value2) {
  return value2 !== void 0;
}
function TAny$1(schema, references, value2) {
  return true;
}
function TArray$3(schema, references, value2) {
  if (!(0, guard_1$5.IsArray)(value2))
    return false;
  if (IsDefined(schema.minItems) && !(value2.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value2.length <= schema.maxItems)) {
    return false;
  }
  if (!value2.every((value3) => Visit$3(schema.items, references, value3))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set = /* @__PURE__ */ new Set();
    for (const element of value2) {
      const hashed = (0, hash_1$1.Hash)(element);
      if (set.has(hashed)) {
        return false;
      } else {
        set.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || (0, guard_1$5.IsNumber)(schema.minContains) || (0, guard_1$5.IsNumber)(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Types$5.Type.Never();
  const containsCount = value2.reduce((acc, value3) => Visit$3(containsSchema, references, value3) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if ((0, guard_1$5.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if ((0, guard_1$5.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function TAsyncIterator$1(schema, references, value2) {
  return (0, guard_1$5.IsAsyncIterator)(value2);
}
function TBigInt$2(schema, references, value2) {
  if (!(0, guard_1$5.IsBigInt)(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function TBoolean$2(schema, references, value2) {
  return (0, guard_1$5.IsBoolean)(value2);
}
function TConstructor$2(schema, references, value2) {
  return Visit$3(schema.returns, references, value2.prototype);
}
function TDate$2(schema, references, value2) {
  if (!(0, guard_1$5.IsDate)(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value2.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value2.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value2.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value2.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value2.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function TFunction$1(schema, references, value2) {
  return (0, guard_1$5.IsFunction)(value2);
}
function TInteger$2(schema, references, value2) {
  if (!(0, guard_1$5.IsInteger)(value2)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function TIntersect$3(schema, references, value2) {
  const check1 = schema.allOf.every((schema2) => Visit$3(schema2, references, value2));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(Types$5.KeyResolver.ResolvePattern(schema));
    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (Types$5.TypeGuard.TSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(Types$5.KeyResolver.ResolvePattern(schema));
    const check2 = Object.getOwnPropertyNames(value2).every((key) => keyCheck.test(key) || Visit$3(schema.unevaluatedProperties, references, value2[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function TIterator$1(schema, references, value2) {
  return (0, guard_1$5.IsIterator)(value2);
}
function TLiteral$2(schema, references, value2) {
  return value2 === schema.const;
}
function TNever$2(schema, references, value2) {
  return false;
}
function TNot$1(schema, references, value2) {
  return !Visit$3(schema.not, references, value2);
}
function TNull$2(schema, references, value2) {
  return (0, guard_1$5.IsNull)(value2);
}
function TNumber$2(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsNumberLike(value2))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value2 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value2 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value2 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value2 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value2 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function TObject$3(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsObjectLike(value2))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit$3(property, references, value2[knownKey])) {
        return false;
      }
      if ((Types$5.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value2)) {
        return false;
      }
    } else {
      if (index_1$1.TypeSystemPolicy.IsExactOptionalProperty(value2, knownKey) && !Visit$3(property, references, value2[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value2);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value2);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit$3(schema.additionalProperties, references, value2[key]));
  } else {
    return true;
  }
}
function TPromise$1(schema, references, value2) {
  return (0, guard_1$5.IsPromise)(value2);
}
function TRecord$3(schema, references, value2) {
  if (!index_1$1.TypeSystemPolicy.IsRecordLike(value2)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value2).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value2).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value2).every(([key, value3]) => {
    return regex.test(key) ? Visit$3(patternSchema, references, value3) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value2).every(([key, value3]) => {
    return !regex.test(key) ? Visit$3(schema.additionalProperties, references, value3) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value2).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function TRef$3(schema, references, value2) {
  return Visit$3((0, deref_1$5.Deref)(schema, references), references, value2);
}
function TString$2(schema, references, value2) {
  if (!(0, guard_1$5.IsString)(value2)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value2.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value2.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value2))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!Types$5.FormatRegistry.Has(schema.format))
      return false;
    const func = Types$5.FormatRegistry.Get(schema.format);
    return func(value2);
  }
  return true;
}
function TSymbol$2(schema, references, value2) {
  return (0, guard_1$5.IsSymbol)(value2);
}
function TTemplateLiteral$1(schema, references, value2) {
  return (0, guard_1$5.IsString)(value2) && new RegExp(schema.pattern).test(value2);
}
function TThis$3(schema, references, value2) {
  return Visit$3((0, deref_1$5.Deref)(schema, references), references, value2);
}
function TTuple$3(schema, references, value2) {
  if (!(0, guard_1$5.IsArray)(value2)) {
    return false;
  }
  if (schema.items === void 0 && !(value2.length === 0)) {
    return false;
  }
  if (!(value2.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i2 = 0; i2 < schema.items.length; i2++) {
    if (!Visit$3(schema.items[i2], references, value2[i2]))
      return false;
  }
  return true;
}
function TUndefined$2(schema, references, value2) {
  return (0, guard_1$5.IsUndefined)(value2);
}
function TUnion$3(schema, references, value2) {
  return schema.anyOf.some((inner) => Visit$3(inner, references, value2));
}
function TUint8Array$1(schema, references, value2) {
  if (!(0, guard_1$5.IsUint8Array)(value2)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value2.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value2.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function TUnknown$1(schema, references, value2) {
  return true;
}
function TVoid$1(schema, references, value2) {
  return index_1$1.TypeSystemPolicy.IsVoidLike(value2);
}
function TKind$1(schema, references, value2) {
  if (!Types$5.TypeRegistry.Has(schema[Types$5.Kind]))
    return false;
  const func = Types$5.TypeRegistry.Get(schema[Types$5.Kind]);
  return func(schema, value2);
}
function Visit$3(schema, references, value2) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Types$5.Kind]) {
    case "Any":
      return TAny$1();
    case "Array":
      return TArray$3(schema_, references_, value2);
    case "AsyncIterator":
      return TAsyncIterator$1(schema_, references_, value2);
    case "BigInt":
      return TBigInt$2(schema_, references_, value2);
    case "Boolean":
      return TBoolean$2(schema_, references_, value2);
    case "Constructor":
      return TConstructor$2(schema_, references_, value2);
    case "Date":
      return TDate$2(schema_, references_, value2);
    case "Function":
      return TFunction$1(schema_, references_, value2);
    case "Integer":
      return TInteger$2(schema_, references_, value2);
    case "Intersect":
      return TIntersect$3(schema_, references_, value2);
    case "Iterator":
      return TIterator$1(schema_, references_, value2);
    case "Literal":
      return TLiteral$2(schema_, references_, value2);
    case "Never":
      return TNever$2();
    case "Not":
      return TNot$1(schema_, references_, value2);
    case "Null":
      return TNull$2(schema_, references_, value2);
    case "Number":
      return TNumber$2(schema_, references_, value2);
    case "Object":
      return TObject$3(schema_, references_, value2);
    case "Promise":
      return TPromise$1(schema_, references_, value2);
    case "Record":
      return TRecord$3(schema_, references_, value2);
    case "Ref":
      return TRef$3(schema_, references_, value2);
    case "String":
      return TString$2(schema_, references_, value2);
    case "Symbol":
      return TSymbol$2(schema_, references_, value2);
    case "TemplateLiteral":
      return TTemplateLiteral$1(schema_, references_, value2);
    case "This":
      return TThis$3(schema_, references_, value2);
    case "Tuple":
      return TTuple$3(schema_, references_, value2);
    case "Undefined":
      return TUndefined$2(schema_, references_, value2);
    case "Union":
      return TUnion$3(schema_, references_, value2);
    case "Uint8Array":
      return TUint8Array$1(schema_, references_, value2);
    case "Unknown":
      return TUnknown$1();
    case "Void":
      return TVoid$1(schema_, references_, value2);
    default:
      if (!Types$5.TypeRegistry.Has(schema_[Types$5.Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return TKind$1(schema_, references_, value2);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit$3(args[0], args[1], args[2]) : Visit$3(args[0], [], args[1]);
}
check.Check = Check;
Object.defineProperty(create, "__esModule", { value: true });
create.Create = create.ValueCreateRecursiveInstantiationError = create.ValueCreateTempateLiteralTypeError = create.ValueCreateIntersectTypeError = create.ValueCreateNotTypeError = create.ValueCreateNeverTypeError = create.ValueCreateUnknownTypeError = void 0;
const guard_1$4 = guard;
const check_1$3 = check;
const deref_1$4 = deref;
const Types$4 = typebox;
class ValueCreateUnknownTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
create.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;
class ValueCreateNeverTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Never types cannot be created");
    this.schema = schema;
  }
}
create.ValueCreateNeverTypeError = ValueCreateNeverTypeError;
class ValueCreateNotTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Not types must have a default value");
    this.schema = schema;
  }
}
create.ValueCreateNotTypeError = ValueCreateNotTypeError;
class ValueCreateIntersectTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Intersect produced invalid value. Consider using a default value.");
    this.schema = schema;
  }
}
create.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;
class ValueCreateTempateLiteralTypeError extends Types$4.TypeBoxError {
  constructor(schema) {
    super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
    this.schema = schema;
  }
}
create.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;
class ValueCreateRecursiveInstantiationError extends Types$4.TypeBoxError {
  constructor(schema, recursiveMaxDepth2) {
    super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
    this.schema = schema;
    this.recursiveMaxDepth = recursiveMaxDepth2;
  }
}
create.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
function TAny(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return {};
  }
}
function TArray$2(schema, references) {
  if (schema.uniqueItems === true && !(0, guard_1$4.HasPropertyKey)(schema, "default")) {
    throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !(0, guard_1$4.HasPropertyKey)(schema, "default")) {
    throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return schema.default;
  } else if (schema.minItems !== void 0) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit$2(schema.items, references);
    });
  } else {
    return [];
  }
}
function TAsyncIterator(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return /* @__PURE__ */ async function* () {
    }();
  }
}
function TBigInt$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return BigInt(0);
  }
}
function TBoolean$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return false;
  }
}
function TConstructor$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const value2 = Visit$2(schema.returns, references);
    if (typeof value2 === "object" && !Array.isArray(value2)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value2)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function TDate$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimumTimestamp !== void 0) {
    return new Date(schema.minimumTimestamp);
  } else {
    return /* @__PURE__ */ new Date();
  }
}
function TFunction(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return () => Visit$2(schema.returns, references);
  }
}
function TInteger$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function TIntersect$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const value2 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit$2(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!(0, check_1$3.Check)(schema, references, value2))
      throw new ValueCreateIntersectTypeError(schema);
    return value2;
  }
}
function TIterator(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return /* @__PURE__ */ function* () {
    }();
  }
}
function TLiteral$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return schema.const;
  }
}
function TNever$1(schema, references) {
  throw new ValueCreateNeverTypeError(schema);
}
function TNot(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    throw new ValueCreateNotTypeError(schema);
  }
}
function TNull$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return null;
  }
}
function TNumber$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minimum !== void 0) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function TObject$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    const required = new Set(schema.required);
    return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit$2(schema2, references) } : { ...acc };
    }, {});
  }
}
function TPromise(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Promise.resolve(Visit$2(schema.item, references));
  }
}
function TRecord$2(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (!(keyPattern === Types$4.PatternStringExact || keyPattern === Types$4.PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit$2(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
}
function TRef$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Visit$2((0, deref_1$4.Deref)(schema, references), references);
  }
}
function TString$1(schema, references) {
  if (schema.pattern !== void 0) {
    if (!(0, guard_1$4.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.String: String types with patterns must specify a default value");
    } else {
      return schema.default;
    }
  } else if (schema.format !== void 0) {
    if (!(0, guard_1$4.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.String: String types with formats must specify a default value");
    } else {
      return schema.default;
    }
  } else {
    if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minLength !== void 0) {
      return Array.from({ length: schema.minLength }).map(() => ".").join("");
    } else {
      return "";
    }
  }
}
function TSymbol$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function TTemplateLiteral(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  }
  const expression = Types$4.TemplateLiteralParser.ParseExact(schema.pattern);
  if (!Types$4.TemplateLiteralFinite.Check(expression))
    throw new ValueCreateTempateLiteralTypeError(schema);
  const sequence = Types$4.TemplateLiteralGenerator.Generate(expression);
  return sequence.next().value;
}
function TThis$2(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return Visit$2((0, deref_1$4.Deref)(schema, references), references);
  }
}
function TTuple$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  }
  if (schema.items === void 0) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit$2(schema.items[index], references));
  }
}
function TUndefined$1(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return void 0;
  }
}
function TUnion$2(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit$2(schema.anyOf[0], references);
  }
}
function TUint8Array(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else if (schema.minByteLength !== void 0) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function TUnknown(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return {};
  }
}
function TVoid(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    return void 0;
  }
}
function TKind(schema, references) {
  if ((0, guard_1$4.HasPropertyKey)(schema, "default")) {
    return schema.default;
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit$2(schema, references) {
  const references_ = (0, guard_1$4.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Types$4.Kind]) {
    case "Any":
      return TAny(schema_);
    case "Array":
      return TArray$2(schema_, references_);
    case "AsyncIterator":
      return TAsyncIterator(schema_);
    case "BigInt":
      return TBigInt$1(schema_);
    case "Boolean":
      return TBoolean$1(schema_);
    case "Constructor":
      return TConstructor$1(schema_, references_);
    case "Date":
      return TDate$1(schema_);
    case "Function":
      return TFunction(schema_, references_);
    case "Integer":
      return TInteger$1(schema_);
    case "Intersect":
      return TIntersect$2(schema_, references_);
    case "Iterator":
      return TIterator(schema_);
    case "Literal":
      return TLiteral$1(schema_);
    case "Never":
      return TNever$1(schema_);
    case "Not":
      return TNot(schema_);
    case "Null":
      return TNull$1(schema_);
    case "Number":
      return TNumber$1(schema_);
    case "Object":
      return TObject$2(schema_, references_);
    case "Promise":
      return TPromise(schema_, references_);
    case "Record":
      return TRecord$2(schema_, references_);
    case "Ref":
      return TRef$2(schema_, references_);
    case "String":
      return TString$1(schema_);
    case "Symbol":
      return TSymbol$1(schema_);
    case "TemplateLiteral":
      return TTemplateLiteral(schema_);
    case "This":
      return TThis$2(schema_, references_);
    case "Tuple":
      return TTuple$2(schema_, references_);
    case "Undefined":
      return TUndefined$1(schema_);
    case "Union":
      return TUnion$2(schema_, references_);
    case "Uint8Array":
      return TUint8Array(schema_);
    case "Unknown":
      return TUnknown(schema_);
    case "Void":
      return TVoid(schema_);
    default:
      if (!Types$4.TypeRegistry.Has(schema_[Types$4.Kind]))
        throw new ValueCreateUnknownTypeError(schema_);
      return TKind(schema_);
  }
}
const recursiveMaxDepth = 512;
let recursiveDepth = 0;
function Create(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit$2(args[0], args[1]) : Visit$2(args[0], []);
}
create.Create = Create;
Object.defineProperty(cast, "__esModule", { value: true });
cast.Cast = cast.Default = cast.DefaultClone = cast.ValueCastUnknownTypeError = cast.ValueCastRecursiveTypeError = cast.ValueCastNeverTypeError = cast.ValueCastArrayUniqueItemsTypeError = void 0;
const guard_1$3 = guard;
const create_1 = create;
const check_1$2 = check;
const clone_1$1 = clone;
const deref_1$3 = deref;
const Types$3 = typebox;
class ValueCastArrayUniqueItemsTypeError extends Types$3.TypeBoxError {
  constructor(schema, value2) {
    super("Array cast produced invalid data due to uniqueItems constraint");
    this.schema = schema;
    this.value = value2;
  }
}
cast.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;
class ValueCastNeverTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Never types cannot be cast");
    this.schema = schema;
  }
}
cast.ValueCastNeverTypeError = ValueCastNeverTypeError;
class ValueCastRecursiveTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Cannot cast recursive schemas");
    this.schema = schema;
  }
}
cast.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;
class ValueCastUnknownTypeError extends Types$3.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
cast.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
var UnionCastCreate;
(function(UnionCastCreate2) {
  function Score(schema, references, value2) {
    if (schema[Types$3.Kind] === "Object" && typeof value2 === "object" && !(0, guard_1$3.IsNull)(value2)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value2);
      const entries = Object.entries(object.properties);
      const [point, max] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[Types$3.Kind] === "Literal" && schema2.const === value2[key] ? max : 0;
        const checks = (0, check_1$2.Check)(schema2, references, value2[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal + checks + exists);
      }, 0);
    } else {
      return (0, check_1$2.Check)(schema, references, value2) ? 1 : 0;
    }
  }
  function Select(union, references, value2) {
    let [select, best] = [union.anyOf[0], 0];
    for (const schema of union.anyOf) {
      const score = Score(schema, references, value2);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function Create2(union, references, value2) {
    if ("default" in union) {
      return union.default;
    } else {
      const schema = Select(union, references, value2);
      return Cast(schema, references, value2);
    }
  }
  UnionCastCreate2.Create = Create2;
})(UnionCastCreate || (UnionCastCreate = {}));
function DefaultClone(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? (0, clone_1$1.Clone)(value2) : (0, create_1.Create)(schema, references);
}
cast.DefaultClone = DefaultClone;
function Default$1(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? value2 : (0, create_1.Create)(schema, references);
}
cast.Default = Default$1;
function TArray$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  const created = (0, guard_1$3.IsArray)(value2) ? (0, clone_1$1.Clone)(value2) : (0, create_1.Create)(schema, references);
  const minimum = (0, guard_1$3.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = (0, guard_1$3.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value3) => Visit$1(schema.items, references, value3));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!(0, check_1$2.Check)(schema, references, unique))
    throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
  return unique;
}
function TConstructor(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, create_1.Create)(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value2.prototype[key] === void 0)
      continue;
    result.prototype[key] = Visit$1(property, references, value2.prototype[key]);
  }
  return result;
}
function TIntersect$1(schema, references, value2) {
  const created = (0, create_1.Create)(schema, references);
  const mapped = (0, guard_1$3.IsPlainObject)(created) && (0, guard_1$3.IsPlainObject)(value2) ? { ...created, ...value2 } : value2;
  return (0, check_1$2.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);
}
function TNever(schema, references, value2) {
  throw new ValueCastNeverTypeError(schema);
}
function TObject$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return value2;
  if (value2 === null || typeof value2 !== "object")
    return (0, create_1.Create)(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value2[key] === void 0)
      continue;
    result[key] = Visit$1(property, references, value2[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value2)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit$1(schema.additionalProperties, references, value2[propertyName]);
    }
  }
  return result;
}
function TRecord$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  if (value2 === null || typeof value2 !== "object" || Array.isArray(value2) || value2 instanceof Date)
    return (0, create_1.Create)(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value2)) {
    result[propKey] = Visit$1(subschema, references, propValue);
  }
  return result;
}
function TRef$1(schema, references, value2) {
  return Visit$1((0, deref_1$3.Deref)(schema, references), references, value2);
}
function TThis$1(schema, references, value2) {
  return Visit$1((0, deref_1$3.Deref)(schema, references), references, value2);
}
function TTuple$1(schema, references, value2) {
  if ((0, check_1$2.Check)(schema, references, value2))
    return (0, clone_1$1.Clone)(value2);
  if (!(0, guard_1$3.IsArray)(value2))
    return (0, create_1.Create)(schema, references);
  if (schema.items === void 0)
    return [];
  return schema.items.map((schema2, index) => Visit$1(schema2, references, value2[index]));
}
function TUnion$1(schema, references, value2) {
  return (0, check_1$2.Check)(schema, references, value2) ? (0, clone_1$1.Clone)(value2) : UnionCastCreate.Create(schema, references, value2);
}
function Visit$1(schema, references, value2) {
  const references_ = (0, guard_1$3.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Types$3.Kind]) {
    case "Array":
      return TArray$1(schema_, references_, value2);
    case "Constructor":
      return TConstructor(schema_, references_, value2);
    case "Intersect":
      return TIntersect$1(schema_, references_, value2);
    case "Never":
      return TNever(schema_);
    case "Object":
      return TObject$1(schema_, references_, value2);
    case "Record":
      return TRecord$1(schema_, references_, value2);
    case "Ref":
      return TRef$1(schema_, references_, value2);
    case "This":
      return TThis$1(schema_, references_, value2);
    case "Tuple":
      return TTuple$1(schema_, references_, value2);
    case "Union":
      return TUnion$1(schema_, references_, value2);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value2);
    case "Any":
    case "AsyncIterator":
    case "BigInt":
    case "Boolean":
    case "Function":
    case "Integer":
    case "Iterator":
    case "Literal":
    case "Not":
    case "Null":
    case "Number":
    case "Promise":
    case "String":
    case "TemplateLiteral":
    case "Undefined":
    case "Unknown":
    case "Void":
      return Default$1(schema_, references_, value2);
    default:
      if (!Types$3.TypeRegistry.Has(schema_[Types$3.Kind]))
        throw new ValueCastUnknownTypeError(schema_);
      return Default$1(schema_, references_, value2);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit$1(args[0], args[1], args[2]) : Visit$1(args[0], [], args[1]);
}
cast.Cast = Cast;
var convert = {};
Object.defineProperty(convert, "__esModule", { value: true });
convert.Convert = convert.Default = convert.ValueConvertUnknownTypeError = void 0;
const guard_1$2 = guard;
const clone_1 = clone;
const check_1$1 = check;
const deref_1$2 = deref;
const Types$2 = typebox;
class ValueConvertUnknownTypeError extends Types$2.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
convert.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
function IsStringNumeric(value2) {
  return (0, guard_1$2.IsString)(value2) && !isNaN(value2) && !isNaN(parseFloat(value2));
}
function IsValueToString(value2) {
  return (0, guard_1$2.IsBigInt)(value2) || (0, guard_1$2.IsBoolean)(value2) || (0, guard_1$2.IsNumber)(value2);
}
function IsValueTrue(value2) {
  return value2 === true || (0, guard_1$2.IsNumber)(value2) && value2 === 1 || (0, guard_1$2.IsBigInt)(value2) && value2 === BigInt("1") || (0, guard_1$2.IsString)(value2) && (value2.toLowerCase() === "true" || value2 === "1");
}
function IsValueFalse(value2) {
  return value2 === false || (0, guard_1$2.IsNumber)(value2) && (value2 === 0 || Object.is(value2, -0)) || (0, guard_1$2.IsBigInt)(value2) && value2 === BigInt("0") || (0, guard_1$2.IsString)(value2) && (value2.toLowerCase() === "false" || value2 === "0" || value2 === "-0");
}
function IsTimeStringWithTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value2);
}
function IsTimeStringWithoutTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value2);
}
function IsDateTimeStringWithTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value2);
}
function IsDateTimeStringWithoutTimeZone(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value2);
}
function IsDateString(value2) {
  return (0, guard_1$2.IsString)(value2) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value2);
}
function TryConvertLiteralString(value2, target) {
  const conversion = TryConvertString(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteralNumber(value2, target) {
  const conversion = TryConvertNumber(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteralBoolean(value2, target) {
  const conversion = TryConvertBoolean(value2);
  return conversion === target ? conversion : value2;
}
function TryConvertLiteral(schema, value2) {
  if (typeof schema.const === "string") {
    return TryConvertLiteralString(value2, schema.const);
  } else if (typeof schema.const === "number") {
    return TryConvertLiteralNumber(value2, schema.const);
  } else if (typeof schema.const === "boolean") {
    return TryConvertLiteralBoolean(value2, schema.const);
  } else {
    return (0, clone_1.Clone)(value2);
  }
}
function TryConvertBoolean(value2) {
  return IsValueTrue(value2) ? true : IsValueFalse(value2) ? false : value2;
}
function TryConvertBigInt(value2) {
  return IsStringNumeric(value2) ? BigInt(parseInt(value2)) : (0, guard_1$2.IsNumber)(value2) ? BigInt(value2 | 0) : IsValueFalse(value2) ? BigInt(0) : IsValueTrue(value2) ? BigInt(1) : value2;
}
function TryConvertString(value2) {
  return IsValueToString(value2) ? value2.toString() : (0, guard_1$2.IsSymbol)(value2) && value2.description !== void 0 ? value2.description.toString() : value2;
}
function TryConvertNumber(value2) {
  return IsStringNumeric(value2) ? parseFloat(value2) : IsValueTrue(value2) ? 1 : IsValueFalse(value2) ? 0 : value2;
}
function TryConvertInteger(value2) {
  return IsStringNumeric(value2) ? parseInt(value2) : (0, guard_1$2.IsNumber)(value2) ? value2 | 0 : IsValueTrue(value2) ? 1 : IsValueFalse(value2) ? 0 : value2;
}
function TryConvertNull(value2) {
  return (0, guard_1$2.IsString)(value2) && value2.toLowerCase() === "null" ? null : value2;
}
function TryConvertUndefined(value2) {
  return (0, guard_1$2.IsString)(value2) && value2 === "undefined" ? void 0 : value2;
}
function TryConvertDate(value2) {
  return (0, guard_1$2.IsDate)(value2) ? value2 : (0, guard_1$2.IsNumber)(value2) ? new Date(value2) : IsValueTrue(value2) ? /* @__PURE__ */ new Date(1) : IsValueFalse(value2) ? /* @__PURE__ */ new Date(0) : IsStringNumeric(value2) ? new Date(parseInt(value2)) : IsTimeStringWithoutTimeZone(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}.000Z`) : IsTimeStringWithTimeZone(value2) ? /* @__PURE__ */ new Date(`1970-01-01T${value2}`) : IsDateTimeStringWithoutTimeZone(value2) ? /* @__PURE__ */ new Date(`${value2}.000Z`) : IsDateTimeStringWithTimeZone(value2) ? new Date(value2) : IsDateString(value2) ? /* @__PURE__ */ new Date(`${value2}T00:00:00.000Z`) : value2;
}
function Default(value2) {
  return value2;
}
convert.Default = Default;
function TArray(schema, references, value2) {
  if ((0, guard_1$2.IsArray)(value2)) {
    return value2.map((value3) => Visit(schema.items, references, value3));
  }
  return value2;
}
function TBigInt(schema, references, value2) {
  return TryConvertBigInt(value2);
}
function TBoolean(schema, references, value2) {
  return TryConvertBoolean(value2);
}
function TDate(schema, references, value2) {
  return TryConvertDate(value2);
}
function TInteger(schema, references, value2) {
  return TryConvertInteger(value2);
}
function TIntersect(schema, references, value2) {
  return schema.allOf.every((schema2) => Types$2.TypeGuard.TObject(schema2)) ? Visit(Types$2.Type.Composite(schema.allOf), references, value2) : Visit(schema.allOf[0], references, value2);
}
function TLiteral(schema, references, value2) {
  return TryConvertLiteral(schema, value2);
}
function TNull(schema, references, value2) {
  return TryConvertNull(value2);
}
function TNumber(schema, references, value2) {
  return TryConvertNumber(value2);
}
function TObject(schema, references, value2) {
  if ((0, guard_1$2.IsObject)(value2))
    return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {
      return value2[key] !== void 0 ? { ...acc, [key]: Visit(schema.properties[key], references, value2[key]) } : { ...acc };
    }, value2);
  return value2;
}
function TRecord(schema, references, value2) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value2)) {
    result[propKey] = Visit(property, references, propValue);
  }
  return result;
}
function TRef(schema, references, value2) {
  return Visit((0, deref_1$2.Deref)(schema, references), references, value2);
}
function TString(schema, references, value2) {
  return TryConvertString(value2);
}
function TSymbol(schema, references, value2) {
  return (0, guard_1$2.IsString)(value2) || (0, guard_1$2.IsNumber)(value2) ? Symbol(value2) : value2;
}
function TThis(schema, references, value2) {
  return Visit((0, deref_1$2.Deref)(schema, references), references, value2);
}
function TTuple(schema, references, value2) {
  if ((0, guard_1$2.IsArray)(value2) && !(0, guard_1$2.IsUndefined)(schema.items)) {
    return value2.map((value3, index) => {
      return index < schema.items.length ? Visit(schema.items[index], references, value3) : value3;
    });
  }
  return value2;
}
function TUndefined(schema, references, value2) {
  return TryConvertUndefined(value2);
}
function TUnion(schema, references, value2) {
  for (const subschema of schema.anyOf) {
    const converted = Visit(subschema, references, value2);
    if ((0, check_1$1.Check)(subschema, references, converted)) {
      return converted;
    }
  }
  return value2;
}
function Visit(schema, references, value2) {
  const references_ = (0, guard_1$2.IsString)(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Types$2.Kind]) {
    case "Array":
      return TArray(schema_, references_, value2);
    case "BigInt":
      return TBigInt(schema_, references_, value2);
    case "Boolean":
      return TBoolean(schema_, references_, value2);
    case "Date":
      return TDate(schema_, references_, value2);
    case "Integer":
      return TInteger(schema_, references_, value2);
    case "Intersect":
      return TIntersect(schema_, references_, value2);
    case "Literal":
      return TLiteral(schema_, references_, value2);
    case "Null":
      return TNull(schema_, references_, value2);
    case "Number":
      return TNumber(schema_, references_, value2);
    case "Object":
      return TObject(schema_, references_, value2);
    case "Record":
      return TRecord(schema_, references_, value2);
    case "Ref":
      return TRef(schema_, references_, value2);
    case "String":
      return TString(schema_, references_, value2);
    case "Symbol":
      return TSymbol(schema_, references_, value2);
    case "This":
      return TThis(schema_, references_, value2);
    case "Tuple":
      return TTuple(schema_, references_, value2);
    case "Undefined":
      return TUndefined(schema_, references_, value2);
    case "Union":
      return TUnion(schema_, references_, value2);
    case "Any":
    case "AsyncIterator":
    case "Constructor":
    case "Function":
    case "Iterator":
    case "Never":
    case "Promise":
    case "TemplateLiteral":
    case "Uint8Array":
    case "Unknown":
    case "Void":
      return Default(value2);
    default:
      if (!Types$2.TypeRegistry.Has(schema_[Types$2.Kind]))
        throw new ValueConvertUnknownTypeError(schema_);
      return Default(value2);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
}
convert.Convert = Convert;
var transform = {};
Object.defineProperty(transform, "__esModule", { value: true });
transform.EncodeTransform = transform.DecodeTransform = transform.HasTransform = transform.TransformEncodeError = transform.TransformDecodeError = transform.TransformEncodeCheckError = transform.TransformDecodeCheckError = void 0;
const guard_1$1 = guard;
const deref_1$1 = deref;
const check_1 = check;
const Types$1 = typebox;
class TransformDecodeCheckError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value2;
    this.error = error;
  }
}
transform.TransformDecodeCheckError = TransformDecodeCheckError;
class TransformEncodeCheckError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value2;
    this.error = error;
  }
}
transform.TransformEncodeCheckError = TransformEncodeCheckError;
class TransformDecodeError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value2;
  }
}
transform.TransformDecodeError = TransformDecodeError;
class TransformEncodeError extends Types$1.TypeBoxError {
  constructor(schema, value2, error) {
    super(`${error instanceof Error ? error.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value2;
  }
}
transform.TransformEncodeError = TransformEncodeError;
var HasTransform;
(function(HasTransform2) {
  function TArray2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TAsyncIterator2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TConstructor2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.returns, references) || schema.parameters.some((schema2) => Visit2(schema2, references));
  }
  function TFunction2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.returns, references) || schema.parameters.some((schema2) => Visit2(schema2, references));
  }
  function TIntersect2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Types$1.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit2(schema2, references));
  }
  function TIterator2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.items, references);
  }
  function TNot2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.not, references);
  }
  function TObject2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema2) => Visit2(schema2, references)) || Types$1.TypeGuard.TSchema(schema.additionalProperties) && Visit2(schema.additionalProperties, references);
  }
  function TPromise2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || Visit2(schema.item, references);
  }
  function TRecord2(schema, references) {
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern2];
    return Types$1.TypeGuard.TTransform(schema) || Visit2(property, references) || Types$1.TypeGuard.TSchema(schema.additionalProperties) && Types$1.TypeGuard.TTransform(schema.additionalProperties);
  }
  function TRef2(schema, references) {
    if (Types$1.TypeGuard.TTransform(schema))
      return true;
    return Visit2((0, deref_1$1.Deref)(schema, references), references);
  }
  function TThis2(schema, references) {
    if (Types$1.TypeGuard.TTransform(schema))
      return true;
    return Visit2((0, deref_1$1.Deref)(schema, references), references);
  }
  function TTuple2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || !(0, guard_1$1.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit2(schema2, references));
  }
  function TUnion2(schema, references) {
    return Types$1.TypeGuard.TTransform(schema) || schema.anyOf.some((schema2) => Visit2(schema2, references));
  }
  function Visit2(schema, references) {
    const references_ = (0, guard_1$1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
      return false;
    if (schema.$id)
      visited.add(schema.$id);
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_);
      case "AsyncIterator":
        return TAsyncIterator2(schema_, references_);
      case "Constructor":
        return TConstructor2(schema_, references_);
      case "Function":
        return TFunction2(schema_, references_);
      case "Intersect":
        return TIntersect2(schema_, references_);
      case "Iterator":
        return TIterator2(schema_, references_);
      case "Not":
        return TNot2(schema_, references_);
      case "Object":
        return TObject2(schema_, references_);
      case "Promise":
        return TPromise2(schema_, references_);
      case "Record":
        return TRecord2(schema_, references_);
      case "Ref":
        return TRef2(schema_, references_);
      case "This":
        return TThis2(schema_, references_);
      case "Tuple":
        return TTuple2(schema_, references_);
      case "Union":
        return TUnion2(schema_, references_);
      default:
        return Types$1.TypeGuard.TTransform(schema);
    }
  }
  const visited = /* @__PURE__ */ new Set();
  function Has(schema, references) {
    visited.clear();
    return Visit2(schema, references);
  }
  HasTransform2.Has = Has;
})(HasTransform || (transform.HasTransform = HasTransform = {}));
var DecodeTransform;
(function(DecodeTransform2) {
  function Default2(schema, value2) {
    try {
      return Types$1.TypeGuard.TTransform(schema) ? schema[Types$1.Transform].Decode(value2) : value2;
    } catch (error) {
      throw new TransformDecodeError(schema, value2, error);
    }
  }
  function TArray2(schema, references, value2) {
    return (0, guard_1$1.IsArray)(value2) ? Default2(schema, value2.map((value3) => Visit2(schema.items, references, value3))) : Default2(schema, value2);
  }
  function TIntersect2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2) || (0, guard_1$1.IsValueType)(value2))
      return Default2(schema, value2);
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(Types$1.IndexedAccessor.Resolve(schema, [key]), references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TTransform(schema.unevaluatedProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(unevaluatedProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TNot2(schema, references, value2) {
    return Default2(schema, Visit2(schema.not, references, value2));
  }
  function TObject2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return Default2(schema, value2);
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(schema.properties[key], references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TRecord2(schema, references, value2) {
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return Default2(schema, value2);
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern2);
    const knownProperties = Object.getOwnPropertyNames(value2).reduce((value3, key) => {
      return knownKeys.test(key) ? { ...value3, [key]: Visit2(schema.patternProperties[pattern2], references, value3[key]) } : value3;
    }, value2);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = unknownKeys.reduce((value3, key) => {
      return !knownKeys.test(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
    return Default2(schema, unknownProperties);
  }
  function TRef2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    return Default2(schema, Visit2(target, references, value2));
  }
  function TThis2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    return Default2(schema, Visit2(target, references, value2));
  }
  function TTuple2(schema, references, value2) {
    return (0, guard_1$1.IsArray)(value2) && (0, guard_1$1.IsArray)(schema.items) ? Default2(schema, schema.items.map((schema2, index) => Visit2(schema2, references, value2[index]))) : Default2(schema, value2);
  }
  function TUnion2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    for (const subschema of schema.anyOf) {
      if (!(0, check_1.Check)(subschema, references, defaulted))
        continue;
      return Visit2(subschema, references, defaulted);
    }
    return defaulted;
  }
  function Visit2(schema, references, value2) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_, value2);
      case "Intersect":
        return TIntersect2(schema_, references_, value2);
      case "Not":
        return TNot2(schema_, references_, value2);
      case "Object":
        return TObject2(schema_, references_, value2);
      case "Record":
        return TRecord2(schema_, references_, value2);
      case "Ref":
        return TRef2(schema_, references_, value2);
      case "Symbol":
        return Default2(schema_, value2);
      case "This":
        return TThis2(schema_, references_, value2);
      case "Tuple":
        return TTuple2(schema_, references_, value2);
      case "Union":
        return TUnion2(schema_, references_, value2);
      default:
        return Default2(schema_, value2);
    }
  }
  function Decode(schema, references, value2) {
    return Visit2(schema, references, value2);
  }
  DecodeTransform2.Decode = Decode;
})(DecodeTransform || (transform.DecodeTransform = DecodeTransform = {}));
var EncodeTransform;
(function(EncodeTransform2) {
  function Default2(schema, value2) {
    try {
      return Types$1.TypeGuard.TTransform(schema) ? schema[Types$1.Transform].Encode(value2) : value2;
    } catch (error) {
      throw new TransformEncodeError(schema, value2, error);
    }
  }
  function TArray2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    return (0, guard_1$1.IsArray)(defaulted) ? defaulted.map((value3) => Visit2(schema.items, references, value3)) : defaulted;
  }
  function TIntersect2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2) || (0, guard_1$1.IsValueType)(value2))
      return defaulted;
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in defaulted ? { ...value3, [key]: Visit2(Types$1.IndexedAccessor.Resolve(schema, [key]), references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TTransform(schema.unevaluatedProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(unevaluatedProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TNot2(schema, references, value2) {
    return Default2(schema.not, Default2(schema, value2));
  }
  function TObject2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return defaulted;
    const knownKeys = Types$1.KeyResolver.ResolveKeys(schema, { includePatterns: false });
    const knownProperties = knownKeys.reduce((value3, key) => {
      return key in value3 ? { ...value3, [key]: Visit2(schema.properties[key], references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.includes(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TRecord2(schema, references, value2) {
    const defaulted = Default2(schema, value2);
    if (!(0, guard_1$1.IsPlainObject)(value2))
      return defaulted;
    const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern2);
    const knownProperties = Object.getOwnPropertyNames(value2).reduce((value3, key) => {
      return knownKeys.test(key) ? { ...value3, [key]: Visit2(schema.patternProperties[pattern2], references, value3[key]) } : value3;
    }, defaulted);
    if (!Types$1.TypeGuard.TSchema(schema.additionalProperties)) {
      return Default2(schema, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    return unknownKeys.reduce((value3, key) => {
      return !knownKeys.test(key) ? { ...value3, [key]: Default2(additionalProperties, value3[key]) } : value3;
    }, knownProperties);
  }
  function TRef2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    const resolved = Visit2(target, references, value2);
    return Default2(schema, resolved);
  }
  function TThis2(schema, references, value2) {
    const target = (0, deref_1$1.Deref)(schema, references);
    const resolved = Visit2(target, references, value2);
    return Default2(schema, resolved);
  }
  function TTuple2(schema, references, value2) {
    const value1 = Default2(schema, value2);
    return (0, guard_1$1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit2(schema2, references, value1[index])) : [];
  }
  function TUnion2(schema, references, value2) {
    for (const subschema of schema.anyOf) {
      if (!(0, check_1.Check)(subschema, references, value2))
        continue;
      const value1 = Visit2(subschema, references, value2);
      return Default2(schema, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit2(subschema, references, value2);
      if (!(0, check_1.Check)(schema, references, value1))
        continue;
      return Default2(schema, value1);
    }
    return Default2(schema, value2);
  }
  function Visit2(schema, references, value2) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types$1.Kind]) {
      case "Array":
        return TArray2(schema_, references_, value2);
      case "Intersect":
        return TIntersect2(schema_, references_, value2);
      case "Not":
        return TNot2(schema_, references_, value2);
      case "Object":
        return TObject2(schema_, references_, value2);
      case "Record":
        return TRecord2(schema_, references_, value2);
      case "Ref":
        return TRef2(schema_, references_, value2);
      case "This":
        return TThis2(schema_, references_, value2);
      case "Tuple":
        return TTuple2(schema_, references_, value2);
      case "Union":
        return TUnion2(schema_, references_, value2);
      default:
        return Default2(schema_, value2);
    }
  }
  function Encode(schema, references, value2) {
    return Visit2(schema, references, value2);
  }
  EncodeTransform2.Encode = Encode;
})(EncodeTransform || (transform.EncodeTransform = EncodeTransform = {}));
Object.defineProperty(value, "__esModule", { value: true });
value.Value = void 0;
const ValueErrors = errors$1;
const ValueMutate = mutate;
const ValueHash = hash$1;
const ValueEqual = equal;
const ValueCast = cast;
const ValueClone = clone;
const ValueConvert = convert;
const ValueCreate = create;
const ValueCheck = check;
const ValueDelta = delta;
const ValueTransform = transform;
var Value;
(function(Value2) {
  function Cast2(...args) {
    return ValueCast.Cast.apply(ValueCast, args);
  }
  Value2.Cast = Cast2;
  function Create2(...args) {
    return ValueCreate.Create.apply(ValueCreate, args);
  }
  Value2.Create = Create2;
  function Check2(...args) {
    return ValueCheck.Check.apply(ValueCheck, args);
  }
  Value2.Check = Check2;
  function Convert2(...args) {
    return ValueConvert.Convert.apply(ValueConvert, args);
  }
  Value2.Convert = Convert2;
  function Clone2(value2) {
    return ValueClone.Clone(value2);
  }
  Value2.Clone = Clone2;
  function Decode(...args) {
    const [schema, references, value2] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check2(schema, references, value2))
      throw new ValueTransform.TransformDecodeCheckError(schema, value2, Errors(schema, references, value2).First());
    return ValueTransform.DecodeTransform.Decode(schema, references, value2);
  }
  Value2.Decode = Decode;
  function Encode(...args) {
    const [schema, references, value2] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value2);
    if (!Check2(schema, references, encoded))
      throw new ValueTransform.TransformEncodeCheckError(schema, value2, Errors(schema, references, value2).First());
    return encoded;
  }
  Value2.Encode = Encode;
  function Errors(...args) {
    return ValueErrors.Errors.apply(ValueErrors, args);
  }
  Value2.Errors = Errors;
  function Equal2(left, right) {
    return ValueEqual.Equal(left, right);
  }
  Value2.Equal = Equal2;
  function Diff(current, next) {
    return ValueDelta.Diff(current, next);
  }
  Value2.Diff = Diff;
  function Hash2(value2) {
    return ValueHash.Hash(value2);
  }
  Value2.Hash = Hash2;
  function Patch(current, edits) {
    return ValueDelta.Patch(current, edits);
  }
  Value2.Patch = Patch;
  function Mutate2(current, next) {
    ValueMutate.Mutate(current, next);
  }
  Value2.Mutate = Mutate2;
})(Value || (value.Value = Value = {}));
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = void 0;
  var index_12 = errors$1;
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_12.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_12.ValueErrorIterator;
  } });
  var delta_1 = delta;
  Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
    return delta_1.Edit;
  } });
  Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
    return delta_1.Insert;
  } });
  Object.defineProperty(exports, "Update", { enumerable: true, get: function() {
    return delta_1.Update;
  } });
  Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
    return delta_1.Delete;
  } });
  var pointer_12 = pointer;
  Object.defineProperty(exports, "ValuePointer", { enumerable: true, get: function() {
    return pointer_12.ValuePointer;
  } });
  var value_1 = value;
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return value_1.Value;
  } });
})(value$1);
const resolveMessageLintRules = (args) => {
  const result = {
    data: [],
    errors: []
  };
  for (const rule of args.messageLintRules) {
    if (value$1.Value.Check(MessageLintRule, rule) === false) {
      const errors2 = [...value$1.Value.Errors(MessageLintRule, rule)];
      result.errors.push(new MessageLintRuleIsInvalidError({
        // @ts-ignore
        id: rule.id,
        errors: errors2
      }));
      continue;
    } else {
      result.data.push(rule);
    }
  }
  return result;
};
function escape(url) {
  const bytes = new TextEncoder().encode(url);
  const hash2 = bytes.reduce((hash3, byte) => BigInt.asUintN(64, (hash3 ^ BigInt(byte)) * 1099511628211n), 14695981039346656037n);
  return hash2.toString(36);
}
async function readModuleFromCache(moduleURI, projectPath, readFile) {
  const moduleHash = escape(moduleURI);
  const filePath = projectPath + `/cache/modules/${moduleHash}`;
  return await tryCatch(async () => await readFile(filePath, { encoding: "utf-8" }));
}
async function writeModuleToCache(moduleURI, moduleContent, projectPath, writeFile, mkdir) {
  const moduleHash = escape(moduleURI);
  const filePath = projectPath + `/cache/modules/${moduleHash}`;
  const writeFileResult = await tryCatch(() => writeFile(filePath, moduleContent));
  if (writeFileResult.error) {
    const dirPath = projectPath + `/cache/modules`;
    const createDirResult = await tryCatch(() => mkdir(dirPath, { recursive: true }));
    if (createDirResult.error && createDirResult.error.code !== "EEXIST")
      throw new Error("[sdk:module-cacke] failed to create cache-directory. Path: " + dirPath, {
        cause: createDirResult.error
      });
    const writeFileResult2 = await tryCatch(() => writeFile(filePath, moduleContent));
    if (writeFileResult2.error)
      throw new Error("[sdk:module-cacke] failed to write cache-file. Path: " + filePath, {
        cause: writeFileResult2.error
      });
  }
}
function withCache(moduleLoader, projectPath, nodeishFs) {
  return async (uri) => {
    const cachePromise = readModuleFromCache(uri, projectPath, nodeishFs.readFile);
    const loaderResult = await tryCatch(async () => await moduleLoader(uri));
    if (loaderResult.error) {
      const cacheResult = await cachePromise;
      if (!cacheResult.error)
        return cacheResult.data;
      else
        throw loaderResult.error;
    } else {
      const moduleAsText = loaderResult.data;
      try {
        await writeModuleToCache(uri, moduleAsText, projectPath, nodeishFs.writeFile, nodeishFs.mkdir);
      } catch (error) {
      }
      return moduleAsText;
    }
  };
}
function createImport(projectPath, nodeishFs) {
  return (uri) => $import(uri, projectPath, nodeishFs);
}
async function $import(uri, projectPath, nodeishFs) {
  const moduleAsText = uri.startsWith("http") ? await withCache(readModuleFromCDN, projectPath, nodeishFs)(uri) : await readModulefromDisk(uri, nodeishFs.readFile);
  const moduleWithMimeType = "data:application/javascript," + encodeURIComponent(moduleAsText);
  try {
    return await import(
      /* @vite-ignore */
      moduleWithMimeType
    );
  } catch (error) {
    if (error instanceof SyntaxError && uri.includes("jsdelivr")) {
      error.message += dedent`\n\n
				Are you sure that the file exists on JSDelivr?

				The error indicates that the imported file does not exist on JSDelivr. For non-existent files, JSDelivr returns a 404 text that JS cannot parse as a module and throws a SyntaxError.`;
    }
    throw new ModuleImportError({ module: uri, cause: error });
  }
}
async function readModulefromDisk(uri, readFile) {
  try {
    return await readFile(uri, { encoding: "utf-8" });
  } catch (error) {
    throw new ModuleImportError({ module: uri, cause: error });
  }
}
async function readModuleFromCDN(uri) {
  var _a;
  if (!isValidUrl(uri))
    throw new ModuleImportError({ module: uri, cause: new Error("Malformed URL") });
  const result = await tryCatch(async () => await fetch(uri));
  if (result.error) {
    throw new ModuleImportError({
      module: uri,
      cause: result.error
    });
  }
  const response = result.data;
  if (!response.ok) {
    throw new ModuleImportError({
      module: uri,
      cause: new Error(`Failed to fetch module. HTTP status: ${response.status}, Message: ${response.statusText}`)
    });
  }
  const JS_CONTENT_TYPES = [
    "application/javascript",
    "text/javascript",
    "application/x-javascript",
    "text/x-javascript"
  ];
  const contentType = (_a = response.headers.get("content-type")) == null ? void 0 : _a.toLowerCase();
  if (contentType && !JS_CONTENT_TYPES.some((knownType) => contentType.includes(knownType))) {
    throw new ModuleImportError({
      module: uri,
      cause: new Error(`Server responded with ${contentType} insetad of a JavaScript module`)
    });
  }
  return await response.text();
}
function isValidUrl(url) {
  const URLConstructor = URL;
  if ("canParse" in URL) {
    return URL.canParse(url);
  }
  try {
    new URLConstructor(url);
    return true;
  } catch (e) {
    console.warn(`Invalid URL: ${url}`);
    return false;
  }
}
const actions = {
  defaultMerge: Symbol("deepmerge-ts: default merge"),
  skip: Symbol("deepmerge-ts: skip")
};
({
  defaultMerge: actions.defaultMerge
});
function defaultMetaDataUpdater(previousMeta, metaMeta) {
  return metaMeta;
}
function getObjectType(object) {
  if (typeof object !== "object" || object === null) {
    return 0;
  }
  if (Array.isArray(object)) {
    return 2;
  }
  if (isRecord(object)) {
    return 1;
  }
  if (object instanceof Set) {
    return 3;
  }
  if (object instanceof Map) {
    return 4;
  }
  return 5;
}
function getKeys(objects) {
  const keys = /* @__PURE__ */ new Set();
  for (const object of objects) {
    for (const key of [
      ...Object.keys(object),
      ...Object.getOwnPropertySymbols(object)
    ]) {
      keys.add(key);
    }
  }
  return keys;
}
function objectHasProperty(object, property) {
  return typeof object === "object" && Object.prototype.propertyIsEnumerable.call(object, property);
}
function getIterableOfIterables(iterables) {
  return {
    // eslint-disable-next-line functional/functional-parameters
    *[Symbol.iterator]() {
      for (const iterable of iterables) {
        for (const value2 of iterable) {
          yield value2;
        }
      }
    }
  };
}
const validRecordToStringValues = /* @__PURE__ */ new Set([
  "[object Object]",
  "[object Module]"
]);
function isRecord(value2) {
  if (!validRecordToStringValues.has(Object.prototype.toString.call(value2))) {
    return false;
  }
  const { constructor } = value2;
  if (constructor === void 0) {
    return true;
  }
  const prototype = constructor.prototype;
  if (prototype === null || typeof prototype !== "object" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {
    return false;
  }
  if (!prototype.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function mergeRecords$2(values, utils, meta) {
  const result = {};
  for (const key of getKeys(values)) {
    const propValues = [];
    for (const value2 of values) {
      if (objectHasProperty(value2, key)) {
        propValues.push(value2[key]);
      }
    }
    if (propValues.length === 0) {
      continue;
    }
    const updatedMeta = utils.metaDataUpdater(meta, {
      key,
      parents: values
    });
    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);
    if (propertyResult === actions.skip) {
      continue;
    }
    if (key === "__proto__") {
      Object.defineProperty(result, key, {
        value: propertyResult,
        configurable: true,
        enumerable: true,
        writable: true
      });
    } else {
      result[key] = propertyResult;
    }
  }
  return result;
}
function mergeArrays$2(values) {
  return values.flat();
}
function mergeSets$2(values) {
  return new Set(getIterableOfIterables(values));
}
function mergeMaps$2(values) {
  return new Map(getIterableOfIterables(values));
}
function mergeOthers$2(values) {
  return values.at(-1);
}
var defaultMergeFunctions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mergeArrays: mergeArrays$2,
  mergeMaps: mergeMaps$2,
  mergeOthers: mergeOthers$2,
  mergeRecords: mergeRecords$2,
  mergeSets: mergeSets$2
});
function deepmerge(...objects) {
  return deepmergeCustom({})(...objects);
}
function deepmergeCustom(options, rootMetaData) {
  const utils = getUtils(options, customizedDeepmerge);
  function customizedDeepmerge(...objects) {
    return mergeUnknowns(objects, utils, rootMetaData);
  }
  return customizedDeepmerge;
}
function getUtils(options, customizedDeepmerge) {
  return {
    defaultMergeFunctions,
    mergeFunctions: {
      ...defaultMergeFunctions,
      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.hasOwn(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))
    },
    metaDataUpdater: options.metaDataUpdater ?? defaultMetaDataUpdater,
    deepmerge: customizedDeepmerge,
    useImplicitDefaultMerging: options.enableImplicitDefaultMerging ?? false,
    actions
  };
}
function mergeUnknowns(values, utils, meta) {
  if (values.length === 0) {
    return void 0;
  }
  if (values.length === 1) {
    return mergeOthers$1(values, utils, meta);
  }
  const type = getObjectType(values[0]);
  if (type !== 0 && type !== 5) {
    for (let m_index = 1; m_index < values.length; m_index++) {
      if (getObjectType(values[m_index]) === type) {
        continue;
      }
      return mergeOthers$1(values, utils, meta);
    }
  }
  switch (type) {
    case 1: {
      return mergeRecords$1(values, utils, meta);
    }
    case 2: {
      return mergeArrays$1(values, utils, meta);
    }
    case 3: {
      return mergeSets$1(values, utils, meta);
    }
    case 4: {
      return mergeMaps$1(values, utils, meta);
    }
    default: {
      return mergeOthers$1(values, utils, meta);
    }
  }
}
function mergeRecords$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {
    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);
  }
  return result;
}
function mergeArrays$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {
    return utils.defaultMergeFunctions.mergeArrays(values);
  }
  return result;
}
function mergeSets$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeSets(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {
    return utils.defaultMergeFunctions.mergeSets(values);
  }
  return result;
}
function mergeMaps$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {
    return utils.defaultMergeFunctions.mergeMaps(values);
  }
  return result;
}
function mergeOthers$1(values, utils, meta) {
  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);
  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === void 0 && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {
    return utils.defaultMergeFunctions.mergeOthers(values);
  }
  return result;
}
var compiler$1 = {};
var compiler = {};
Object.defineProperty(compiler, "__esModule", { value: true });
compiler.TypeCompiler = compiler.Policy = compiler.TypeCompilerTypeGuardError = compiler.TypeCompilerUnknownTypeError = compiler.TypeCheck = void 0;
const transform_1 = transform;
const guard_1 = guard;
const errors_1 = requireErrors();
const index_1 = system;
const deref_1 = deref;
const hash_1 = hash$1;
const Types = typebox;
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = transform_1.HasTransform.Has(schema, references);
  }
  /** Returns the generated assertion code used to validate this type. */
  Code() {
    return this.code;
  }
  /** Returns an iterator for each error in this value. */
  Errors(value2) {
    return (0, errors_1.Errors)(this.schema, this.references, value2);
  }
  /** Returns true if the value matches the compiled type. */
  Check(value2) {
    return this.checkFunc(value2);
  }
  /** Decodes a value or throws if error */
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new transform_1.TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value2) : value2;
  }
  /** Encodes a value or throws if error */
  Encode(value2) {
    const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new transform_1.TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
compiler.TypeCheck = TypeCheck;
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i2 = 0; i2 < value2.length; i2++) {
      const code = value2.charCodeAt(i2);
      const check2 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check2)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode($id) {
    const buffer = [];
    for (let i2 = 0; i2 < $id.length; i2++) {
      const code = $id.charCodeAt(i2);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i2));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape;
})(LiteralString || (LiteralString = {}));
class TypeCompilerUnknownTypeError extends Types.TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
compiler.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
class TypeCompilerTypeGuardError extends Types.TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
compiler.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value2} === 'number' && Number.isFinite(${value2}))` : `typeof ${value2} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (compiler.Policy = Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
  }
  function* TAny2(schema, references, value2) {
    yield "true";
  }
  function* TArray2(schema, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if ((0, guard_1.IsNumber)(schema.maxItems))
      yield `${value2}.length <= ${schema.maxItems}`;
    if ((0, guard_1.IsNumber)(schema.minItems))
      yield `${value2}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (Types.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {
      const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check2 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value2})`;
    }
    if (schema.uniqueItems === true) {
      const check2 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check2} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* TAsyncIterator2(schema, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* TBigInt2(schema, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))
      yield `${value2} < BigInt(${schema.exclusiveMaximum})`;
    if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))
      yield `${value2} > BigInt(${schema.exclusiveMinimum})`;
    if ((0, guard_1.IsBigInt)(schema.maximum))
      yield `${value2} <= BigInt(${schema.maximum})`;
    if ((0, guard_1.IsBigInt)(schema.minimum))
      yield `${value2} >= BigInt(${schema.minimum})`;
    if ((0, guard_1.IsBigInt)(schema.multipleOf))
      yield `(${value2} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* TBoolean2(schema, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* TConstructor2(schema, references, value2) {
    yield* Visit2(schema.returns, references, `${value2}.prototype`);
  }
  function* TDate2(schema, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema.maximumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema.minimumTimestamp}`;
    if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* TFunction2(schema, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* TInteger2(schema, references, value2) {
    yield `(typeof ${value2} === 'number' && Number.isInteger(${value2}))`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
      yield `${value2} < ${schema.exclusiveMaximum}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
      yield `${value2} > ${schema.exclusiveMinimum}`;
    if ((0, guard_1.IsNumber)(schema.maximum))
      yield `${value2} <= ${schema.maximum}`;
    if ((0, guard_1.IsNumber)(schema.minimum))
      yield `${value2} >= ${schema.minimum}`;
    if ((0, guard_1.IsNumber)(schema.multipleOf))
      yield `(${value2} % ${schema.multipleOf}) === 0`;
  }
  function* TIntersect2(schema, references, value2) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value2)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check2})`;
    } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
      const check2 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check2})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* TIterator2(schema, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* TLiteral2(schema, references, value2) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value2} === ${schema.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* TNever2(schema, references, value2) {
    yield `false`;
  }
  function* TNot2(schema, references, value2) {
    const expression = CreateExpression(schema.not, references, value2);
    yield `(!${expression})`;
  }
  function* TNull2(schema, references, value2) {
    yield `(${value2} === null)`;
  }
  function* TNumber2(schema, references, value2) {
    yield Policy.IsNumberLike(value2);
    if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
      yield `${value2} < ${schema.exclusiveMaximum}`;
    if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
      yield `${value2} > ${schema.exclusiveMinimum}`;
    if ((0, guard_1.IsNumber)(schema.maximum))
      yield `${value2} <= ${schema.maximum}`;
    if ((0, guard_1.IsNumber)(schema.minimum))
      yield `${value2} >= ${schema.minimum}`;
    if ((0, guard_1.IsNumber)(schema.multipleOf))
      yield `(${value2} % ${schema.multipleOf}) === 0`;
  }
  function* TObject2(schema, references, value2) {
    yield Policy.IsObjectLike(value2);
    if ((0, guard_1.IsNumber)(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema.minProperties}`;
    if ((0, guard_1.IsNumber)(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit2(property, references, memberExpression);
        if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* TPromise2(schema, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* TRecord2(schema, references, value2) {
    yield Policy.IsRecordLike(value2);
    if ((0, guard_1.IsNumber)(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema.minProperties}`;
    if ((0, guard_1.IsNumber)(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value2) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* TRef2(schema, references, value2) {
    const target = (0, deref_1.Deref)(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value2})`;
    yield* Visit2(target, references, value2);
  }
  function* TString2(schema, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if ((0, guard_1.IsNumber)(schema.maxLength))
      yield `${value2}.length <= ${schema.maxLength}`;
    if ((0, guard_1.IsNumber)(schema.minLength))
      yield `${value2}.length >= ${schema.minLength}`;
    if (schema.pattern !== void 0) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema.format !== void 0) {
      yield `format('${schema.format}', ${value2})`;
    }
  }
  function* TSymbol2(schema, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* TTemplateLiteral2(schema, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* TThis2(schema, references, value2) {
    yield `${CreateFunctionName(schema.$ref)}(${value2})`;
  }
  function* TTuple2(schema, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema.items === void 0)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema.maxItems})`;
    for (let i2 = 0; i2 < schema.items.length; i2++) {
      const expression = CreateExpression(schema.items[i2], references, `${value2}[${i2}]`);
      yield `${expression}`;
    }
  }
  function* TUndefined2(schema, references, value2) {
    yield `${value2} === undefined`;
  }
  function* TUnion2(schema, references, value2) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* TUint8Array2(schema, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if ((0, guard_1.IsNumber)(schema.maxByteLength))
      yield `(${value2}.length <= ${schema.maxByteLength})`;
    if ((0, guard_1.IsNumber)(schema.minByteLength))
      yield `(${value2}.length >= ${schema.minByteLength})`;
  }
  function* TUnknown2(schema, references, value2) {
    yield "true";
  }
  function* TVoid2(schema, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* TKind2(schema, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Types.Kind]}', ${instance}, ${value2})`;
  }
  function* Visit2(schema, references, value2, useHoisting = true) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && (0, guard_1.IsString)(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny2();
      case "Array":
        return yield* TArray2(schema_, references_, value2);
      case "AsyncIterator":
        return yield* TAsyncIterator2(schema_, references_, value2);
      case "BigInt":
        return yield* TBigInt2(schema_, references_, value2);
      case "Boolean":
        return yield* TBoolean2(schema_, references_, value2);
      case "Constructor":
        return yield* TConstructor2(schema_, references_, value2);
      case "Date":
        return yield* TDate2(schema_, references_, value2);
      case "Function":
        return yield* TFunction2(schema_, references_, value2);
      case "Integer":
        return yield* TInteger2(schema_, references_, value2);
      case "Intersect":
        return yield* TIntersect2(schema_, references_, value2);
      case "Iterator":
        return yield* TIterator2(schema_, references_, value2);
      case "Literal":
        return yield* TLiteral2(schema_, references_, value2);
      case "Never":
        return yield* TNever2();
      case "Not":
        return yield* TNot2(schema_, references_, value2);
      case "Null":
        return yield* TNull2(schema_, references_, value2);
      case "Number":
        return yield* TNumber2(schema_, references_, value2);
      case "Object":
        return yield* TObject2(schema_, references_, value2);
      case "Promise":
        return yield* TPromise2(schema_, references_, value2);
      case "Record":
        return yield* TRecord2(schema_, references_, value2);
      case "Ref":
        return yield* TRef2(schema_, references_, value2);
      case "String":
        return yield* TString2(schema_, references_, value2);
      case "Symbol":
        return yield* TSymbol2(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* TTemplateLiteral2(schema_, references_, value2);
      case "This":
        return yield* TThis2(schema_, references_, value2);
      case "Tuple":
        return yield* TTuple2(schema_, references_, value2);
      case "Undefined":
        return yield* TUndefined2(schema_, references_, value2);
      case "Union":
        return yield* TUnion2(schema_, references_, value2);
      case "Uint8Array":
        return yield* TUint8Array2(schema_, references_, value2);
      case "Unknown":
        return yield* TUnknown2();
      case "Void":
        return yield* TVoid2(schema_, references_, value2);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* TKind2(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: /* @__PURE__ */ new Map(),
    variables: /* @__PURE__ */ new Map(),
    instances: /* @__PURE__ */ new Map()
    // exterior kind instances
  };
  function CreateExpression(schema, references, value2, useHoisting = true) {
    return `(${[...Visit2(schema, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value2, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit2(schema, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type) {
    const annotation = state.language === "typescript" ? `: ${type}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type) {
    return state.language === "typescript" ? `: ${type}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = (0, guard_1.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args.length === 2 && (0, guard_1.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, guard_1.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!Types.TypeGuard.TSchema(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!Types.TypeGuard.TSchema(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = Types.TypeRegistry.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!Types.FormatRegistry.Has(format))
        return false;
      const checkFunc = Types.FormatRegistry.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return (0, hash_1.Hash)(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (compiler.TypeCompiler = TypeCompiler = {}));
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = void 0;
  var index_12 = errors$1;
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_12.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_12.ValueErrorIterator;
  } });
  __exportStar(compiler, exports);
})(compiler$1);
var src = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split2[i2]) {
          continue;
        }
        namespaces = split2[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag)
    return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor)
    return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0;
  const tty = require$$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let flagForceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== void 0) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
        return 3;
      }
      if (hasFlag2("color=256")) {
        return 2;
      }
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function getSupportLevel(stream, options = {}) {
    const level = supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel({ isTTY: tty.isatty(1) }),
    stderr: getSupportLevel({ isTTY: tty.isatty(2) })
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node.exports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$1;
    const util = require$$1$1;
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports.inspectOpts[keys[i2]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  })(node, node.exports);
  return node.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src.exports = requireBrowser();
} else {
  src.exports = requireNode();
}
var srcExports = src.exports;
const _debug = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
const debug$7 = _debug("sdk:resolvePlugins");
const PluginCompiler = compiler$1.TypeCompiler.Compile(Plugin);
const resolvePlugins = async (args) => {
  var _a;
  const result = {
    data: {
      loadMessages: void 0,
      saveMessages: void 0,
      customApi: {}
    },
    errors: []
  };
  const experimentalPersistence = !!((_a = args.settings.experimental) == null ? void 0 : _a.persistence);
  if (experimentalPersistence) {
    debug$7("Using experimental persistence");
  }
  for (const plugin of args.plugins) {
    const errors2 = [...PluginCompiler.Errors(plugin)];
    const hasInvalidId = errors2.some((error) => error.path === "/id");
    if (hasInvalidId) {
      result.errors.push(new PluginHasInvalidIdError({ id: plugin.id }));
    }
    if (errors2.length > 0) {
      result.errors.push(new PluginHasInvalidSchemaError({
        id: plugin.id,
        errors: errors2
      }));
    }
    if (typeof plugin.loadMessages === "function" && result.data.loadMessages !== void 0) {
      result.errors.push(new PluginLoadMessagesFunctionAlreadyDefinedError({ id: plugin.id }));
    }
    if (typeof plugin.saveMessages === "function" && result.data.saveMessages !== void 0) {
      result.errors.push(new PluginSaveMessagesFunctionAlreadyDefinedError({ id: plugin.id }));
    }
    if (typeof plugin.addCustomApi === "function") {
      const { data: customApi, error } = tryCatch(() => plugin.addCustomApi({
        settings: args.settings
      }));
      if (error) {
        result.errors.push(new PluginReturnedInvalidCustomApiError({ id: plugin.id, cause: error }));
      } else if (typeof customApi !== "object") {
        result.errors.push(new PluginReturnedInvalidCustomApiError({
          id: plugin.id,
          cause: new Error(`The return value must be an object. Received "${typeof customApi}".`)
        }));
      }
    }
    if (result.errors.length > 0) {
      continue;
    }
    if (typeof plugin.loadMessages === "function") {
      result.data.loadMessages = plugin.loadMessages;
    }
    if (typeof plugin.saveMessages === "function") {
      result.data.saveMessages = plugin.saveMessages;
    }
    if (typeof plugin.addCustomApi === "function") {
      const { data: customApi } = tryCatch(() => plugin.addCustomApi({
        settings: args.settings
      }));
      if (customApi) {
        result.data.customApi = deepmerge(result.data.customApi, customApi);
      }
    }
  }
  if (!experimentalPersistence && (typeof result.data.loadMessages !== "function" || typeof result.data.saveMessages !== "function")) {
    result.errors.push(new PluginsDoNotProvideLoadOrSaveMessagesError());
  }
  return result;
};
const validatedModuleSettings = (args) => {
  if (args.settingsSchema && args.moduleSettings) {
    const hasValidSettings = value$1.Value.Check(args.settingsSchema, args.moduleSettings);
    if (hasValidSettings === false) {
      const errors2 = [...value$1.Value.Errors(args.settingsSchema, args.moduleSettings)];
      return errors2;
    }
  }
  return "isValid";
};
const ModuleCompiler = compiler$1.TypeCompiler.Compile(InlangModule);
const resolveModules = async (args) => {
  const _import = args._import ?? createImport(args.projectPath, args.nodeishFs);
  const allPlugins = [];
  const allMessageLintRules = [];
  const meta = [];
  const moduleErrors = [];
  async function resolveModule(module) {
    var _a;
    const importedModule = await tryCatch(() => _import(module));
    if (importedModule.error) {
      moduleErrors.push(new ModuleImportError({
        module,
        cause: importedModule.error
      }));
      return;
    }
    if (((_a = importedModule.data) == null ? void 0 : _a.default) === void 0) {
      moduleErrors.push(new ModuleHasNoExportsError({
        module
      }));
      return;
    }
    const isValidModule = ModuleCompiler.Check(importedModule.data);
    if (isValidModule === false) {
      const errors2 = [...ModuleCompiler.Errors(importedModule.data)];
      moduleErrors.push(new ModuleExportIsInvalidError({
        module,
        errors: errors2
      }));
      return;
    }
    const result = validatedModuleSettings({
      settingsSchema: importedModule.data.default.settingsSchema,
      moduleSettings: args.settings[importedModule.data.default.id]
    });
    if (result !== "isValid") {
      moduleErrors.push(new ModuleSettingsAreInvalidError({ module, errors: result }));
      return;
    }
    meta.push({
      module,
      id: importedModule.data.default.id
    });
    if (importedModule.data.default.id.startsWith("plugin.")) {
      allPlugins.push(importedModule.data.default);
    } else if (importedModule.data.default.id.startsWith("messageLintRule.")) {
      allMessageLintRules.push(importedModule.data.default);
    } else {
      moduleErrors.push(new ModuleError(`Unimplemented module type ${importedModule.data.default.id}.The module has not been installed.`, { module }));
    }
  }
  await Promise.all(args.settings.modules.map(resolveModule));
  const resolvedPlugins = await resolvePlugins({
    plugins: allPlugins,
    settings: args.settings,
    nodeishFs: args.nodeishFs
  });
  const resolvedLintRules = resolveMessageLintRules({ messageLintRules: allMessageLintRules });
  return {
    meta,
    messageLintRules: allMessageLintRules,
    plugins: allPlugins,
    resolvedPluginApi: resolvedPlugins.data,
    errors: [...moduleErrors, ...resolvedLintRules.errors, ...resolvedPlugins.errors]
  };
};
function assertValidProjectPath(projectPath) {
  if (!isAbsolutePath(projectPath)) {
    throw new Error(`Expected an absolute path but received "${projectPath}".`);
  }
  if (!isInlangProjectPath(projectPath)) {
    throw new Error(`Expected a path ending in "{name}.inlang" but received "${projectPath}".

Valid examples: 
- "/path/to/micky-mouse.inlang"
- "/path/to/green-elephant.inlang
`);
  }
}
function isInlangProjectPath(path) {
  return /[^\\/]+\.inlang$/.test(path);
}
function isAbsolutePath(path) {
  return /^\/|^[A-Za-z]:[\\/]/.test(path);
}
class ProjectSettingsInvalidError extends Error {
  constructor(options) {
    super(`The project settings are invalid:
${options.errors.filter((error) => error.path).map(FormatProjectSettingsError).join("\n")}`);
    this.name = "ProjectSettingsInvalidError";
  }
}
function FormatProjectSettingsError(error) {
  let msg = `${error.message} at ${error.path}`;
  if (error.path.startsWith("/modules/")) {
    msg += `
value = "${error.value}"
- ${error.schema.allOf.map((o) => `${o.description ?? ""}`).join("\n- ")}`;
  }
  return msg;
}
class ProjectSettingsFileJSONSyntaxError extends Error {
  constructor(options) {
    super(`The settings file at "${options.path}" is not a valid JSON file:

${options.cause}`, options);
    this.name = "ProjectSettingsFileJSONSyntaxError";
  }
}
class ProjectSettingsFileNotFoundError extends Error {
  constructor(options) {
    super(`The file at "${options.path}" could not be read. Does the file exists?`, options);
    this.name = "ProjectSettingsFileNotFoundError";
  }
}
class PluginSaveMessagesError extends Error {
  constructor(options) {
    super(`An error occured in saveMessages() caused by ${options.cause}.`, options);
    this.name = "PluginSaveMessagesError";
  }
}
class PluginLoadMessagesError extends Error {
  constructor(options) {
    super(`An error occured in loadMessages() caused by ${options.cause}.`, options);
    this.name = "PluginLoadMessagesError";
  }
}
const equalFn = (a, b) => a === b;
const signalOptions = {
  equals: equalFn
};
let runEffects = runQueue;
const STALE = 1;
const PENDING = 2;
const UNOWNED = {
  owned: null,
  cleanups: null,
  context: null,
  owner: null
};
var Owner = null;
let Transition = null;
let Listener = null;
let Updates = null;
let Effects = null;
let ExecCount = 0;
function createRoot$1(fn, detachedOwner) {
  const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {
    owned: null,
    cleanups: null,
    context: null,
    owner: detachedOwner === void 0 ? owner : detachedOwner
  }, updateFn = unowned ? fn : () => fn(() => untrack$1(() => cleanNode(root)));
  Owner = root;
  Listener = null;
  try {
    return runUpdates(updateFn, true);
  } finally {
    Listener = listener;
    Owner = owner;
  }
}
function createSignal$1(value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const s = {
    value: value2,
    observers: null,
    observerSlots: null,
    comparator: options.equals || void 0
  };
  const setter = (value3) => {
    if (typeof value3 === "function") {
      value3 = value3(s.value);
    }
    return writeSignal(s, value3);
  };
  return [readSignal.bind(s), setter];
}
function createEffect$1(fn, value2, options) {
  runEffects = runUserEffects;
  const c = createComputation(fn, value2, false, STALE);
  c.user = true;
  Effects ? Effects.push(c) : updateComputation(c);
}
function createMemo$1(fn, value2, options) {
  options = options ? Object.assign({}, signalOptions, options) : signalOptions;
  const c = createComputation(fn, value2, true, 0);
  c.observers = null;
  c.observerSlots = null;
  c.comparator = options.equals || void 0;
  updateComputation(c);
  return readSignal.bind(c);
}
function batch$1(fn) {
  return runUpdates(fn, false);
}
function untrack$1(fn) {
  if (Listener === null)
    return fn();
  const listener = Listener;
  Listener = null;
  try {
    return fn();
  } finally {
    Listener = listener;
  }
}
function onCleanup$1(fn) {
  if (Owner === null)
    ;
  else if (Owner.cleanups === null)
    Owner.cleanups = [fn];
  else
    Owner.cleanups.push(fn);
  return fn;
}
function getListener$1() {
  return Listener;
}
function readSignal() {
  const runningTransition = Transition;
  if (this.sources && (this.state || runningTransition)) {
    if (this.state === STALE || runningTransition)
      updateComputation(this);
    else {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(this), false);
      Updates = updates;
    }
  }
  if (Listener) {
    const sSlot = this.observers ? this.observers.length : 0;
    if (!Listener.sources) {
      Listener.sources = [this];
      Listener.sourceSlots = [sSlot];
    } else {
      Listener.sources.push(this);
      Listener.sourceSlots.push(sSlot);
    }
    if (!this.observers) {
      this.observers = [Listener];
      this.observerSlots = [Listener.sources.length - 1];
    } else {
      this.observers.push(Listener);
      this.observerSlots.push(Listener.sources.length - 1);
    }
  }
  return this.value;
}
function writeSignal(node2, value2, isComp) {
  let current = node2.value;
  if (!node2.comparator || !node2.comparator(current, value2)) {
    node2.value = value2;
    if (node2.observers && node2.observers.length) {
      runUpdates(() => {
        for (let i2 = 0; i2 < node2.observers.length; i2 += 1) {
          const o = node2.observers[i2];
          const TransitionRunning = Transition && Transition.running;
          if (TransitionRunning && Transition.disposed.has(o))
            ;
          if (TransitionRunning && !o.tState || !TransitionRunning && !o.state) {
            if (o.pure)
              Updates.push(o);
            else
              Effects.push(o);
            if (o.observers)
              markDownstream(o);
          }
          if (TransitionRunning)
            ;
          else
            o.state = STALE;
        }
        if (Updates.length > 1e6) {
          Updates = [];
          if (false)
            ;
          throw new Error();
        }
      }, false);
    }
  }
  return value2;
}
function updateComputation(node2) {
  if (!node2.fn)
    return;
  cleanNode(node2);
  const owner = Owner, listener = Listener, time = ExecCount;
  Listener = Owner = node2;
  runComputation(node2, node2.value, time);
  Listener = listener;
  Owner = owner;
}
function runComputation(node2, value2, time) {
  let nextValue;
  try {
    nextValue = node2.fn(value2);
  } catch (err) {
    if (node2.pure) {
      {
        node2.state = STALE;
        node2.owned && node2.owned.forEach(cleanNode);
        node2.owned = null;
      }
    }
    node2.updatedAt = time + 1;
    return handleError(err);
  }
  if (!node2.updatedAt || node2.updatedAt <= time) {
    if (node2.updatedAt != null && "observers" in node2) {
      writeSignal(node2, nextValue);
    } else
      node2.value = nextValue;
    node2.updatedAt = time;
  }
}
function createComputation(fn, init, pure, state = STALE, options) {
  const c = {
    fn,
    state,
    updatedAt: null,
    owned: null,
    sources: null,
    sourceSlots: null,
    cleanups: null,
    value: init,
    owner: Owner,
    context: null,
    pure
  };
  if (Owner === null)
    ;
  else if (Owner !== UNOWNED) {
    {
      if (!Owner.owned)
        Owner.owned = [c];
      else
        Owner.owned.push(c);
    }
  }
  return c;
}
function runTop(node2) {
  const runningTransition = Transition;
  if (node2.state === 0 || runningTransition)
    return;
  if (node2.state === PENDING || runningTransition)
    return lookUpstream(node2);
  if (node2.suspense && untrack$1(node2.suspense.inFallback))
    return node2.suspense.effects.push(node2);
  const ancestors = [node2];
  while ((node2 = node2.owner) && (!node2.updatedAt || node2.updatedAt < ExecCount)) {
    if (node2.state || runningTransition)
      ancestors.push(node2);
  }
  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {
    node2 = ancestors[i2];
    if (node2.state === STALE || runningTransition) {
      updateComputation(node2);
    } else if (node2.state === PENDING || runningTransition) {
      const updates = Updates;
      Updates = null;
      runUpdates(() => lookUpstream(node2, ancestors[0]), false);
      Updates = updates;
    }
  }
}
function runUpdates(fn, init) {
  if (Updates)
    return fn();
  let wait = false;
  if (!init)
    Updates = [];
  if (Effects)
    wait = true;
  else
    Effects = [];
  ExecCount++;
  try {
    const res = fn();
    completeUpdates(wait);
    return res;
  } catch (err) {
    if (!wait)
      Effects = null;
    Updates = null;
    handleError(err);
  }
}
function completeUpdates(wait) {
  if (Updates) {
    runQueue(Updates);
    Updates = null;
  }
  if (wait)
    return;
  const e = Effects;
  Effects = null;
  if (e.length)
    runUpdates(() => runEffects(e), false);
}
function runQueue(queue) {
  for (let i2 = 0; i2 < queue.length; i2++)
    runTop(queue[i2]);
}
function runUserEffects(queue) {
  let i2, userLength = 0;
  for (i2 = 0; i2 < queue.length; i2++) {
    const e = queue[i2];
    if (!e.user)
      runTop(e);
    else
      queue[userLength++] = e;
  }
  for (i2 = 0; i2 < userLength; i2++)
    runTop(queue[i2]);
}
function lookUpstream(node2, ignore) {
  const runningTransition = Transition;
  node2.state = 0;
  for (let i2 = 0; i2 < node2.sources.length; i2 += 1) {
    const source = node2.sources[i2];
    if (source.sources) {
      if (source.state === STALE || runningTransition) {
        if (source !== ignore && (!source.updatedAt || source.updatedAt < ExecCount))
          runTop(source);
      } else if (source.state === PENDING || runningTransition)
        lookUpstream(source, ignore);
    }
  }
}
function markDownstream(node2) {
  const runningTransition = Transition;
  for (let i2 = 0; i2 < node2.observers.length; i2 += 1) {
    const o = node2.observers[i2];
    if (!o.state || runningTransition) {
      o.state = PENDING;
      if (o.pure)
        Updates.push(o);
      else
        Effects.push(o);
      o.observers && markDownstream(o);
    }
  }
}
function cleanNode(node2) {
  let i2;
  if (node2.sources) {
    while (node2.sources.length) {
      const source = node2.sources.pop(), index = node2.sourceSlots.pop(), obs = source.observers;
      if (obs && obs.length) {
        const n = obs.pop(), s = source.observerSlots.pop();
        if (index < obs.length) {
          n.sourceSlots[s] = index;
          obs[index] = n;
          source.observerSlots[index] = s;
        }
      }
    }
  }
  if (node2.owned) {
    for (i2 = 0; i2 < node2.owned.length; i2++)
      cleanNode(node2.owned[i2]);
    node2.owned = null;
  }
  if (node2.cleanups) {
    for (i2 = 0; i2 < node2.cleanups.length; i2++)
      node2.cleanups[i2]();
    node2.cleanups = null;
  }
  node2.state = 0;
  node2.context = null;
}
function castError(err) {
  if (err instanceof Error || typeof err === "string")
    return err;
  return new Error("Unknown error");
}
function handleError(err) {
  err = castError(err);
  throw err;
}
const createSignal = createSignal$1;
const createMemo = createMemo$1;
const createRoot = createRoot$1;
const createEffect = createEffect$1;
const batch = batch$1;
const getListener = getListener$1;
const onCleanup = onCleanup$1;
const untrack = untrack$1;
var triggerOptions = { equals: false };
var triggerCacheOptions = triggerOptions;
var TriggerCache = class {
  #map;
  constructor(mapConstructor = Map) {
    this.#map = new mapConstructor();
  }
  dirty(key) {
    var _a;
    (_a = this.#map.get(key)) == null ? void 0 : _a.$$();
  }
  track(key) {
    if (!getListener())
      return;
    let trigger = this.#map.get(key);
    if (!trigger) {
      const [$, $$] = createSignal(void 0, triggerCacheOptions);
      this.#map.set(key, trigger = { $, $$, n: 1 });
    } else
      trigger.n++;
    onCleanup(() => {
      if (trigger.n-- === 1)
        queueMicrotask(() => trigger.n === 0 && this.#map.delete(key));
    });
    trigger.$();
  }
};
var $KEYS = Symbol("track-keys");
var ReactiveMap = class extends Map {
  #keyTriggers = new TriggerCache();
  #valueTriggers = new TriggerCache();
  constructor(initial) {
    super();
    if (initial)
      for (const v of initial)
        super.set(v[0], v[1]);
  }
  // reads
  has(key) {
    this.#keyTriggers.track(key);
    return super.has(key);
  }
  get(key) {
    this.#valueTriggers.track(key);
    return super.get(key);
  }
  get size() {
    this.#keyTriggers.track($KEYS);
    return super.size;
  }
  keys() {
    this.#keyTriggers.track($KEYS);
    return super.keys();
  }
  values() {
    this.#keyTriggers.track($KEYS);
    for (const v of super.keys())
      this.#valueTriggers.track(v);
    return super.values();
  }
  entries() {
    this.#keyTriggers.track($KEYS);
    for (const v of super.keys())
      this.#valueTriggers.track(v);
    return super.entries();
  }
  // writes
  set(key, value2) {
    batch(() => {
      if (super.has(key)) {
        if (super.get(key) === value2)
          return;
      } else {
        this.#keyTriggers.dirty(key);
        this.#keyTriggers.dirty($KEYS);
      }
      this.#valueTriggers.dirty(key);
      super.set(key, value2);
    });
    return this;
  }
  delete(key) {
    const r = super.delete(key);
    if (r) {
      batch(() => {
        this.#keyTriggers.dirty(key);
        this.#keyTriggers.dirty($KEYS);
        this.#valueTriggers.dirty(key);
      });
    }
    return r;
  }
  clear() {
    if (super.size) {
      batch(() => {
        for (const v of super.keys()) {
          this.#keyTriggers.dirty(v);
          this.#valueTriggers.dirty(v);
        }
        super.clear();
        this.#keyTriggers.dirty($KEYS);
      });
    }
  }
  // callback
  forEach(callbackfn) {
    this.#keyTriggers.track($KEYS);
    super.forEach((value2, key) => callbackfn(value2, key, this));
  }
  [Symbol.iterator]() {
    return this.entries();
  }
};
const createNodeishFsWithWatcher = (args) => {
  const pathList = /* @__PURE__ */ new Set();
  const abortControllers = /* @__PURE__ */ new Set();
  const stopWatching = () => {
    for (const ac of abortControllers) {
      ac.abort();
      abortControllers.delete(ac);
    }
  };
  const makeWatcher = async (path) => {
    try {
      const ac = new AbortController();
      abortControllers.add(ac);
      const watcher = args.nodeishFs.watch(path, {
        signal: ac.signal,
        recursive: true,
        persistent: false
      });
      if (watcher) {
        for await (const event of watcher) {
          args.onChange();
        }
      }
    } catch (err) {
      if (err.name === "AbortError")
        return;
      else if (err.code === "ENOENT")
        return;
      throw err;
    }
  };
  const watched = (fn) => {
    return (path, ...rest) => {
      if (!pathList.has(path)) {
        makeWatcher(path);
        pathList.add(path);
      }
      return fn(path, ...rest);
    };
  };
  return {
    ...args.nodeishFs,
    /**
     * Reads the file and automatically adds it to the list of watched files.
     * Any changes to the file will trigger a message update.
     */
    // @ts-expect-error
    readFile: watched(args.nodeishFs.readFile),
    /**
     * Reads the directory and automatically adds it to the list of watched files.
     * Any changes to the directory will trigger a message update.
     */
    readdir: watched(args.nodeishFs.readdir),
    stopWatching
  };
};
function normalizeMessage(message) {
  const messageWithSortedKeys = {};
  for (const key of Object.keys(message).sort()) {
    messageWithSortedKeys[key] = message[key];
  }
  messageWithSortedKeys["variants"] = messageWithSortedKeys["variants"].sort((variantA, variantB) => {
    const languageComparison = variantA.languageTag.localeCompare(variantB.languageTag);
    if (languageComparison === 0) {
      return variantA.match.join("-").localeCompare(variantB.match.join("-"));
    }
    return languageComparison;
  }).map((variant) => {
    const variantWithSortedKeys = {};
    for (const variantKey of Object.keys(variant).sort()) {
      if (variantKey === "pattern") {
        variantWithSortedKeys[variantKey] = variant["pattern"].map((token) => {
          const tokenWithSortedKey = {};
          for (const tokenKey of Object.keys(token).sort()) {
            tokenWithSortedKey[tokenKey] = token[tokenKey];
          }
          return tokenWithSortedKey;
        });
      } else {
        variantWithSortedKeys[variantKey] = variant[variantKey];
      }
    }
    return variantWithSortedKeys;
  });
  return messageWithSortedKeys;
}
function stringifyMessage(message) {
  return JSON.stringify(normalizeMessage(message), void 0, 4);
}
function normalizePath(path, { trailingSlash, leadingSlash } = {}) {
  path = path.replace(/^\.\//, "/");
  if (path === "\\" || path === "" || path === "/" || path === "." || path === "//.") {
    return "/";
  }
  if (path.length <= 1) {
    return path;
  }
  const hadTrailingSlash = path[path.length - 1] === "/" || path[path.length - 1] === "\\";
  const addleadingSlash = leadingSlash === "always" || path[0] === "/" || path[0] === "\\";
  const segs = path.split(/[/\\]+/);
  const stack = [];
  for (const seg of segs) {
    if (seg === "..") {
      stack.pop();
    } else if (seg && seg !== ".") {
      stack.push(seg);
    }
  }
  if (trailingSlash !== "strip" && (hadTrailingSlash || trailingSlash === "always")) {
    stack.push("");
  }
  return addleadingSlash ? "/" + stack.join("/") : stack.join("/");
}
function getDirname(path) {
  const dirname = path.split("/").filter((x) => x).slice(0, -1).join("/");
  return normalizePath(dirname, { leadingSlash: "always", trailingSlash: "always" }) ?? path;
}
function getBasename(path) {
  return path.split("/").filter((x) => x).at(-1) ?? "";
}
const debug$6 = _debug("sdk:fileLock");
const maxRetries = 10;
const nProbes = 50;
const probeInterval = 100;
async function acquireFileLock(fs, lockDirPath, lockOrigin, tryCount = 0) {
  if (tryCount > maxRetries) {
    throw new Error(`${lockOrigin} exceeded maximum retries (${maxRetries}) to acquire lockfile ${tryCount}`);
  }
  try {
    debug$6(lockOrigin + " tries to acquire a lockfile Retry Nr.: " + tryCount);
    await fs.mkdir(lockDirPath);
    const stats = await fs.stat(lockDirPath);
    debug$6(lockOrigin + " acquired a lockfile Retry Nr.: " + tryCount);
    return stats.mtimeMs;
  } catch (error) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }
  let currentLockTime;
  try {
    const stats = await fs.stat(lockDirPath);
    currentLockTime = stats.mtimeMs;
  } catch (fstatError) {
    if (fstatError.code === "ENOENT") {
      debug$6(lockOrigin + " tryCount++ lock file seems to be gone :) - lets try again " + tryCount);
      return acquireFileLock(fs, lockDirPath, lockOrigin, tryCount + 1);
    }
    throw fstatError;
  }
  debug$6(lockOrigin + " tries to acquire a lockfile  - lock currently in use... starting probe phase " + tryCount);
  return new Promise((resolve, reject) => {
    let probeCounts = 0;
    const scheduleProbationTimeout = () => {
      setTimeout(async () => {
        probeCounts += 1;
        let lockFileStats = void 0;
        try {
          debug$6(lockOrigin + " tries to acquire a lockfile - check if the lock is free now " + tryCount);
          lockFileStats = await fs.stat(lockDirPath);
        } catch (fstatError) {
          if (fstatError.code === "ENOENT") {
            debug$6(lockOrigin + " tryCount++ in Promise - tries to acquire a lockfile - lock file seems to be free now - try to acquire " + tryCount);
            const lock = acquireFileLock(fs, lockDirPath, lockOrigin, tryCount + 1);
            return resolve(lock);
          }
          return reject(fstatError);
        }
        if (lockFileStats.mtimeMs === currentLockTime) {
          if (probeCounts >= nProbes) {
            debug$6(lockOrigin + " tries to acquire a lockfile  - lock not free - but stale lets drop it" + tryCount);
            try {
              await fs.rmdir(lockDirPath);
            } catch (rmLockError) {
              if (rmLockError.code === "ENOENT")
                ;
              return reject(rmLockError);
            }
            try {
              debug$6(lockOrigin + " tryCount++ same locker - try to acquire again after removing stale lock " + tryCount);
              const lock = await acquireFileLock(fs, lockDirPath, lockOrigin, tryCount + 1);
              return resolve(lock);
            } catch (lockAquireException) {
              return reject(lockAquireException);
            }
          } else {
            return scheduleProbationTimeout();
          }
        } else {
          try {
            debug$6(lockOrigin + " tryCount++ different locker - try to acquire again " + tryCount);
            const lock = await acquireFileLock(fs, lockDirPath, lockOrigin, tryCount + 1);
            return resolve(lock);
          } catch (error) {
            return reject(error);
          }
        }
      }, probeInterval);
    };
    scheduleProbationTimeout();
  });
}
const debug$5 = _debug("sdk:fileLock");
async function releaseLock(fs, lockDirPath, lockOrigin, lockTime) {
  debug$5(lockOrigin + " releasing the lock ");
  try {
    const stats = await fs.stat(lockDirPath);
    if (stats.mtimeMs === lockTime) {
      await fs.rmdir(lockDirPath);
    }
  } catch (statError) {
    debug$5(lockOrigin + " couldn't release the lock");
    if (statError.code === "ENOENT") {
      debug$5(lockOrigin + " WARNING - the lock was released by a different process");
      return;
    }
    debug$5(statError);
    throw statError;
  }
}
var murmurHash3js = { exports: {} };
(function(module, exports) {
  (function(root, undefined$1) {
    var library = {
      "version": "3.0.1",
      "x86": {},
      "x64": {}
    };
    function _x86Multiply(m, n) {
      return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m, n) {
      return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
      h ^= h >>> 16;
      h = _x86Multiply(h, 2246822507);
      h ^= h >>> 13;
      h = _x86Multiply(h, 3266489909);
      h ^= h >>> 16;
      return h;
    }
    function _x64Add(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m, n) {
      n %= 64;
      if (n === 32) {
        return [m[1], m[0]];
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m, n) {
      n %= 64;
      if (n === 0) {
        return m;
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
      } else {
        return [m[1] << n - 32, 0];
      }
    }
    function _x64Xor(m, n) {
      return [m[0] ^ n[0], m[1] ^ n[1]];
    }
    function _x64Fmix(h) {
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [4283543511, 3981806797]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [3301882366, 444984403]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      return h;
    }
    library.x86.hash32 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 4;
      var bytes = key.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 4) {
        k1 = key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= (key.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          k1 ^= (key.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          k1 ^= key.charCodeAt(i2) & 255;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24;
        k2 = key.charCodeAt(i2 + 4) & 255 | (key.charCodeAt(i2 + 5) & 255) << 8 | (key.charCodeAt(i2 + 6) & 255) << 16 | (key.charCodeAt(i2 + 7) & 255) << 24;
        k3 = key.charCodeAt(i2 + 8) & 255 | (key.charCodeAt(i2 + 9) & 255) << 8 | (key.charCodeAt(i2 + 10) & 255) << 16 | (key.charCodeAt(i2 + 11) & 255) << 24;
        k4 = key.charCodeAt(i2 + 12) & 255 | (key.charCodeAt(i2 + 13) & 255) << 8 | (key.charCodeAt(i2 + 14) & 255) << 16 | (key.charCodeAt(i2 + 15) & 255) << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= key.charCodeAt(i2 + 14) << 16;
        case 14:
          k4 ^= key.charCodeAt(i2 + 13) << 8;
        case 13:
          k4 ^= key.charCodeAt(i2 + 12);
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= key.charCodeAt(i2 + 11) << 24;
        case 11:
          k3 ^= key.charCodeAt(i2 + 10) << 16;
        case 10:
          k3 ^= key.charCodeAt(i2 + 9) << 8;
        case 9:
          k3 ^= key.charCodeAt(i2 + 8);
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= key.charCodeAt(i2 + 7) << 24;
        case 7:
          k2 ^= key.charCodeAt(i2 + 6) << 16;
        case 6:
          k2 ^= key.charCodeAt(i2 + 5) << 8;
        case 5:
          k2 ^= key.charCodeAt(i2 + 4);
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= key.charCodeAt(i2 + 3) << 24;
        case 3:
          k1 ^= key.charCodeAt(i2 + 2) << 16;
        case 2:
          k1 ^= key.charCodeAt(i2 + 1) << 8;
        case 1:
          k1 ^= key.charCodeAt(i2);
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= key.length;
      h2 ^= key.length;
      h3 ^= key.length;
      h4 ^= key.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(key, seed) {
      key = key || "";
      seed = seed || 0;
      var remainder = key.length % 16;
      var bytes = key.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i2 = 0; i2 < bytes; i2 = i2 + 16) {
        k1 = [key.charCodeAt(i2 + 4) & 255 | (key.charCodeAt(i2 + 5) & 255) << 8 | (key.charCodeAt(i2 + 6) & 255) << 16 | (key.charCodeAt(i2 + 7) & 255) << 24, key.charCodeAt(i2) & 255 | (key.charCodeAt(i2 + 1) & 255) << 8 | (key.charCodeAt(i2 + 2) & 255) << 16 | (key.charCodeAt(i2 + 3) & 255) << 24];
        k2 = [key.charCodeAt(i2 + 12) & 255 | (key.charCodeAt(i2 + 13) & 255) << 8 | (key.charCodeAt(i2 + 14) & 255) << 16 | (key.charCodeAt(i2 + 15) & 255) << 24, key.charCodeAt(i2 + 8) & 255 | (key.charCodeAt(i2 + 9) & 255) << 8 | (key.charCodeAt(i2 + 10) & 255) << 16 | (key.charCodeAt(i2 + 11) & 255) << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 14)], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 13)], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 12)], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 11)], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 10)], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, key.charCodeAt(i2 + 9)], 8));
        case 9:
          k2 = _x64Xor(k2, [0, key.charCodeAt(i2 + 8)]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 7)], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 6)], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 5)], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 4)], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 3)], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 2)], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, key.charCodeAt(i2 + 1)], 8));
        case 1:
          k1 = _x64Xor(k1, [0, key.charCodeAt(i2)]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, key.length]);
      h2 = _x64Xor(h2, [0, key.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    {
      if (module.exports) {
        exports = module.exports = library;
      }
      exports.murmurHash3 = library;
    }
  })();
})(murmurHash3js, murmurHash3js.exports);
var murmurHash3jsExports = murmurHash3js.exports;
var murmurhash3js = murmurHash3jsExports;
const murmurhash3 = /* @__PURE__ */ getDefaultExportFromCjs(murmurhash3js);
const animals = [
  "albatross",
  "alligator",
  "alpaca",
  "anaconda",
  "angelfish",
  "ant",
  "anteater",
  "antelope",
  "ape",
  "baboon",
  "badger",
  "barbel",
  "bat",
  "bear",
  "beaver",
  "bee",
  "beetle",
  "bird",
  "bison",
  "blackbird",
  "boar",
  "bobcat",
  "bulldog",
  "bullock",
  "bumblebee",
  "butterfly",
  "buzzard",
  "camel",
  "canary",
  "capybara",
  "carp",
  "cat",
  "cheetah",
  "chicken",
  "chipmunk",
  "clownfish",
  "cobra",
  "cockroach",
  "cod",
  "cougar",
  "cow",
  "cowfish",
  "coyote",
  "crab",
  "crocodile",
  "crossbill",
  "crow",
  "cuckoo",
  "dachshund",
  "deer",
  "dingo",
  "dog",
  "dolphin",
  "donkey",
  "dove",
  "dragonfly",
  "duck",
  "eagle",
  "earthworm",
  "eel",
  "elephant",
  "elk",
  "emu",
  "falcon",
  "felix",
  "finch",
  "fireant",
  "firefox",
  "fish",
  "flamingo",
  "flea",
  "florian",
  "fly",
  "fox",
  "frog",
  "gadfly",
  "gazelle",
  "gecko",
  "gibbon",
  "giraffe",
  "goat",
  "goldfish",
  "goose",
  "gopher",
  "gorilla",
  "grebe",
  "grizzly",
  "gull",
  "guppy",
  "haddock",
  "halibut",
  "hamster",
  "hare",
  "hawk",
  "hedgehog",
  "herring",
  "hornet",
  "horse",
  "hound",
  "husky",
  "hyena",
  "ibex",
  "iguana",
  "impala",
  "insect",
  "jackal",
  "jackdaw",
  "jaguar",
  "jan",
  "jannes",
  "javelina",
  "jay",
  "jellyfish",
  "jurgen",
  "kangaroo",
  "kestrel",
  "kitten",
  "koala",
  "kudu",
  "ladybug",
  "lamb",
  "lark",
  "larva",
  "lemming",
  "lemur",
  "leopard",
  "liger",
  "lion",
  "lionfish",
  "lizard",
  "llama",
  "lobster",
  "loris",
  "lynx",
  "macaw",
  "maggot",
  "mallard",
  "mammoth",
  "manatee",
  "mantis",
  "mare",
  "marlin",
  "marmot",
  "marten",
  "martin",
  "mayfly",
  "meerkat",
  "midge",
  "millipede",
  "mink",
  "mole",
  "mongoose",
  "monkey",
  "moose",
  "moth",
  "mouse",
  "mule",
  "myna",
  "newt",
  "niklas",
  "nils",
  "nuthatch",
  "ocelot",
  "octopus",
  "okapi",
  "opossum",
  "orangutan",
  "oryx",
  "osprey",
  "ostrich",
  "otter",
  "owl",
  "ox",
  "panda",
  "panther",
  "parakeet",
  "parrot",
  "peacock",
  "pelican",
  "penguin",
  "pig",
  "pigeon",
  "piranha",
  "platypus",
  "polecat",
  "pony",
  "poodle",
  "porpoise",
  "puffin",
  "pug",
  "puma",
  "quail",
  "rabbit",
  "racoon",
  "rat",
  "raven",
  "ray",
  "reindeer",
  "robin",
  "rook",
  "rooster",
  "salmon",
  "samuel",
  "sawfish",
  "scallop",
  "seahorse",
  "seal",
  "shad",
  "shark",
  "sheep",
  "shell",
  "shrike",
  "shrimp",
  "skate",
  "skunk",
  "sloth",
  "slug",
  "snail",
  "snake",
  "sparrow",
  "spider",
  "squid",
  "squirrel",
  "starfish",
  "stingray",
  "stork",
  "swallow",
  "swan",
  "tadpole",
  "tapir",
  "termite",
  "tern",
  "thrush",
  "tiger",
  "toad",
  "tortoise",
  "toucan",
  "trout",
  "tuna",
  "turkey",
  "turtle",
  "vole",
  "vulture",
  "wallaby",
  "walrus",
  "warbler",
  "warthog",
  "wasp",
  "weasel",
  "whale",
  "wolf",
  "wombat",
  "worm",
  "wren",
  "yak",
  "zebra"
];
const adjectives = [
  "acidic",
  "active",
  "actual",
  "agent",
  "ago",
  "alert",
  "alive",
  "aloof",
  "antsy",
  "any",
  "aqua",
  "arable",
  "awake",
  "aware",
  "away",
  "awful",
  "bad",
  "bald",
  "basic",
  "best",
  "big",
  "bland",
  "blue",
  "bold",
  "born",
  "brave",
  "brief",
  "bright",
  "broad",
  "busy",
  "calm",
  "candid",
  "careful",
  "caring",
  "chunky",
  "civil",
  "clean",
  "clear",
  "close",
  "cool",
  "cozy",
  "crazy",
  "crisp",
  "cuddly",
  "curly",
  "cute",
  "dark",
  "day",
  "deft",
  "direct",
  "dirty",
  "dizzy",
  "drab",
  "dry",
  "due",
  "dull",
  "each",
  "early",
  "east",
  "elegant",
  "empty",
  "equal",
  "even",
  "every",
  "extra",
  "factual",
  "fair",
  "fancy",
  "few",
  "fine",
  "fit",
  "flaky",
  "flat",
  "fluffy",
  "formal",
  "frail",
  "free",
  "fresh",
  "front",
  "full",
  "fun",
  "funny",
  "fuzzy",
  "game",
  "gaudy",
  "giant",
  "glad",
  "good",
  "grand",
  "grassy",
  "gray",
  "great",
  "green",
  "gross",
  "happy",
  "heavy",
  "helpful",
  "heroic",
  "home",
  "honest",
  "hour",
  "house",
  "icy",
  "ideal",
  "inclusive",
  "inner",
  "jolly",
  "jumpy",
  "just",
  "keen",
  "key",
  "kind",
  "knotty",
  "known",
  "large",
  "last",
  "late",
  "lazy",
  "least",
  "left",
  "legal",
  "less",
  "level",
  "light",
  "lime",
  "livid",
  "lofty",
  "long",
  "loose",
  "lost",
  "loud",
  "loved",
  "low",
  "lower",
  "lucky",
  "mad",
  "main",
  "major",
  "male",
  "many",
  "maroon",
  "mealy",
  "mean",
  "mellow",
  "merry",
  "mild",
  "minor",
  "misty",
  "moving",
  "muddy",
  "mushy",
  "neat",
  "new",
  "next",
  "nice",
  "nimble",
  "noble",
  "noisy",
  "north",
  "novel",
  "odd",
  "ok",
  "only",
  "orange",
  "ornate",
  "patchy",
  "patient",
  "petty",
  "pink",
  "plain",
  "plane",
  "polite",
  "pretty",
  "proof",
  "proud",
  "quaint",
  "quick",
  "quiet",
  "raw",
  "real",
  "red",
  "round",
  "royal",
  "sad",
  "safe",
  "salty",
  "same",
  "sea",
  "seemly",
  "sharp",
  "short",
  "shy",
  "silly",
  "simple",
  "sleek",
  "slimy",
  "slow",
  "small",
  "smart",
  "smug",
  "soft",
  "solid",
  "sound",
  "sour",
  "spare",
  "spicy",
  "spry",
  "stale",
  "steep",
  "still",
  "stock",
  "stout",
  "strong",
  "suave",
  "such",
  "sunny",
  "super",
  "sweet",
  "swift",
  "tame",
  "tangy",
  "tasty",
  "teal",
  "teary",
  "tense",
  "that",
  "these",
  "this",
  "tidy",
  "tiny",
  "tired",
  "top",
  "topical",
  "tough",
  "trick",
  "trite",
  "true",
  "upper",
  "vexed",
  "vivid",
  "wacky",
  "warm",
  "watery",
  "weak",
  "weary",
  "weird",
  "white",
  "whole",
  "wide",
  "wild",
  "wise",
  "witty",
  "yummy",
  "zany",
  "zesty",
  "zippy"
];
const adverbs = [
  "ablaze",
  "about",
  "above",
  "abroad",
  "across",
  "adrift",
  "afloat",
  "after",
  "again",
  "ahead",
  "alike",
  "all",
  "almost",
  "alone",
  "along",
  "aloud",
  "always",
  "amazing",
  "anxious",
  "anywhere",
  "apart",
  "around",
  "arrogant",
  "aside",
  "asleep",
  "awkward",
  "back",
  "bashful",
  "beautiful",
  "before",
  "behind",
  "below",
  "beside",
  "besides",
  "beyond",
  "bitter",
  "bleak",
  "blissful",
  "boldly",
  "bravely",
  "briefly",
  "brightly",
  "brisk",
  "busily",
  "calmly",
  "carefully",
  "careless",
  "cautious",
  "certain",
  "cheerful",
  "clearly",
  "clever",
  "closely",
  "closer",
  "colorful",
  "common",
  "correct",
  "cross",
  "cruel",
  "curious",
  "daily",
  "dainty",
  "daring",
  "dear",
  "desperate",
  "diligent",
  "doubtful",
  "doubtless",
  "down",
  "downwards",
  "dreamily",
  "eager",
  "easily",
  "either",
  "elegantly",
  "else",
  "elsewhere",
  "enormous",
  "enough",
  "ever",
  "famous",
  "far",
  "fast",
  "fervent",
  "fierce",
  "fondly",
  "foolish",
  "forever",
  "forth",
  "fortunate",
  "forward",
  "frank",
  "freely",
  "frequent",
  "fully",
  "general",
  "generous",
  "gladly",
  "graceful",
  "grateful",
  "gratis",
  "half",
  "happily",
  "hard",
  "harsh",
  "hearty",
  "helpless",
  "here",
  "highly",
  "hitherto",
  "how",
  "however",
  "hurried",
  "immediate",
  "in",
  "indeed",
  "inland",
  "innocent",
  "inside",
  "instant",
  "intense",
  "inward",
  "jealous",
  "jovial",
  "joyful",
  "jubilant",
  "keenly",
  "kindly",
  "knowing",
  "lately",
  "lazily",
  "lightly",
  "likely",
  "little",
  "live",
  "loftily",
  "longing",
  "loosely",
  "loudly",
  "loving",
  "loyal",
  "luckily",
  "madly",
  "maybe",
  "meanwhile",
  "mocking",
  "monthly",
  "moreover",
  "much",
  "near",
  "neatly",
  "neither",
  "nervous",
  "never",
  "noisily",
  "normal",
  "not",
  "now",
  "nowadays",
  "nowhere",
  "oddly",
  "off",
  "official",
  "often",
  "on",
  "once",
  "open",
  "openly",
  "opposite",
  "otherwise",
  "out",
  "outside",
  "over",
  "overall",
  "overhead",
  "overnight",
  "overseas",
  "parallel",
  "partial",
  "past",
  "patiently",
  "perfect",
  "perhaps",
  "physical",
  "playful",
  "politely",
  "potential",
  "powerful",
  "presto",
  "profound",
  "prompt",
  "proper",
  "proudly",
  "punctual",
  "quickly",
  "quizzical",
  "rare",
  "ravenous",
  "ready",
  "really",
  "reckless",
  "regular",
  "repeated",
  "restful",
  "rightful",
  "rigid",
  "rude",
  "sadly",
  "safely",
  "scarce",
  "scary",
  "searching",
  "seeming",
  "seldom",
  "selfish",
  "separate",
  "serious",
  "shaky",
  "sheepish",
  "silent",
  "sleepy",
  "smooth",
  "softly",
  "solemn",
  "solidly",
  "sometimes",
  "speedy",
  "stealthy",
  "stern",
  "strict",
  "stubborn",
  "sudden",
  "supposed",
  "sweetly",
  "swiftly",
  "tender",
  "tensely",
  "thankful",
  "tight",
  "too",
  "twice",
  "under",
  "untrue",
  "uphill",
  "upward",
  "vaguely",
  "vainly",
  "vastly",
  "warmly",
  "wearily",
  "weekly",
  "well",
  "wisely",
  "within",
  "wrongly",
  "yonder"
];
const verbs = [
  "absorb",
  "accept",
  "achieve",
  "adapt",
  "adore",
  "advise",
  "affirm",
  "agree",
  "aid",
  "aim",
  "amaze",
  "amuse",
  "animate",
  "approve",
  "arise",
  "arrive",
  "ascend",
  "ask",
  "aspire",
  "assure",
  "attend",
  "bake",
  "bask",
  "beam",
  "believe",
  "belong",
  "bend",
  "blend",
  "bless",
  "blink",
  "bloom",
  "boil",
  "boost",
  "borrow",
  "breathe",
  "bubble",
  "build",
  "bump",
  "burn",
  "buy",
  "buzz",
  "care",
  "catch",
  "charm",
  "cheer",
  "cherish",
  "chop",
  "clap",
  "clasp",
  "climb",
  "clip",
  "coax",
  "comfort",
  "commend",
  "compose",
  "conquer",
  "cook",
  "create",
  "cry",
  "cuddle",
  "cure",
  "cut",
  "dance",
  "dare",
  "dart",
  "dash",
  "dazzle",
  "delight",
  "devour",
  "dial",
  "dig",
  "dine",
  "dream",
  "drip",
  "drop",
  "drum",
  "dust",
  "earn",
  "edit",
  "embrace",
  "emerge",
  "empower",
  "enchant",
  "endure",
  "engage",
  "enjoy",
  "enrich",
  "evoke",
  "exhale",
  "expand",
  "explore",
  "express",
  "fade",
  "fall",
  "favor",
  "fear",
  "feast",
  "feel",
  "fetch",
  "file",
  "find",
  "flip",
  "flop",
  "flow",
  "fold",
  "fond",
  "forgive",
  "foster",
  "fry",
  "fulfill",
  "gasp",
  "gaze",
  "gleam",
  "glow",
  "grace",
  "grasp",
  "greet",
  "grin",
  "grip",
  "grow",
  "gulp",
  "hack",
  "harbor",
  "heal",
  "heart",
  "hike",
  "hint",
  "honor",
  "hope",
  "hug",
  "hunt",
  "hurl",
  "hush",
  "imagine",
  "inspire",
  "intend",
  "jest",
  "jolt",
  "jump",
  "kick",
  "kiss",
  "laugh",
  "launch",
  "lead",
  "leap",
  "learn",
  "lend",
  "lift",
  "link",
  "list",
  "lock",
  "loop",
  "love",
  "mend",
  "mix",
  "mop",
  "nail",
  "nourish",
  "nudge",
  "nurture",
  "offer",
  "pat",
  "pause",
  "pave",
  "peek",
  "peel",
  "persist",
  "pet",
  "pick",
  "pinch",
  "play",
  "pop",
  "pout",
  "praise",
  "pray",
  "pride",
  "promise",
  "propel",
  "prosper",
  "pull",
  "push",
  "quell",
  "quiz",
  "race",
  "radiate",
  "read",
  "reap",
  "relish",
  "renew",
  "reside",
  "rest",
  "revive",
  "ripple",
  "rise",
  "roam",
  "roar",
  "rush",
  "sail",
  "savor",
  "scold",
  "scoop",
  "seek",
  "sew",
  "shine",
  "sing",
  "skip",
  "slide",
  "slurp",
  "smile",
  "snap",
  "snip",
  "soar",
  "spark",
  "spin",
  "splash",
  "sprout",
  "spur",
  "stab",
  "startle",
  "stir",
  "stop",
  "strive",
  "succeed",
  "support",
  "surge",
  "sway",
  "swim",
  "talk",
  "tap",
  "taste",
  "tear",
  "tend",
  "thrive",
  "tickle",
  "transform",
  "treasure",
  "treat",
  "trim",
  "trip",
  "trust",
  "twirl",
  "twist",
  "type",
  "urge",
  "value",
  "vent",
  "view",
  "walk",
  "wave",
  "win",
  "wish",
  "work",
  "yell",
  "zap",
  "zip",
  "zoom"
];
function humanIdHash(value2, offset = 0) {
  const seed = 42;
  const hash32 = murmurhash3.x86.hash32(value2, seed);
  const hash32WithOffset = hash32 + offset >>> 0;
  const part1 = hash32WithOffset >>> 24 & 255;
  const part2 = hash32WithOffset >>> 16 & 255;
  const part3 = hash32WithOffset >>> 8 & 255;
  const part4 = hash32WithOffset & 255;
  return `${adjectives[part1]}_${animals[part2]}_${verbs[part3]}_${adverbs[part4]}`;
}
const debug$4 = _debug("sdk:messages");
function createMessagesQuery({ projectPath, nodeishFs, settings, resolvedModules, onInitialMessageLoadResult, onLoadMessageResult, onSaveMessageResult }) {
  const index = new ReactiveMap();
  let loaded = false;
  const messageLockDirPath = projectPath + "/messagelock";
  let delegate = void 0;
  const setDelegate = (newDelegate, onLoad) => {
    delegate = newDelegate;
    if (newDelegate && loaded && onLoad) {
      newDelegate.onLoaded([...index.values()]);
    }
  };
  const defaultAliasIndex = new ReactiveMap();
  const messageStates = {
    messageDirtyFlags: {},
    messageLoadHash: {},
    isSaving: false,
    currentSaveMessagesViaPlugin: void 0,
    sheduledSaveMessages: void 0,
    isLoading: false,
    sheduledLoadMessagesViaPlugin: void 0
  };
  createEffect(() => {
    var _a;
    index.clear();
    defaultAliasIndex.clear();
    loaded = false;
    const _settings = settings();
    if (!_settings)
      return;
    const resolvedPluginApi = (_a = resolvedModules()) == null ? void 0 : _a.resolvedPluginApi;
    if (!resolvedPluginApi)
      return;
    const fsWithWatcher = createNodeishFsWithWatcher({
      nodeishFs,
      // this message is called whenever a file changes that was read earlier by this filesystem
      // - the plugin loads messages -> reads the file messages.json -> start watching on messages.json -> updateMessages
      onChange: () => {
        loadMessagesViaPlugin(
          fsWithWatcher,
          messageLockDirPath,
          messageStates,
          index,
          defaultAliasIndex,
          delegate,
          _settings,
          // NOTE we bang here - we don't expect the settings to become null during the livetime of a project
          resolvedPluginApi
        ).catch((e) => {
          onLoadMessageResult(e);
        }).then(() => {
          onLoadMessageResult();
        });
      }
    });
    onCleanup(() => {
      fsWithWatcher.stopWatching();
      delegate == null ? void 0 : delegate.onCleanup();
    });
    if (!resolvedPluginApi.loadMessages) {
      onInitialMessageLoadResult(new Error("no loadMessages in resolved Modules found"));
      return;
    }
    loadMessagesViaPlugin(
      fsWithWatcher,
      messageLockDirPath,
      messageStates,
      index,
      defaultAliasIndex,
      void 0,
      _settings,
      // NOTE we bang here - we don't expect the settings to become null during the livetime of a project
      resolvedPluginApi
    ).catch((e) => {
      onInitialMessageLoadResult(new PluginLoadMessagesError({ cause: e }));
    }).then(() => {
      onInitialMessageLoadResult();
      delegate == null ? void 0 : delegate.onLoaded([...index.values()]);
      loaded = true;
    });
  });
  const get = (args) => index.get(args.where.id);
  const getByDefaultAlias = (alias) => defaultAliasIndex.get(alias);
  const scheduleSave = function() {
    var _a;
    const _settings = settings();
    if (!_settings)
      return;
    const resolvedPluginApi = (_a = resolvedModules()) == null ? void 0 : _a.resolvedPluginApi;
    if (!resolvedPluginApi)
      return;
    saveMessagesViaPlugin(
      nodeishFs,
      messageLockDirPath,
      messageStates,
      index,
      defaultAliasIndex,
      delegate,
      _settings,
      // NOTE we bang here - we don't expect the settings to become null during the livetime of a project
      resolvedPluginApi
    ).catch((e) => {
      debug$4.log("error during saveMessagesViaPlugin");
      debug$4.log(e);
    }).catch((e) => {
      onSaveMessageResult(e);
    }).then(() => {
      onSaveMessageResult();
    });
  };
  return {
    setDelegate,
    create: ({ data }) => {
      if (index.has(data.id))
        return false;
      index.set(data.id, data);
      if ("default" in data.alias) {
        defaultAliasIndex.set(data.alias.default, data);
      }
      messageStates.messageDirtyFlags[data.id] = true;
      delegate == null ? void 0 : delegate.onMessageCreate(data.id, index.get(data.id), [...index.values()]);
      scheduleSave();
      return true;
    },
    get: Object.assign(get, {
      subscribe: (args, callback) => createSubscribable(() => get(args)).subscribe(callback)
    }),
    getByDefaultAlias: Object.assign(getByDefaultAlias, {
      subscribe: (alias, callback) => createSubscribable(() => getByDefaultAlias(alias)).subscribe(callback)
    }),
    includedMessageIds: createSubscribable(() => {
      return [...index.keys()];
    }),
    getAll: createSubscribable(() => {
      return [...index.values()];
    }),
    update: ({ where, data }) => {
      const message = index.get(where.id);
      if (message === void 0)
        return false;
      index.set(where.id, { ...message, ...data });
      if (data.alias && "default" in data.alias) {
        defaultAliasIndex.set(data.alias.default, data);
      }
      messageStates.messageDirtyFlags[where.id] = true;
      delegate == null ? void 0 : delegate.onMessageUpdate(where.id, index.get(data.id), [...index.values()]);
      scheduleSave();
      return true;
    },
    upsert: ({ where, data }) => {
      const message = index.get(where.id);
      if (message === void 0) {
        index.set(where.id, data);
        if ("default" in data.alias) {
          defaultAliasIndex.set(data.alias.default, data);
        }
        messageStates.messageDirtyFlags[where.id] = true;
        delegate == null ? void 0 : delegate.onMessageCreate(data.id, index.get(data.id), [...index.values()]);
      } else {
        index.set(where.id, { ...message, ...data });
        defaultAliasIndex.set(data.alias.default, { ...message, ...data });
        messageStates.messageDirtyFlags[where.id] = true;
        delegate == null ? void 0 : delegate.onMessageUpdate(data.id, index.get(data.id), [...index.values()]);
      }
      scheduleSave();
      return true;
    },
    delete: ({ where }) => {
      const message = index.get(where.id);
      if (message === void 0)
        return false;
      if ("default" in message.alias) {
        defaultAliasIndex.delete(message.alias.default);
      }
      index.delete(where.id);
      messageStates.messageDirtyFlags[where.id] = true;
      delegate == null ? void 0 : delegate.onMessageDelete(where.id, [...index.values()]);
      scheduleSave();
      return true;
    }
  };
}
async function loadMessagesViaPlugin(fs, lockDirPath, messageState, messages, aliaseToMessageMap, delegate, settingsValue, resolvedPluginApi) {
  var _a;
  const experimentalAliases = !!((_a = settingsValue.experimental) == null ? void 0 : _a.aliases);
  if (messageState.isLoading) {
    if (!messageState.sheduledLoadMessagesViaPlugin) {
      messageState.sheduledLoadMessagesViaPlugin = createAwaitable$1();
    }
    return messageState.sheduledLoadMessagesViaPlugin.promise;
  }
  messageState.isLoading = true;
  let lockTime = void 0;
  try {
    lockTime = await acquireFileLock(fs, lockDirPath, "loadMessage");
    const loadedMessages = await makeTrulyAsync(resolvedPluginApi.loadMessages({
      settings: settingsValue,
      nodeishFs: fs
    }));
    const deletedMessages = new Set(messages.keys());
    batch(() => {
      for (const loadedMessage of loadedMessages) {
        const loadedMessageClone = structuredClone(loadedMessage);
        const currentMessages = [...messages.values()].filter((message) => (experimentalAliases ? message.alias["default"] : message.id) === loadedMessage.id);
        if (currentMessages.length > 1) {
          throw new Error("more than one message with the same id or alias found ");
        } else if (currentMessages.length === 1) {
          deletedMessages.delete(currentMessages[0].id);
          loadedMessageClone.alias = {};
          if (experimentalAliases) {
            loadedMessageClone.alias["default"] = loadedMessageClone.id;
            loadedMessageClone.id = currentMessages[0].id;
          }
          const importedEnecoded = stringifyMessage(loadedMessageClone);
          if (messageState.messageLoadHash[loadedMessageClone.id] === importedEnecoded) {
            continue;
          }
          messages.set(loadedMessageClone.id, loadedMessageClone);
          if (loadedMessageClone.alias["default"]) {
            aliaseToMessageMap.set(loadedMessageClone.alias["default"], loadedMessageClone);
          }
          messageState.messageLoadHash[loadedMessageClone.id] = importedEnecoded;
          delegate == null ? void 0 : delegate.onMessageUpdate(loadedMessageClone.id, loadedMessageClone, [
            ...messages.values()
          ]);
        } else {
          loadedMessageClone.alias = {};
          if (experimentalAliases) {
            loadedMessageClone.alias["default"] = loadedMessageClone.id;
            let currentOffset = 0;
            let messsageId;
            do {
              messsageId = humanIdHash(loadedMessageClone.id, currentOffset);
              if (messages.get(messsageId)) {
                currentOffset += 1;
                messsageId = void 0;
              }
            } while (messsageId === void 0);
            loadedMessageClone.id = messsageId;
            aliaseToMessageMap.set(loadedMessageClone.alias["default"], loadedMessageClone);
          }
          const importedEnecoded = stringifyMessage(loadedMessageClone);
          messages.set(loadedMessageClone.id, loadedMessageClone);
          messageState.messageLoadHash[loadedMessageClone.id] = importedEnecoded;
          delegate == null ? void 0 : delegate.onMessageUpdate(loadedMessageClone.id, loadedMessageClone, [
            ...messages.values()
          ]);
        }
      }
      for (const deletedMessageId of deletedMessages) {
        messages.delete(deletedMessageId);
        delegate == null ? void 0 : delegate.onMessageDelete(deletedMessageId, [...messages.values()]);
      }
    });
    await releaseLock(fs, lockDirPath, "loadMessage", lockTime);
    lockTime = void 0;
    debug$4("loadMessagesViaPlugin: " + loadedMessages.length + " Messages processed ");
    messageState.isLoading = false;
  } finally {
    if (lockTime !== void 0) {
      await releaseLock(fs, lockDirPath, "loadMessage", lockTime);
    }
    messageState.isLoading = false;
  }
  const executingScheduledMessages = messageState.sheduledLoadMessagesViaPlugin;
  if (executingScheduledMessages) {
    messageState.sheduledLoadMessagesViaPlugin = void 0;
    loadMessagesViaPlugin(fs, lockDirPath, messageState, messages, aliaseToMessageMap, delegate, settingsValue, resolvedPluginApi).then(() => {
      executingScheduledMessages.resolve();
    }).catch((e) => {
      executingScheduledMessages.reject(e);
    });
  }
}
async function saveMessagesViaPlugin(fs, lockDirPath, messageState, messages, aliaseToMessageMap, delegate, settingsValue, resolvedPluginApi) {
  if (messageState.isSaving) {
    if (!messageState.sheduledSaveMessages) {
      messageState.sheduledSaveMessages = createAwaitable$1();
    }
    return messageState.sheduledSaveMessages.promise;
  }
  messageState.isSaving = true;
  messageState.currentSaveMessagesViaPlugin = async function() {
    var _a;
    const saveMessageHashes = {};
    if (Object.keys(messageState.messageDirtyFlags).length == 0) {
      debug$4("save was skipped - no messages marked as dirty... build!");
      messageState.isSaving = false;
      return;
    }
    let messageDirtyFlagsBeforeSave;
    let lockTime;
    try {
      lockTime = await acquireFileLock(fs, lockDirPath, "saveMessage");
      if (Object.keys(messageState.messageDirtyFlags).length == 0) {
        debug$4("save was skipped - no messages marked as dirty... releasing lock again");
        messageState.isSaving = false;
        return;
      }
      const currentMessages = [...messages.values()];
      const messagesToExport = [];
      for (const message of currentMessages) {
        if (messageState.messageDirtyFlags[message.id]) {
          const importedEnecoded = stringifyMessage(message);
          saveMessageHashes[message.id] = importedEnecoded;
        }
        const fixedExportMessage = { ...message };
        if ((_a = settingsValue.experimental) == null ? void 0 : _a.aliases) {
          fixedExportMessage.id = fixedExportMessage.alias["default"] ?? fixedExportMessage.id;
        }
        messagesToExport.push(fixedExportMessage);
      }
      messageDirtyFlagsBeforeSave = { ...messageState.messageDirtyFlags };
      messageState.messageDirtyFlags = {};
      await resolvedPluginApi.saveMessages({
        settings: settingsValue,
        messages: messagesToExport,
        nodeishFs: fs
      });
      for (const [messageId, messageHash] of Object.entries(saveMessageHashes)) {
        messageState.messageLoadHash[messageId] = messageHash;
      }
      if (lockTime !== void 0) {
        await releaseLock(fs, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      if (messageState.sheduledLoadMessagesViaPlugin) {
        debug$4("saveMessagesViaPlugin calling queued loadMessagesViaPlugin to share lock");
        await loadMessagesViaPlugin(fs, lockDirPath, messageState, messages, aliaseToMessageMap, delegate, settingsValue, resolvedPluginApi);
      }
      messageState.isSaving = false;
    } catch (err) {
      if (messageDirtyFlagsBeforeSave !== void 0) {
        for (const dirtyMessageId of Object.keys(messageDirtyFlagsBeforeSave)) {
          messageState.messageDirtyFlags[dirtyMessageId] = true;
        }
      }
      if (lockTime !== void 0) {
        await releaseLock(fs, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      messageState.isSaving = false;
      throw new PluginSaveMessagesError({
        cause: err
      });
    } finally {
      if (lockTime !== void 0) {
        await releaseLock(fs, lockDirPath, "saveMessage", lockTime);
        lockTime = void 0;
      }
      messageState.isSaving = false;
    }
  }();
  await messageState.currentSaveMessagesViaPlugin;
  if (messageState.sheduledSaveMessages) {
    const executingSheduledSaveMessages = messageState.sheduledSaveMessages;
    messageState.sheduledSaveMessages = void 0;
    saveMessagesViaPlugin(fs, lockDirPath, messageState, messages, aliaseToMessageMap, delegate, settingsValue, resolvedPluginApi).then(() => {
      executingSheduledSaveMessages.resolve();
    }).catch((e) => {
      executingSheduledSaveMessages.reject(e);
    });
  }
}
const makeTrulyAsync = (fn) => (async () => fn)();
const createAwaitable$1 = () => {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
};
class MessagedLintRuleThrowedError extends Error {
  constructor(message, options) {
    super(message, options);
    this.name = "MessagedLintRuleThrowedError";
  }
}
const lintSingleMessage = async (args) => {
  const reports = [];
  const errors2 = [];
  const promises = args.rules.map(async (rule) => {
    var _a;
    const level = (_a = args.settings.messageLintRuleLevels) == null ? void 0 : _a[rule.id];
    if (level === void 0) {
      throw Error("No lint level provided for lint rule: " + rule.id);
    }
    try {
      await rule.run({
        message: args.message,
        settings: args.settings,
        report: (reportArgs) => {
          reports.push({
            ruleId: rule.id,
            level,
            messageId: reportArgs.messageId,
            languageTag: reportArgs.languageTag,
            body: reportArgs.body
          });
        }
      });
    } catch (error) {
      errors2.push(new MessagedLintRuleThrowedError(`Lint rule '${rule.id}' throwed while linting message "${args.message.id}".`, { cause: error }));
    }
  });
  await Promise.all(promises);
  const sortedReports = reports.sort((r1, r2) => r1.ruleId.localeCompare(r2.ruleId));
  return { data: sortedReports, errors: errors2 };
};
const debug$3 = _debug("sdk:lintReports");
function createMessageLintReportsQuery(messagesQuery, settings, installedMessageLintRules, resolvedModules) {
  const index = new ReactiveMap();
  debug$3("resetting settledReports");
  let settledReports = Promise.resolve();
  let currentBatchEnd = void 0;
  const updatedReports = {};
  createMemo(() => {
    index.clear();
    onCleanup(() => {
      messagesQuery.setDelegate(void 0, false);
    });
    const _settings = settings();
    if (!_settings)
      return;
    const _resolvedModules = resolvedModules();
    if (!_resolvedModules)
      return;
    const rulesArray = _resolvedModules.messageLintRules;
    const messageLintRuleLevels = Object.fromEntries(installedMessageLintRules().map((rule) => [rule.id, rule.level]));
    const settingsObject = () => {
      return {
        ...settings(),
        messageLintRuleLevels
      };
    };
    const sheduleLintMessage = (message, messages) => {
      debug$3("shedule Lint for message:", message.id);
      const updateOutstandingReportsOnLast = async () => {
        if (currentBatchEnd !== updateOutstandingReportsOnLast) {
          debug$3("skip triggering reactivy", message.id);
          return;
        }
        debug$3("finished queue - trigger reactivity", message.id);
        batch(() => {
          for (const [id, reports] of Object.entries(updatedReports)) {
            const currentReports = index.get(id);
            if (!reportsEqual(currentReports, reports)) {
              debug$3("lint reports for message: ", id, " now n:", reports.length);
              index.set(id, reports);
            }
          }
        });
      };
      currentBatchEnd = updateOutstandingReportsOnLast;
      const scheduledLint = lintSingleMessage({
        rules: rulesArray,
        settings: settingsObject(),
        messages,
        message
      }).then((reportsResult) => {
        if (reportsResult.errors.length === 0) {
          debug$3("lint reports for message: ", message.id, "n:", reportsResult.data.length);
          updatedReports[message.id] = reportsResult.data;
        }
        return updateOutstandingReportsOnLast();
      });
      settledReports = settledReports.then(() => scheduledLint);
    };
    const messageQueryChangeDelegate = {
      onCleanup: () => {
        index.clear();
      },
      onLoaded: (messages) => {
        debug$3("sheduluing Lint for all messages - on load");
        batch(() => {
          debug$3("sheduluing Lint for all messages - subsquencial call?");
          for (const message of messages) {
            sheduleLintMessage(message, messages);
          }
        });
      },
      onMessageCreate: (messageId, message, messages) => {
        debug$3("shedule Lint for message - onMessageCreate", message.id);
        sheduleLintMessage(message, messages);
      },
      onMessageUpdate: (messageId, message, messages) => {
        debug$3("shedule Lint for message - onMessageUpdate", message.id);
        sheduleLintMessage(message, messages);
      },
      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TODO MESDK-105 we gonna need the mesage Property for evaluation
      onMessageDelete: (messageId, _messages) => {
        index.delete(messageId);
      }
    };
    untrack(() => {
      messagesQuery.setDelegate(messageQueryChangeDelegate, true);
    });
  });
  const get = (args) => {
    debug$3("get", args.where.messageId);
    return structuredClone(index.get(args.where.messageId));
  };
  const getAll = () => {
    const flatValues = [...index.values()].flat();
    debug$3("getAll", flatValues.length);
    return structuredClone(flatValues.length === 0 ? [] : flatValues);
  };
  return {
    getAll: Object.assign(createSubscribable(getAll), {
      settled: async () => {
        await settledReports;
        return getAll();
      }
    }),
    get: Object.assign(get, {
      subscribe: (args, callback) => createSubscribable(() => get(args)).subscribe(callback)
    })
  };
}
function reportsEqual(reportsA, reportsB) {
  var _a, _b, _c, _d, _e, _f;
  if (reportsA === void 0 && reportsB === void 0) {
    return true;
  } else if (reportsA === void 0 || reportsB === void 0) {
    return false;
  }
  if (reportsA.length !== reportsB.length) {
    return false;
  }
  for (const [i2, element] of reportsA.entries()) {
    if ((element == null ? void 0 : element.languageTag) !== ((_a = reportsB[i2]) == null ? void 0 : _a.languageTag)) {
      return false;
    }
    if ((element == null ? void 0 : element.level) !== ((_b = reportsB[i2]) == null ? void 0 : _b.level)) {
      return false;
    }
    if ((element == null ? void 0 : element.ruleId) !== ((_c = reportsB[i2]) == null ? void 0 : _c.ruleId)) {
      return false;
    }
    if (typeof (element == null ? void 0 : element.body) !== typeof ((_d = reportsB[i2]) == null ? void 0 : _d.body)) {
      return false;
    }
    if (typeof (element == null ? void 0 : element.body) === "string") {
      if (((_e = reportsB[i2]) == null ? void 0 : _e.body) !== ((_f = reportsB[i2]) == null ? void 0 : _f.body)) {
        return false;
      }
    } else {
      if (JSON.stringify(element == null ? void 0 : element.body) !== JSON.stringify(element == null ? void 0 : element.body)) {
        return false;
      }
    }
  }
  return true;
}
const migrate1to2 = (config) => {
  const migrated = {
    $schema: "https://inlang.com/schema/project-settings",
    sourceLanguageTag: config.sourceLanguageTag,
    languageTags: config.languageTags,
    modules: config.modules
  };
  if (config.settings["project.messageLintRuleLevels"]) {
    migrated.messageLintRuleLevels = config.settings["project.messageLintRuleLevels"];
  }
  for (const key in config.settings) {
    if (key === "project.messageLintRuleLevels")
      continue;
    migrated[key] = config.settings[key];
  }
  return migrated;
};
function migrateIfOutdated(schema) {
  if (schema.settings) {
    return migrate1to2(schema);
  }
  return schema;
}
const createNodeishFsWithAbsolutePaths = (args) => {
  if (!isAbsolutePath(args.projectPath)) {
    throw new Error(`Expected an absolute path but received "${args.projectPath}".`);
  }
  const basePath = normalizePath(args.projectPath).split("/").slice(0, -1).join("/");
  const makeAbsolute = (path) => {
    if (isAbsolutePath(path)) {
      return normalizePath(path);
    }
    return normalizePath(basePath + "/" + path);
  };
  return {
    // @ts-expect-error
    readFile: (path, options) => args.nodeishFs.readFile(makeAbsolute(path), options),
    readdir: (path) => args.nodeishFs.readdir(makeAbsolute(path)),
    mkdir: (path, options) => args.nodeishFs.mkdir(makeAbsolute(path), options),
    writeFile: (path, data) => args.nodeishFs.writeFile(makeAbsolute(path), data),
    stat: (path) => args.nodeishFs.stat(makeAbsolute(path)),
    rm: (path) => args.nodeishFs.rm(makeAbsolute(path)),
    rmdir: (path) => args.nodeishFs.rmdir(makeAbsolute(path)),
    watch: (path, options) => args.nodeishFs.watch(makeAbsolute(path), options),
    // This might be surprising when symlinks were intended to be relative
    symlink: (target, path) => args.nodeishFs.symlink(makeAbsolute(target), makeAbsolute(path)),
    unlink: (path) => args.nodeishFs.unlink(makeAbsolute(path)),
    readlink: (path) => args.nodeishFs.readlink(makeAbsolute(path)),
    lstat: (path) => args.nodeishFs.lstat(makeAbsolute(path))
  };
};
const maybeMigrateToDirectory = async (args) => {
  if (args.projectPath.endsWith("project.inlang") === false) {
    return;
  }
  const projectDirectory = await tryCatch(() => args.nodeishFs.stat(args.projectPath));
  if (projectDirectory.data) {
    return;
  }
  const settingsFile = await tryCatch(() => args.nodeishFs.readFile(args.projectPath + ".json", { encoding: "utf-8" }));
  if (settingsFile.error) {
    return;
  }
  await args.nodeishFs.mkdir(args.projectPath);
  await args.nodeishFs.writeFile(`${args.projectPath}/settings.json`, settingsFile.data);
  await args.nodeishFs.writeFile(args.projectPath + ".README.md", readme);
};
const readme = `
# DELETE THE \`project.inlang.json\` FILE

The \`project.inlang.json\` file is now contained in a project directory e.g. \`project.inlang/settings.json\`.


## What you need to do

1. Update the inlang CLI (if you use it) to use the new path \`project.inlang\` instead of \`project.inlang.json\`.
2. Delete the \`project.inlang.json\` file.


## Why is this happening?

See this RFC https://docs.google.com/document/d/1OYyA1wYfQRbIJOIBDliYoWjiUlkFBNxH_U2R4WpVRZ4/edit#heading=h.pecv6xb7ial6 
and the following GitHub issue for more information https://github.com/opral/monorepo/issues/1678.

- Monorepo support https://github.com/opral/monorepo/discussions/258. 
- Required for many other future features like caching, first class offline support, and more. 
- Stablize the inlang project format.
`;
const withProxy = ({ nodeishFs, verbose = false, description, intercept }) => {
  return new Proxy(nodeishFs, {
    get(getTarget, prop, receiver) {
      if (getTarget[prop]) {
        return new Proxy(getTarget[prop], {
          apply(callTarget, thisArg, argumentsList) {
            if (verbose) {
              console.warn(`${description} fs:`, prop, argumentsList);
            }
            const execute = () => Reflect.apply(callTarget, thisArg, argumentsList);
            return intercept ? intercept({ prop, argumentsList, execute }) : execute();
          }
        });
      }
      return Reflect.get(getTarget, prop, receiver);
    }
  });
};
function parseOrigin({ remotes }) {
  const origin = remotes == null ? void 0 : remotes.find((elements) => elements.remote === "origin");
  if (origin === void 0) {
    return void 0;
  }
  let result = origin.url;
  if (result.endsWith(".git") === false) {
    result += ".git";
  }
  return transformRemote(result);
}
function transformRemote(remote) {
  const regex = /(?:https:\/\/|@|git:\/\/)([^/]+)\/(.+?)(?:\.git)?$/;
  const matches = remote.match(regex);
  if (matches && matches[1] && matches[2]) {
    let host = matches[1].replace(/:/g, "/");
    const repo = matches[2];
    const hostRegex = /(ghp_|ghs_)[\w]+@/;
    host = host.replace(hostRegex, "");
    return `${host}/${repo}.git`;
  }
  return void 0;
}
function parseLixUri(uriText) {
  let url;
  try {
    url = new URL(uriText);
  } catch (error) {
    return {
      error,
      username: "",
      password: "",
      protocol: "",
      lixHost: "",
      namespace: "",
      repoHost: "",
      owner: "",
      repoName: ""
    };
  }
  const { protocol, host, pathname, username, password } = url;
  const pathParts = pathname.split("/");
  let lixHost = "";
  let namespace = "";
  let repoHost = "";
  let owner = "";
  let repoName = "";
  if (host === "github.com") {
    repoHost = host;
    owner = pathParts[1] || "";
    repoName = pathParts[2] || "";
    if (!repoHost || !owner || !repoName) {
      return {
        error: new Error(`Invalid url format for '${uriText}' for direct cloning repository from github, please use the format of https://github.com/opral/monorepo.`),
        username,
        password,
        protocol,
        lixHost,
        namespace,
        repoHost,
        owner,
        repoName
      };
    }
  } else {
    lixHost = host;
    namespace = pathParts[1] || "";
    repoHost = pathParts[2] || "";
    owner = pathParts[3] || "";
    repoName = pathParts[4] || "";
    if (!namespace || !host || !owner || !repoName) {
      return {
        error: new Error(`Invalid url format for '${uriText}' for cloning repository, please use the format of https://lix.inlang.com/git/github.com/opral/monorepo.`),
        username,
        password,
        protocol,
        lixHost,
        namespace,
        repoHost,
        owner,
        repoName
      };
    }
  }
  return {
    username,
    password,
    protocol,
    lixHost,
    namespace,
    repoHost,
    owner,
    repoName
  };
}
async function hash(inputStr) {
  var _a;
  let usedCrypto;
  if (typeof crypto === "undefined" && typeof process !== "undefined" && ((_a = process == null ? void 0 : process.versions) == null ? void 0 : _a.node)) {
    const modName = "crypto";
    usedCrypto = (globalThis == null ? void 0 : globalThis.crypto) || await import(`node:${modName}`);
  } else if (typeof crypto !== "undefined") {
    usedCrypto = crypto;
  }
  if (!usedCrypto) {
    throw new Error("Could not find crypto features in runtime");
  }
  const idDigest = await usedCrypto.subtle.digest("SHA-256", new TextEncoder().encode(inputStr));
  return [...new Uint8Array(idDigest)].map((b) => ("00" + b.toString(16)).slice(-2)).join("");
}
async function maybeCreateFirstProjectId(args) {
  if (args.repo === void 0) {
    return;
  }
  try {
    await args.repo.nodeishFs.readFile(args.projectPath + "/project_id", {
      encoding: "utf-8"
    });
  } catch (error) {
    if (error.code === "ENOENT" && args.repo) {
      const projectId = await generateProjectId({ repo: args.repo, projectPath: args.projectPath });
      if (projectId) {
        await args.repo.nodeishFs.writeFile(args.projectPath + "/project_id", projectId).catch((error2) => {
          console.error("Failed to write project_id", error2);
        });
      }
    }
  }
}
async function generateProjectId(args) {
  if (!args.repo || !args.projectPath) {
    return void 0;
  }
  const firstCommitHash = await args.repo.getFirstCommitHash();
  if (firstCommitHash) {
    try {
      return await hash(`${firstCommitHash + args.projectPath}`);
    } catch (error) {
      console.error("Failed to generate project_id", error);
    }
  }
  return void 0;
}
const EXPECTED_IGNORES = ["cache"];
async function maybeAddModuleCache(args) {
  if (args.repo === void 0)
    return;
  const projectExists = await directoryExists(args.projectPath, args.repo.nodeishFs);
  if (!projectExists)
    return;
  const gitignorePath = args.projectPath + "/.gitignore";
  const moduleCache = args.projectPath + "/cache/modules/";
  const gitignoreExists = await fileExists(gitignorePath, args.repo.nodeishFs);
  const moduleCacheExists = await directoryExists(moduleCache, args.repo.nodeishFs);
  if (gitignoreExists) {
    try {
      const gitignore = await args.repo.nodeishFs.readFile(gitignorePath, { encoding: "utf-8" });
      const missingIgnores = EXPECTED_IGNORES.filter((ignore) => !gitignore.includes(ignore));
      if (missingIgnores.length > 0) {
        await args.repo.nodeishFs.appendFile(gitignorePath, "\n" + missingIgnores.join("\n"));
      }
    } catch (error) {
      throw new Error("[migrate:module-cache] Failed to update .gitignore", { cause: error });
    }
  } else {
    try {
      await args.repo.nodeishFs.writeFile(gitignorePath, EXPECTED_IGNORES.join("\n"));
    } catch (e) {
      if (e.code && e.code !== "EISDIR" && e.code !== "EEXIST") {
        throw new Error("[migrate:module-cache] Failed to create .gitignore", { cause: e });
      }
    }
  }
  if (!moduleCacheExists) {
    try {
      await args.repo.nodeishFs.mkdir(moduleCache, { recursive: true });
    } catch (e) {
      throw new Error("[migrate:module-cache] Failed to create cache directory", { cause: e });
    }
  }
}
async function fileExists(path, nodeishFs) {
  try {
    const stat = await nodeishFs.stat(path);
    return stat.isFile();
  } catch {
    return false;
  }
}
async function directoryExists(path, nodeishFs) {
  try {
    const stat = await nodeishFs.stat(path);
    return stat.isDirectory();
  } catch {
    return false;
  }
}
const ENV_VARIABLES = {
  PUBLIC_POSTHOG_TOKEN: "phc_oE6Qs5mT6oXMw9Z0Om1CqIBpg5RcSLYmghoFR5irZOd"
};
const capture$1 = async (event, args) => {
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.PUBLIC_POSTHOG_TOKEN,
        event,
        // id is "unknown" because no user information is available
        distinct_id: "unknown",
        properties: {
          $groups: { project: args.projectId },
          ...args.properties
        }
      })
    });
  } catch (e) {
  }
};
const identifyProject = async (args) => {
  try {
    await fetch("https://eu.posthog.com/capture/", {
      method: "POST",
      body: JSON.stringify({
        api_key: ENV_VARIABLES.PUBLIC_POSTHOG_TOKEN,
        event: "$groupidentify",
        // id is "unknown" because no user information is available
        distinct_id: "unknown",
        properties: {
          $group_type: "project",
          $group_key: args.projectId,
          $group_set: {
            ...args.properties
          }
        }
      })
    });
  } catch (e) {
  }
};
const stubMessagesQuery = {
  create: () => false,
  // @ts-expect-error
  get: subscribable(() => void 0),
  // @ts-expect-error
  getByDefaultAlias: subscribable(() => void 0),
  // @ts-expect-error
  includedMessageIds: subscribable(() => []),
  // @ts-expect-error
  getAll: subscribable(() => []),
  update: () => false,
  upsert: () => {
  },
  delete: () => false,
  setDelegate: () => {
  }
};
const stubMessageLintReportsQuery = {
  // @ts-expect-error
  get: subscribable(() => []),
  // @ts-expect-error
  getAll: settleable(subscribable(() => []))
};
function subscribable(fn) {
  return Object.assign(fn, {
    subscribe: () => {
    }
  });
}
function settleable(fn) {
  return Object.assign(fn, {
    settled: async () => []
  });
}
const pattern = "^((?<grandfathered>(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((?<language>([A-Za-z]{2,3}(-(?<extlang>[A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?))(-(?<script>[A-Za-z]{4}))?(-(?<region>[A-Za-z]{2}|[0-9]{3}))?(-(?<variant>[A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*))$";
const LanguageTag = typebox.Type.String({
  pattern,
  description: "The language tag must be a valid IETF BCP 47 language tag.",
  examples: ["en", "de", "en-US", "zh-Hans", "es-419"]
});
const Literal = typebox.Type.Object({
  type: typebox.Type.Literal("literal"),
  value: typebox.Type.String()
});
const Text = typebox.Type.Object({
  type: typebox.Type.Literal("text"),
  value: typebox.Type.String()
});
const VariableReference = typebox.Type.Object({
  type: typebox.Type.Literal("variable"),
  name: typebox.Type.String()
});
const Option = typebox.Type.Object({
  name: typebox.Type.String(),
  value: typebox.Type.Union([Literal, VariableReference])
});
const FunctionAnnotation = typebox.Type.Object({
  type: typebox.Type.Literal("function"),
  name: typebox.Type.String(),
  options: typebox.Type.Array(Option)
});
const Expression = typebox.Type.Object({
  type: typebox.Type.Literal("expression"),
  arg: typebox.Type.Union([Literal, VariableReference]),
  annotation: typebox.Type.Optional(FunctionAnnotation)
});
const Pattern = typebox.Type.Array(typebox.Type.Union([Text, Expression]));
const Variant = typebox.Type.Object({
  /**
   * The number of keys in each variant match MUST equal the number of expressions in the selectors.
   *
   * Inspired by: https://github.com/unicode-org/message-format-wg/blob/main/spec/formatting.md#pattern-selection
   */
  // a match can always only be string-based because a string is what is rendered to the UI
  match: typebox.Type.Array(typebox.Type.String()),
  pattern: Pattern
});
const InputDeclaration = typebox.Type.Object({
  type: typebox.Type.Literal("input"),
  name: typebox.Type.String(),
  //TODO make this generic so that only Variable-Ref Expressions are allowed
  value: Expression
});
const Declaration = typebox.Type.Union([InputDeclaration]);
const Message = typebox.Type.Object({
  locale: LanguageTag,
  declarations: typebox.Type.Array(Declaration),
  /**
   * The order in which the selectors are placed determines the precedence of patterns.
   */
  selectors: typebox.Type.Array(Expression),
  variants: typebox.Type.Array(Variant)
});
typebox.Type.Object({
  id: typebox.Type.String(),
  alias: typebox.Type.Record(typebox.Type.String(), typebox.Type.String()),
  messages: typebox.Type.Array(Message)
});
const MessageSlot = typebox.Type.Object({
  locale: LanguageTag,
  slot: typebox.Type.Literal(true)
});
typebox.Type.Object({
  id: typebox.Type.String(),
  alias: typebox.Type.Record(typebox.Type.String(), typebox.Type.String()),
  messages: typebox.Type.Array(typebox.Type.Union([Message, MessageSlot]))
});
function createMessageSlot(locale) {
  return {
    locale,
    slot: true
  };
}
function addSlots(messageBundle, locales) {
  const bundle = structuredClone(messageBundle);
  bundle.messages = locales.map((locale) => {
    return bundle.messages.find((message) => message.locale === locale) ?? createMessageSlot(locale);
  });
  return bundle;
}
function removeSlots(messageBundle) {
  messageBundle.messages = messageBundle.messages.filter((message) => !("slot" in message));
  return messageBundle;
}
function injectJSONNewlines(json) {
  return json.replace(/\{"id":"/g, '\n\n\n\n{"id":"').replace(/"messages":\[\{"locale":"/g, '"messages":[\n\n\n\n{"locale":"').replace(/\}\]\}\]\},\{"locale":"/g, '}]}]},\n\n\n\n{"locale":"').replace(/"slot":true\},\{"locale":/g, '"slot":true},\n\n\n\n{"locale":');
}
const debug$2 = _debug("sdk:batchedIO");
function batchedIO(acquireLock, releaseLock2, save) {
  let state = "idle";
  const queue = [];
  let nextBatch = void 0;
  return async (id) => {
    if (state === "idle") {
      state = "acquiring";
      const lock = await acquireLock();
      state = "saving";
      await save();
      await releaseLock2(lock);
      resolveQueued();
      nextBatch = void 0;
      state = "idle";
      return id;
    } else if (state === "acquiring") {
      return new Promise((resolve, reject) => {
        queue.push({ id, resolve, reject });
      });
    } else {
      nextBatch = nextBatch ?? batchedIO(acquireLock, releaseLock2, save);
      return await nextBatch(id);
    }
  };
  function resolveQueued() {
    debug$2("batched", queue.length + 1);
    for (const { id, resolve } of queue) {
      resolve(id);
    }
    queue.length = 0;
  }
}
const debug$1 = _debug("sdk:store");
async function openStore(args) {
  const nodeishFs = args.nodeishFs;
  const filePath = args.projectPath + "/messages.json";
  const lockDirPath = args.projectPath + "/messagelock";
  let index = await load();
  const batchedSave = batchedIO(acquireSaveLock, releaseSaveLock, save);
  return {
    messageBundles: {
      reload: async () => {
        index.clear();
        index = await load();
      },
      get: async (args2) => {
        return index.get(args2.id);
      },
      set: async (args2) => {
        index.set(args2.data.id, args2.data);
        await batchedSave(args2.data.id);
      },
      delete: async (args2) => {
        index.delete(args2.id);
        await batchedSave(args2.id);
      },
      getAll: async () => {
        return [...index.values()];
      }
    }
  };
  async function load() {
    const lockTime = await acquireFileLock(nodeishFs, lockDirPath, "load");
    const messages = await readJSON({ filePath, nodeishFs });
    const index2 = new Map(messages.map((message) => [message.id, message]));
    await releaseLock(nodeishFs, lockDirPath, "load", lockTime);
    return index2;
  }
  async function acquireSaveLock() {
    return await acquireFileLock(nodeishFs, lockDirPath, "save");
  }
  async function releaseSaveLock(lock) {
    return await releaseLock(nodeishFs, lockDirPath, "save", lock);
  }
  async function save() {
    await writeJSON({
      filePath,
      nodeishFs,
      messages: [...index.values()],
      locales: args.locales
    });
  }
}
async function readJSON(args) {
  let result = [];
  debug$1("loadAll", args.filePath);
  try {
    const file = await args.nodeishFs.readFile(args.filePath, { encoding: "utf-8" });
    result = JSON.parse(file);
  } catch (error) {
    if ((error == null ? void 0 : error.code) !== "ENOENT") {
      debug$1("loadMessages", error);
      throw error;
    }
  }
  return result.map(removeSlots);
}
async function writeJSON(args) {
  debug$1("saveall", args.filePath);
  try {
    await createDirectoryIfNotExits(getDirname(args.filePath), args.nodeishFs);
    const output = injectJSONNewlines(JSON.stringify(args.messages.map((bundle) => addSlots(bundle, args.locales))));
    await args.nodeishFs.writeFile(args.filePath, output);
  } catch (error) {
    debug$1("saveMessages", error);
    throw error;
  }
}
async function createDirectoryIfNotExits(path, nodeishFs) {
  try {
    await nodeishFs.mkdir(path, { recursive: true });
  } catch (error) {
    if (error.code !== "EEXIST") {
      throw error;
    }
  }
}
const debug = _debug("sdk:loadProject");
const settingsCompiler = compiler$1.TypeCompiler.Compile(ProjectSettings);
async function loadProject(args) {
  const projectPath = normalizePath(args.projectPath);
  assertValidProjectPath(projectPath);
  debug(projectPath);
  const nodeishFs = createNodeishFsWithAbsolutePaths({
    projectPath,
    nodeishFs: args.repo.nodeishFs
  });
  await maybeMigrateToDirectory({ nodeishFs, projectPath });
  await maybeCreateFirstProjectId({ projectPath, repo: args.repo });
  await maybeAddModuleCache({ projectPath, repo: args.repo });
  return await createRoot(async () => {
    const { data: projectId } = await tryCatch(() => nodeishFs.readFile(args.projectPath + "/project_id", { encoding: "utf-8" }));
    const [initialized, markInitAsComplete, markInitAsFailed] = createAwaitable();
    const [loadedSettings, markSettingsAsLoaded, markSettingsAsFailed] = createAwaitable();
    const [resolvedModules, setResolvedModules] = createSignal();
    const [settings, _setSettings] = createSignal();
    let v2Persistence = false;
    let locales = [];
    const setSettings = (newSettings) => {
      var _a;
      try {
        const validatedSettings = parseSettings(newSettings);
        v2Persistence = !!((_a = validatedSettings.experimental) == null ? void 0 : _a.persistence);
        locales = validatedSettings.languageTags;
        batch(() => {
          setResolvedModules(void 0);
          _setSettings(validatedSettings);
        });
        return { data: validatedSettings };
      } catch (error) {
        if (error instanceof ProjectSettingsInvalidError) {
          return { error };
        }
        throw new Error("Unhandled error in setSettings. This is an internal bug. Please file an issue.", { cause: error });
      }
    };
    const nodeishFsWithWatchersForSettings = createNodeishFsWithWatcher({
      nodeishFs,
      onChange: async () => {
        const readSettingsResult = await tryCatch(async () => await loadSettings({
          settingsFilePath: projectPath + "/settings.json",
          nodeishFs
        }));
        if (readSettingsResult.error)
          return;
        const newSettings = readSettingsResult.data;
        if (JSON.stringify(newSettings) !== JSON.stringify(settings())) {
          setSettings(newSettings);
        }
      }
    });
    const settingsResult = await tryCatch(async () => await loadSettings({
      settingsFilePath: projectPath + "/settings.json",
      nodeishFs: nodeishFsWithWatchersForSettings
    }));
    if (settingsResult.error) {
      markInitAsFailed(settingsResult.error);
      markSettingsAsFailed(settingsResult.error);
    } else {
      setSettings(settingsResult.data);
      markSettingsAsLoaded();
    }
    createEffect(() => {
      const _settings = settings();
      if (!_settings)
        return;
      resolveModules({
        settings: _settings,
        nodeishFs,
        _import: args._import,
        projectPath
      }).then((resolvedModules2) => {
        setResolvedModules(resolvedModules2);
      }).catch((err) => markInitAsFailed(err));
    });
    let settingsValue;
    createEffect(() => settingsValue = settings());
    const installedMessageLintRules = () => {
      if (!resolvedModules())
        return [];
      return resolvedModules().messageLintRules.map((rule) => {
        var _a, _b, _c;
        return {
          id: rule.id,
          displayName: rule.displayName,
          description: rule.description,
          module: ((_b = (_a = resolvedModules()) == null ? void 0 : _a.meta.find((m) => m.id.includes(rule.id))) == null ? void 0 : _b.module) ?? "Unknown module. You stumbled on a bug in inlang's source code. Please open an issue.",
          // default to warning, see https://github.com/opral/monorepo/issues/1254
          level: ((_c = settingsValue["messageLintRuleLevels"]) == null ? void 0 : _c[rule.id]) ?? "warning",
          settingsSchema: rule.settingsSchema
        };
      });
    };
    const installedPlugins = () => {
      if (!resolvedModules())
        return [];
      return resolvedModules().plugins.map((plugin) => {
        var _a, _b;
        return {
          id: plugin.id,
          displayName: plugin.displayName,
          description: plugin.description,
          module: ((_b = (_a = resolvedModules()) == null ? void 0 : _a.meta.find((m) => m.id.includes(plugin.id))) == null ? void 0 : _b.module) ?? "Unknown module. You stumbled on a bug in inlang's source code. Please open an issue.",
          settingsSchema: plugin.settingsSchema
        };
      });
    };
    const [loadMessagesViaPluginError, setLoadMessagesViaPluginError] = createSignal();
    const [saveMessagesViaPluginError, setSaveMessagesViaPluginError] = createSignal();
    let messagesQuery;
    let lintReportsQuery;
    let store;
    await loadedSettings.catch(() => {
    });
    if (v2Persistence) {
      messagesQuery = stubMessagesQuery;
      lintReportsQuery = stubMessageLintReportsQuery;
      try {
        store = await openStore({ projectPath, nodeishFs, locales });
        markInitAsComplete();
      } catch (e) {
        markInitAsFailed(e);
      }
    } else {
      messagesQuery = createMessagesQuery({
        projectPath,
        nodeishFs,
        settings,
        resolvedModules,
        onInitialMessageLoadResult: (e) => {
          if (e) {
            markInitAsFailed(e);
          } else {
            markInitAsComplete();
          }
        },
        onLoadMessageResult: (e) => {
          setLoadMessagesViaPluginError(e);
        },
        onSaveMessageResult: (e) => {
          setSaveMessagesViaPluginError(e);
        }
      });
      lintReportsQuery = createMessageLintReportsQuery(messagesQuery, settings, installedMessageLintRules, resolvedModules);
      store = void 0;
    }
    const initializeError = await initialized.catch((error) => error);
    let projectLoadedCapturedAlready = false;
    if (projectId && projectLoadedCapturedAlready === false) {
      projectLoadedCapturedAlready = true;
      await identifyProject({
        projectId,
        properties: {
          // using the id for now as a name but can be changed in the future
          // we need at least one property to make a project visible in the dashboard
          name: projectId
        }
      });
      await capture$1("SDK loaded project", {
        projectId,
        properties: {
          appId: args.appId,
          settings: settings(),
          installedPluginIds: installedPlugins().map((p) => p.id),
          installedMessageLintRuleIds: installedMessageLintRules().map((r) => r.id),
          // TODO: fix for v2Persistence
          // https://github.com/opral/inlang-message-sdk/issues/78
          numberOfMessages: messagesQuery.includedMessageIds().length
        }
      });
    }
    return {
      id: projectId,
      installed: {
        plugins: createSubscribable(() => installedPlugins()),
        messageLintRules: createSubscribable(() => installedMessageLintRules())
      },
      errors: createSubscribable(() => [
        ...initializeError ? [initializeError] : [],
        ...resolvedModules() ? resolvedModules().errors : [],
        ...loadMessagesViaPluginError() ? [loadMessagesViaPluginError()] : [],
        ...saveMessagesViaPluginError() ? [saveMessagesViaPluginError()] : []
        // have a query error exposed
        //...(lintErrors() ?? []),
      ]),
      settings: createSubscribable(() => settings()),
      setSettings: (newSettings) => {
        const result = setSettings(newSettings);
        if (!result.error)
          writeSettingsToDisk({ nodeishFs, settings: result.data, projectPath });
        return result.error ? result : { data: void 0 };
      },
      customApi: createSubscribable(() => {
        var _a;
        return ((_a = resolvedModules()) == null ? void 0 : _a.resolvedPluginApi.customApi) || {};
      }),
      query: {
        messages: messagesQuery,
        messageLintReports: lintReportsQuery
      },
      store
    };
  });
}
const loadSettings = async (args) => {
  const { data: settingsFile, error: settingsFileError } = await tryCatch(async () => await args.nodeishFs.readFile(args.settingsFilePath, { encoding: "utf-8" }));
  if (settingsFileError)
    throw new ProjectSettingsFileNotFoundError({
      cause: settingsFileError,
      path: args.settingsFilePath
    });
  const json = tryCatch(() => JSON.parse(settingsFile));
  if (json.error) {
    throw new ProjectSettingsFileJSONSyntaxError({
      cause: json.error,
      path: args.settingsFilePath
    });
  }
  return parseSettings(json.data);
};
const parseSettings = (settings) => {
  const withMigration = migrateIfOutdated(settings);
  if (settingsCompiler.Check(withMigration) === false) {
    const typeErrors = [...settingsCompiler.Errors(settings)];
    if (typeErrors.length > 0) {
      throw new ProjectSettingsInvalidError({
        errors: typeErrors
      });
    }
  }
  const { sourceLanguageTag, languageTags } = settings;
  if (!languageTags.includes(sourceLanguageTag)) {
    throw new ProjectSettingsInvalidError({
      errors: [
        {
          message: `The sourceLanguageTag "${sourceLanguageTag}" is not included in the languageTags "${languageTags.join('", "')}". Please add it to the languageTags.`,
          type: compiler$1.ValueErrorType.String,
          schema: ProjectSettings,
          value: sourceLanguageTag,
          path: "sourceLanguageTag"
        }
      ]
    });
  }
  return withMigration;
};
const writeSettingsToDisk = async (args) => {
  const serializeResult = tryCatch(() => (
    // TODO: this will probably not match the original formatting
    JSON.stringify(args.settings, void 0, 2)
  ));
  if (serializeResult.error)
    throw serializeResult.error;
  const serializedSettings = serializeResult.data;
  const writeResult = await tryCatch(async () => await args.nodeishFs.writeFile(args.projectPath + "/settings.json", serializedSettings));
  if (writeResult.error)
    throw writeResult.error;
};
const createAwaitable = () => {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return [promise, resolve, reject];
};
function createSubscribable(signal) {
  return Object.assign(signal, {
    subscribe: (callback) => {
      createEffect(() => {
        callback(signal());
      });
    }
  });
}
function escapeForTemplateLiteral(text) {
  return text.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\${/g, "\\${");
}
function escapeForSingleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/'/g, "\\'");
}
function escapeForDoubleQuoteString(text) {
  return text.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}
const KEYWORDS = [
  "break",
  "case",
  "catch",
  "class",
  "const",
  "continue",
  "debugger",
  "default",
  "delete",
  "do",
  "else",
  "export",
  "extends",
  "false",
  "finally",
  "for",
  "function",
  "if",
  "import",
  "in",
  "instanceof",
  "new",
  "null",
  "return",
  "super",
  "switch",
  "this",
  "throw",
  "true",
  "try",
  "typeof",
  "var",
  "void",
  "while",
  "with",
  //Strict mode reserved keywords
  "let",
  "static",
  "yield",
  "await",
  //Reserved keywords for future use
  "enum",
  "implements",
  "interface",
  "package",
  "private",
  "protected",
  "public"
];
function isValidJSIdentifier(str) {
  return !KEYWORDS.includes(str) && canBeUsedAsVariableName(str);
}
function canBeUsedAsVariableName(str) {
  if (str.trim() !== str) {
    return false;
  }
  try {
    new Function(str, "var " + str);
  } catch (_) {
    return false;
  }
  return true;
}
const backtick = (str) => `\`${str}\``;
const compilePattern = (pattern2) => {
  let result = "";
  const params = {};
  for (const element of pattern2) {
    switch (element.type) {
      case "Text":
        result += escapeForTemplateLiteral(element.value);
        break;
      case "VariableReference":
        if (isValidJSIdentifier(element.name)) {
          result += "${params." + element.name + "}";
        } else {
          result += "${params['" + escapeForSingleQuoteString(element.name) + "']}";
        }
        params[element.name] = "NonNullable<unknown>";
        break;
      default:
        throw new Error("Unknown pattern element type: " + element);
    }
  }
  return {
    params,
    compiled: backtick(result)
  };
};
const paramsType = (params, isMessagesIndex) => {
  if (Object.keys(params).length === 0) {
    return isMessagesIndex ? "@param {{}} params" : "";
  }
  const fieldTypes = [];
  for (const [name, type] of Object.entries(params)) {
    if (isValidJSIdentifier(name)) {
      fieldTypes.push(`${name}: ${type}`);
    } else {
      fieldTypes.push(`'${escapeForSingleQuoteString(name)}': ${type}`);
    }
  }
  return `@param {{ ${fieldTypes.join(", ")} }} params`;
};
function reexportAliases(message) {
  let code = "";
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    code += `
/**
 * Change the reference from the alias \`m.${message.alias["default"]}()\` to \`m.${message.id}()\`:
 * \`\`\`diff
 * - m.${message.alias["default"]}()
 * + m.${message.id}()
 * \`\`\`
 * ---
 * \`${message.alias["default"]}\` is an alias for the message \`${message.id}\`.
 * Referencing aliases instead of the message ID has downsides like:
 *
 * - The alias might be renamed in the future, breaking the code.
 * - Constant naming convention discussions.
 *
 * Read more about aliases and their downsides here 
 * @see inlang.com/link.
 * ---
 * @deprecated reference the message by id \`m.${message.id}()\` instead
 * 
 * @param {Parameters<typeof ${message.id}>} args
 * @returns {ReturnType<typeof ${message.id}>}
 */
export const ${message.alias["default"]} = (...args) => ${message.id}(...args);
`;
  }
  return code;
}
function i(str) {
  var _a;
  str = str.replaceAll(/[^a-zA-Z0-9_]/g, "_");
  if ((_a = str[0]) == null ? void 0 : _a.match(/[0-9]/)) {
    str = "_" + str;
  }
  return str;
}
function toStringUnion(iterable) {
  return [...iterable].map((item) => `"${escapeForDoubleQuoteString(item)}"`).join(" | ");
}
const optionsType = (args) => {
  return `@param {{ languageTag?: ${toStringUnion(args.languageTags) ?? "undefined"} }} options`;
};
const messageIndexFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `/**
 * This message has been compiled by [inlang paraglide](https://inlang.com/m/gerre34r/library-inlang-paraglideJs).
 *
 * - Don't edit the message's code. Use [Sherlock (VS Code extension)](https://inlang.com/m/r7kp499g/app-inlang-ideExtension),
 *   the [web editor](https://inlang.com/m/tdozzpar/app-inlang-finkLocalizationEditor) instead, or edit the translation files manually.
 * 
 * - The params are NonNullable<unknown> because the inlang SDK does not provide information on the type of a param (yet).
 * 
 * ${paramsType(args.params, true)}
 * ${optionsType({ languageTags: args.availableLanguageTags })}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (params ${hasParams ? "" : "= {}"}, options = {}) => {
	return {
${args.availableLanguageTags.sort((a, b) => a.localeCompare(b)).map((tag) => `		${isValidJSIdentifier(tag) ? tag : `"${tag}"`}: ${i(tag)}.${args.message.id}`).join(",\n")}
	}[options.languageTag ?? languageTag()](${hasParams ? "params" : ""})
}
${reexportAliases(args.message)}
`;
};
const compileMessage = (message, fallbackMap, output = "regular") => {
  if (!isValidJSIdentifier(message.id)) {
    throw new Error(
      `Cannot compile message with ID "${message.id}".

The message is not a valid JavaScript variable name. Please choose a different ID.

To detect this issue during linting, use the valid-js-identifier lint rule: https://inlang.com/m/teldgniy/messageLintRule-inlang-validJsIdentifier`
    );
  }
  const compiledPatterns = {};
  let params = {};
  for (const variant of message.variants) {
    if (compiledPatterns[variant.languageTag]) {
      throw new Error(
        `Duplicate language tag: ${variant.languageTag}. Multiple variants for one language tag are not supported in paraglide yet. `
      );
    }
    const { compiled, params: variantParams } = compilePattern(variant.pattern);
    params = { ...params, ...variantParams };
    compiledPatterns[variant.languageTag] = compiled;
  }
  const resource = {
    source: message,
    params,
    index: messageIndexFunction({
      message,
      params,
      availableLanguageTags: Object.keys(fallbackMap)
    }),
    translations: Object.fromEntries(
      Object.entries(fallbackMap).map(([languageTag, fallbackLanguage]) => {
        const compiledPattern = compiledPatterns[languageTag];
        return [
          languageTag,
          compiledPattern ? messageFunction({
            message,
            params,
            languageTag,
            compiledPattern
          }) : fallbackLanguage ? reexportMessage(message, fallbackLanguage, output) : messageIdFallback(message, languageTag)
        ];
      })
    )
  };
  return resource;
};
const messageFunction = (args) => {
  const hasParams = Object.keys(args.params).length > 0;
  return `/**
 * ${paramsType(args.params, false)}
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${args.message.id} = (${hasParams ? "params" : ""}) => ${args.compiledPattern}
${reexportAliases(args.message)}`;
};
function reexportMessage(message, fromLanguageTag, output) {
  const exports = [message.id];
  if (message.alias["default"] && message.id !== message.alias["default"]) {
    exports.push(message.alias["default"]);
  }
  const from = output === "message-modules" ? `../${fromLanguageTag}.js` : `./${fromLanguageTag}.js`;
  return `export { ${exports.join(", ")} } from "${from}"`;
}
function messageIdFallback(message, languageTag) {
  return `/**
 * Failed to resolve message ${message.id} for languageTag "${languageTag}". 
 * @returns {string}
 */
/* @__NO_SIDE_EFFECTS__ */
export const ${message.id} = () => "${escapeForDoubleQuoteString(message.id)}"
${reexportAliases(message)}`;
}
const posthogToken = "phc_oE6Qs5mT6oXMw9Z0Om1CqIBpg5RcSLYmghoFR5irZOd";
const posthog = new PostHog(posthogToken, {
  host: "https://eu.posthog.com",
  // Events are not captured if not immediately flushed.
  //
  // Posthog shouldn't batch events because CLI commands
  // are short-lived, see https://posthog.com/docs/libraries/node.
  flushAt: 1,
  flushInterval: 0,
  requestTimeout: 1e3
});
const telemetry = new Proxy(posthog, {
  get(target, prop) {
    if (prop === "capture")
      return capture;
    return target[prop];
  }
});
function capture(args, projectId) {
  const data = {
    ...args,
    distinctId: "unknown",
    groups: projectId ? { project: projectId } : {}
  };
  return posthog.capture(data);
}
const RelevantPackages = [
  "next",
  "solid",
  "solid-start",
  "svelte",
  "@sveltejs/kit",
  "@sveltejs/adaper-static",
  "@sveltejs/adapter-node",
  "@sveltejs/adapter-netlify",
  "@sveltejs/adapter-vercel",
  "@sveltejs/adapter-cloudflare-workers",
  "@sveltejs/adapter-auto",
  "vue",
  "nuxt",
  "react",
  "react-native",
  "remix",
  "astro",
  "flutter",
  "vite",
  "webpack",
  "rollup",
  "esbuild",
  "qwick",
  "parcel",
  "lit",
  "lit-html",
  "@angular/core"
];
function getStackInfo(packageJson) {
  const packages = {};
  try {
    const pkg = packageJson;
    const dependencies = (pkg == null ? void 0 : pkg.dependencies) ?? {};
    const devDependencies = (pkg == null ? void 0 : pkg.devDependencies) ?? {};
    const peerDependencies = (pkg == null ? void 0 : pkg.peerDependencies) ?? {};
    const allDependencies = { ...dependencies, ...devDependencies, ...peerDependencies };
    for (const dependencyName of RelevantPackages) {
      if (dependencyName in allDependencies) {
        const dependencyVersion = allDependencies[dependencyName];
        if (typeof dependencyVersion !== "string")
          continue;
        packages[dependencyName] = dependencyVersion;
      }
    }
    return { packages };
  } catch (error) {
    return { packages };
  }
}
async function pathExists(filePath, nodeishFs) {
  try {
    await nodeishFs.stat(filePath);
    return true;
  } catch (error) {
    if (error.code === "ENOENT") {
      return false;
    } else {
      throw new Error(`Failed to check if path exists: ${error}`, { cause: error });
    }
  }
}
async function findPackageJson(fs, cwd) {
  const potentialPackageJsonPath = nodePath__default.resolve(cwd, "package.json");
  const packageJsonExists = await pathExists(potentialPackageJsonPath, fs);
  if (packageJsonExists)
    return potentialPackageJsonPath;
  return void 0;
}
async function getPackageJson(fs, cwd) {
  const packageJsonPath = await findPackageJson(fs, cwd);
  if (!packageJsonPath)
    return void 0;
  try {
    const packageJsonContents = await fs.readFile(packageJsonPath, { encoding: "utf-8" });
    return JSON.parse(packageJsonContents);
  } catch {
    return void 0;
  }
}
function createRuntime(opts) {
  return `/* eslint-disable */
/** @type {((tag: AvailableLanguageTag) => void) | undefined} */
let _onSetLanguageTag

/**
 * The project's source language tag.
 *
 * @example
 *   if (newlySelectedLanguageTag === sourceLanguageTag){
 *     // do nothing as the source language tag is the default language
 *     return
 *   }
 */
export const sourceLanguageTag = "${opts.sourceLanguageTag}"

/**
 * The project's available language tags.
 *
 * @example
 *   if (availableLanguageTags.includes(userSelectedLanguageTag) === false){
 *     throw new Error("Language tag not available")
 *   }
 */
export const availableLanguageTags = /** @type {const} */ (${JSON.stringify(opts.languageTags)})

/**
 * Get the current language tag.
 *
 * @example
 *   if (languageTag() === "de"){
 *     console.log("Germany 🇩🇪")
 *   } else if (languageTag() === "nl"){
 *     console.log("Netherlands 🇳🇱")
 *   }
 *
 * @type {() => AvailableLanguageTag}
 */
export let languageTag = () => sourceLanguageTag

/**
 * Set the language tag.
 *
 * @example
 *
 *   // changing to language
 *   setLanguageTag("en")
 *
 *   // passing a getter function also works.
 *   //
 *   // a getter function is useful for resolving a language tag
 *   // on the server where every request has a different language tag
 *   setLanguageTag(() => {
 *     return request.languageTag
 *   })
 *
 * @param {AvailableLanguageTag | (() => AvailableLanguageTag)} tag
 */
export const setLanguageTag = (tag) => {
    if (typeof tag === "function") {
        languageTag = enforceLanguageTag(tag)
    } else {
        languageTag = enforceLanguageTag(() => tag)
    }
    // call the callback function if it has been defined
    if (_onSetLanguageTag !== undefined) {
        _onSetLanguageTag(languageTag())
    }
}

/**
 * Wraps an untrusted function and enforces that it returns a language tag.
 * @param {() => AvailableLanguageTag} unsafeLanguageTag
 * @returns {() => AvailableLanguageTag}
 */
function enforceLanguageTag(unsafeLanguageTag) {
    return () => {
        const tag = unsafeLanguageTag()
        if(!isAvailableLanguageTag(tag)) {
            throw new Error(\`languageTag() didn't return a valid language tag. Check your setLanguageTag call\`)
        }
        return tag
    }
}

/**
 * Set the \`onSetLanguageTag()\` callback function.
 *
 * The function can be used to trigger client-side side-effects such as
 * making a new request to the server with the updated language tag,
 * or re-rendering the UI on the client (SPA apps).
 *
 * - Don't use this function on the server (!).
 *   Triggering a side-effect is only useful on the client because a server-side
 *   environment doesn't need to re-render the UI.
 *
 * - The \`onSetLanguageTag()\` callback can only be defined once to avoid unexpected behavior.
 *
 * @example
 *   // if you use inlang paraglide on the server, make sure
 *   // to not call \`onSetLanguageTag()\` on the server
 *   if (isServer === false) {
 *     onSetLanguageTag((tag) => {
 *       // (for example) make a new request to the
 *       // server with the updated language tag
 *       window.location.href = \`/\${tag}/\${window.location.pathname}\`
 *     })
 *   }
 *
 * @param {(languageTag: AvailableLanguageTag) => void} fn
 */
export const onSetLanguageTag = (fn) => {
    _onSetLanguageTag = fn
}

/**
 * Check if something is an available language tag.
 *
 * @example
 * 	if (isAvailableLanguageTag(params.locale)) {
 * 		setLanguageTag(params.locale)
 * 	} else {
 * 		setLanguageTag("en")
 * 	}
 *
 * @param {any} thing
 * @returns {thing is AvailableLanguageTag}
 */
export function isAvailableLanguageTag(thing) {
    return availableLanguageTags.includes(thing)
}

// ------ TYPES ------

/**
 * A language tag that is available in the project.
 *
 * @example
 *   setLanguageTag(request.languageTag as AvailableLanguageTag)
 *
 * @typedef {typeof availableLanguageTags[number]} AvailableLanguageTag
 */`;
}
const ignoreDirectory = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`;
const defaultCompileOptions = {
  projectId: void 0,
  outputStructure: "regular"
};
const compile = async (args) => {
  const opts = {
    ...defaultCompileOptions,
    ...args
  };
  const fallbackMap = getFallbackMap(
    opts.settings.languageTags,
    opts.settings.sourceLanguageTag
  );
  const compiledMessages = opts.messages.map(
    (message) => compileMessage(message, fallbackMap, opts.outputStructure)
  );
  const pkgJson = await getPackageJson(nodeFsPromises, process.cwd());
  const stack = getStackInfo(pkgJson);
  telemetry.capture(
    {
      event: "PARAGLIDE-JS compile executed",
      properties: {
        version: "1.11.3",
        stack
      }
    },
    opts.projectId
  );
  const resources = {};
  for (const compiledMessage of compiledMessages) {
    for (const languageTag of Object.keys(compiledMessage.translations)) {
      if (languageTag === "index")
        continue;
      if (!resources[languageTag])
        resources[languageTag] = "";
      resources[languageTag] += "\n\n" + compiledMessage.translations[languageTag];
    }
  }
  const languagesWithMessages = new Set(Object.keys(resources));
  const languagesWithoutMessages = opts.settings.languageTags.filter(
    (languageTag) => !languagesWithMessages.has(languageTag)
  );
  for (const languageTag of languagesWithoutMessages) {
    if (!resources[languageTag])
      resources[languageTag] = "\n\nexport {};";
  }
  telemetry.shutdown();
  let output = {
    // boilerplate files
    ".prettierignore": ignoreDirectory,
    ".gitignore": ignoreDirectory,
    "runtime.js": createRuntime(opts.settings)
  };
  if (opts.outputStructure === "message-modules") {
    for (const message of compiledMessages) {
      output[`messages/index/${message.source.id}.js`] = [
        "/* eslint-disable */",
        'import { languageTag } from "../../runtime.js"',
        opts.settings.languageTags.map(
          (languageTag) => `import * as ${i(languageTag)} from "../${languageTag}/${message.source.id}.js"`
        ).join("\n"),
        "\n",
        message.index
      ].join("\n");
      for (const [lang, source] of Object.entries(message.translations)) {
        output[`messages/${lang}/${message.source.id}.js`] = [
          "/* eslint-disable */",
          `/** 
* This file contains language specific message functions for tree-shaking. 
* 
*! WARNING: Only import messages from this file if you want to manually
*! optimize your bundle. Else, import from the \`messages.js\` file. 
* 
* Your bundler will (in the future) automatically replace the index function 
* with a language specific message function in the build step. 
*/`,
          source
        ].join("\n");
      }
    }
    const messageIDs = compiledMessages.map((message) => message.source.id);
    output["messages.js"] = [
      "/* eslint-disable */",
      ...messageIDs.map((id) => `export * from "./messages/index/${id}.js"`)
    ].join("\n");
    for (const languageTag of opts.settings.languageTags) {
      output[`messages/${languageTag}.js`] = [
        "/* eslint-disable */",
        ...messageIDs.length === 0 ? ["export {}"] : messageIDs.map((id) => `export * from "./${languageTag}/${id}.js"`)
      ].join("\n");
    }
  } else {
    output = {
      ...output,
      // message index file
      "messages.js": [
        "/* eslint-disable */",
        'import { languageTag } from "./runtime.js"',
        opts.settings.languageTags.map((languageTag) => `import * as ${i(languageTag)} from "./messages/${languageTag}.js"`).join("\n"),
        "\n",
        compiledMessages.map((message) => message.index).join("\n\n")
      ].join("\n"),
      ...Object.fromEntries(
        Object.entries(resources).map(([languageTag, content]) => [
          `messages/${languageTag}.js`,
          [
            "/* eslint-disable */",
            `/** 
 * This file contains language specific message functions for tree-shaking. 
 * 
 *! WARNING: Only import messages from this file if you want to manually
 *! optimize your bundle. Else, import from the \`messages.js\` file. 
 * 
 * Your bundler will (in the future) automatically replace the index function 
 * with a language specific message function in the build step. 
 */`,
            content
          ].join("\n")
        ])
      )
    };
  }
  return output;
};
function getFallbackMap(languageTags, sourceLanguageTag) {
  return Object.fromEntries(
    languageTags.map((lang) => {
      const fallbackLanguage = lookup(lang, {
        languageTags: languageTags.filter((t) => t !== lang),
        defaultLanguageTag: sourceLanguageTag
      });
      if (lang === fallbackLanguage)
        return [lang, void 0];
      else
        return [lang, fallbackLanguage];
    })
  );
}
let previousOutputHash;
async function writeOutput(outputDirectory, output, fs) {
  const currentOutputHash = hashOutput(output, outputDirectory);
  if (currentOutputHash === previousOutputHash)
    return;
  await fs.access(outputDirectory).catch(async () => {
    await fs.mkdir(outputDirectory, { recursive: true });
  });
  const files = await fs.readdir(outputDirectory);
  await Promise.allSettled(
    files.map(async (file) => {
      await fs.unlink(outputDirectory + "/" + file);
    })
  );
  await Promise.allSettled(
    Object.keys(output).map(async (filePath) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      const directory = nodePath__default.dirname(fullPath);
      await fs.mkdir(directory, { recursive: true });
    })
  );
  await Promise.allSettled(
    Object.entries(output).map(async ([filePath, fileContent]) => {
      const fullPath = nodePath__default.resolve(outputDirectory, filePath);
      await fs.writeFile(fullPath, fileContent);
    })
  );
  previousOutputHash = currentOutputHash;
}
function hashOutput(output, outputDirectory) {
  const hash2 = crypto$1.createHash("sha256");
  hash2.update(JSON.stringify(output));
  hash2.update(outputDirectory);
  return hash2.digest("hex");
}
consola.options = {
  ...consola.options,
  formatOptions: { date: false }
};
class Logger {
  constructor(options = { silent: false, prefix: true }) {
    this.options = options;
  }
  /**
   * Prints an empty line to the console.
   */
  ln() {
    if (this.options.silent)
      return this;
    console.log("");
    return this;
  }
  log(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold("[paraglide] ") : "";
    consola.log(prefix + message);
    return this;
  }
  info(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.blue("[paraglide] ")) : "";
    consola.info(prefix + message);
    return this;
  }
  success(message) {
    if (this.options.silent)
      return this;
    const prefix = this.options.prefix ? colors.bold(colors.green("[paraglide] ")) : "";
    consola.success(prefix + message);
    return this;
  }
  warn(message, ...args) {
    consola.warn(message, ...args);
    return this;
  }
  error(message, ...args) {
    consola.error(message, ...args);
    return this;
  }
  box(message, ...args) {
    if (this.options.silent)
      return this;
    consola.box(message, ...args);
    return this;
  }
}
function classifyProjectErrors(errors2) {
  const isModuleError = (err) => err instanceof ModuleError;
  const [moduleErrors, otherErrors] = split(errors2, isModuleError);
  const isFatalModuleError = (err) => err.module.includes("plugin");
  const [fatalModuleErrors, nonFatalModuleErrors] = split(moduleErrors, isFatalModuleError);
  const fatalErrors = [...fatalModuleErrors, ...otherErrors];
  const nonFatalErrors = [...nonFatalModuleErrors];
  return { fatalErrors, nonFatalErrors };
}
function split(array, predicate) {
  const mask = array.map(predicate);
  const result = array.filter((_, index) => mask[index]);
  const rest = array.filter((_, index) => !mask[index]);
  return [result, rest];
}
export {
  Logger,
  getBasename as a,
  assertValidProjectPath as b,
  getDefaultExportFromCjs as c,
  classifyProjectErrors,
  compile,
  parseOrigin as d,
  commonjsGlobal as e,
  getAugmentedNamespace as f,
  getDirname as g,
  parseLixUri as h,
  typebox as i,
  telemetry as j,
  pathExists as k,
  loadProject as l,
  findPackageJson as m,
  normalizePath as n,
  pattern$1 as p,
  transformRemote as t,
  value$1 as v,
  withProxy as w,
  writeOutput
};
