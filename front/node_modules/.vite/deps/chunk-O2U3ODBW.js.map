{
  "version": 3,
  "sources": ["../../@inlang/paraglide-sveltekit/dist/constants.js", "../../@inlang/paraglide-sveltekit/dist/runtime/internal/index.js"],
  "sourcesContent": ["// this is a JS file to avoid transpiling in tests\nexport const NO_TRANSLATE_ATTRIBUTE = \"data-no-translate\"\n\n/** The key with which `invalidate` is called when the language changes */\nexport const LANGUAGE_CHANGE_INVALIDATION_KEY = \"paraglide:lang\"\n\n/** The name of the cookie in which the language is stored */\nexport const LANG_COOKIE_NAME = \"paraglide_lang\"\n", "// this is a JS file to avoid transpiling in tests\nimport { NO_TRANSLATE_ATTRIBUTE } from \"../../constants.js\"\nimport { getContext, setContext } from \"svelte\"\n\nconst PARAGLIDE_CONTEXT_KEY = {}\n\n/**\n * @template {string} T\n * @typedef {{ translateHref: (href: string, hreflang?: T) => string }} ParaglideContext\n */\n\n/**\n * @template {string} T\n * @private\n */\nexport const getParaglideContext = () => {\n\treturn /** @type { ParaglideContext<T> | undefined}*/ (getContext(PARAGLIDE_CONTEXT_KEY))\n}\n/**\n * @template {string} T\n * @param {ParaglideContext<T>} context\n * @private\n */\nexport const setParaglideContext = (context) => {\n\tsetContext(PARAGLIDE_CONTEXT_KEY, context)\n}\n\n/**\n * Returns the functions necessary to translate a link component\n *\n * @private\n */\nexport function getTranslationFunctions() {\n\tconst ctx = getParaglideContext()\n\n\t/**\n\t * @param {unknown} value\n\t * @param { string | undefined} lang_value\n\t * @returns\n\t */\n\tfunction translateAttribute(value, lang_value) {\n\t\tif (typeof value !== \"string\") return value\n\t\tif (!ctx) return value\n\t\treturn ctx.translateHref(value, lang_value)\n\t}\n\n\t/**\n\t * @typedef {{\n\t *\tattribute_name: string\n\t *\tlang_attribute_name?: string\n\t *}} AttributeTranslation\n\t */\n\n\t/**\n\t * Takes in an object of attributes, and an object of attribute translations\n\t * & applies the translations to the attributes\n\t *\n\t * @param {Record<string, unknown>} attrs\n\t * @param {AttributeTranslation[]} attribute_translations\n\t */\n\tfunction handleAttributes(attrs, attribute_translations) {\n\t\tif (attrs[NO_TRANSLATE_ATTRIBUTE]) return attrs\n\n\t\tfor (const { attribute_name, lang_attribute_name } of attribute_translations) {\n\t\t\tif (attribute_name in attrs) {\n\t\t\t\tconst attr = attrs[attribute_name]\n\t\t\t\tconst lang_attr = lang_attribute_name ? attrs[lang_attribute_name] : undefined\n\n\t\t\t\tattrs[attribute_name] = translateAttribute(\n\t\t\t\t\tattr,\n\t\t\t\t\ttypeof lang_attr === \"string\" ? lang_attr : undefined\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\treturn attrs\n\t}\n\n\t// we use a tuple instead of an object because the names need to be mangled on the other side\n\t// also this minifies better\n\treturn [translateAttribute, handleAttributes]\n}\n"],
  "mappings": ";;;;;;AACO,IAAM,yBAAyB;AAG/B,IAAM,mCAAmC;AAGzC,IAAM,mBAAmB;;;ACHhC,IAAM,wBAAwB,CAAC;AAWxB,IAAM,sBAAsB,MAAM;AACxC;AAAA;AAAA,IAAuD,WAAW,qBAAqB;AAAA;AACxF;AAMO,IAAM,sBAAsB,CAAC,YAAY;AAC/C,aAAW,uBAAuB,OAAO;AAC1C;AAOO,SAAS,0BAA0B;AACzC,QAAM,MAAM,oBAAoB;AAOhC,WAAS,mBAAmB,OAAO,YAAY;AAC9C,QAAI,OAAO,UAAU,SAAU,QAAO;AACtC,QAAI,CAAC,IAAK,QAAO;AACjB,WAAO,IAAI,cAAc,OAAO,UAAU;AAAA,EAC3C;AAgBA,WAAS,iBAAiB,OAAO,wBAAwB;AACxD,QAAI,MAAM,sBAAsB,EAAG,QAAO;AAE1C,eAAW,EAAE,gBAAgB,oBAAoB,KAAK,wBAAwB;AAC7E,UAAI,kBAAkB,OAAO;AAC5B,cAAM,OAAO,MAAM,cAAc;AACjC,cAAM,YAAY,sBAAsB,MAAM,mBAAmB,IAAI;AAErE,cAAM,cAAc,IAAI;AAAA,UACvB;AAAA,UACA,OAAO,cAAc,WAAW,YAAY;AAAA,QAC7C;AAAA,MACD;AAAA,IACD;AAEA,WAAO;AAAA,EACR;AAIA,SAAO,CAAC,oBAAoB,gBAAgB;AAC7C;",
  "names": []
}
