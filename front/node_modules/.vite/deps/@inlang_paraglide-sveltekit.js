import {
  bestMatch,
  prettyPrintPathDefinitionIssues,
  resolveRoute,
  resolveUserPathDefinitions,
  validatePathTranslations
} from "./chunk-PR4QD6VY.js";
import "./chunk-DMP3J6ER.js";
import {
  get as get2
} from "./chunk-LBZZ2CJ7.js";
import "./chunk-RANNE7LE.js";
import {
  LANGUAGE_CHANGE_INVALIDATION_KEY,
  LANG_COOKIE_NAME,
  setParaglideContext
} from "./chunk-O2U3ODBW.js";
import "./chunk-L3AU2XLF.js";
import {
  add_locations,
  check_target,
  each,
  hmr,
  if_block,
  index,
  init,
  key_block,
  legacy_api,
  log_if_contains_state,
  prop,
  set_attribute,
  setup_stores,
  slot,
  store_get,
  validate_store
} from "./chunk-I3V2BI2N.js";
import {
  append,
  comment,
  head,
  template
} from "./chunk-ANJ44342.js";
import {
  FILENAME,
  HMR,
  deep_read_state,
  first_child,
  get,
  legacy_pre_effect,
  legacy_pre_effect_reset,
  mark_module_end,
  mark_module_start,
  mutable_state,
  pop,
  push,
  set,
  strict_equals,
  template_effect
} from "./chunk-HVWYGCEC.js";
import "./chunk-5AQFBOJN.js";

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte
import { page as page2 } from "$app/stores";
import { browser, dev } from "$app/environment";

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/normaliseBase.js
function normaliseBase(baseValue, currentUrl) {
  if (baseValue === "")
    return "";
  const absoluteBase = new URL(baseValue, currentUrl).pathname;
  return absoluteBase.endsWith("/") ? absoluteBase.slice(0, -1) : absoluteBase;
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/route.js
function parseRoute(fullPath, normalizedBase) {
  const decodedPath = safeDecode(fullPath);
  const pathWithoutBase = removeBase(decodedPath, normalizedBase);
  const [path, dataSuffix] = removeDataSuffix(pathWithoutBase);
  return [path, dataSuffix];
}
var serializeRoute = (path, normalizedBase, dataSuffix) => [normalizedBase, path, dataSuffix ?? ""].filter((s) => s !== "/").join("") || "/";
function removeBase(absolutePath, normalizedBase) {
  const withoutBase = absolutePath.replace(normalizedBase, "");
  return withoutBase.startsWith("/") ? withoutBase : `/${withoutBase}`;
}
function removeDataSuffix(absolutePath) {
  const KNOWN_SUFFIXES = ["/.html__data.json", "/__data.json"];
  const dataSuffix = KNOWN_SUFFIXES.find((suffix) => absolutePath.endsWith(suffix));
  if (dataSuffix) {
    return [absolutePath.slice(0, -dataSuffix.length) || "/", dataSuffix];
  } else {
    return [absolutePath, void 0];
  }
}
function safeDecode(maybeEncoded) {
  try {
    return decodeURI(maybeEncoded);
  } catch {
    return maybeEncoded;
  }
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/diff-urls.js
var metaUrl = import.meta.url;
function getHrefBetween(from, to) {
  if (from.protocol !== to.protocol) {
    return to.href;
  }
  if (to.password || to.username) {
    const credentials = [to.username, to.password].filter(Boolean).join(":");
    return "//" + credentials + "@" + to.host + to.pathname + to.search + to.hash;
  }
  if (from.host !== to.host) {
    return "//" + to.host + to.pathname + to.search + to.hash;
  }
  return to.pathname + to.search + to.hash;
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte
import { base as maybe_relative_base2 } from "$app/paths";

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/external.js
function isExternal(url, currentUrl, base3) {
  const absoluteBase = new URL(base3 ?? "/", currentUrl).pathname;
  return url.origin !== currentUrl.origin || !url.pathname.startsWith(absoluteBase);
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte
import { invalidate } from "$app/navigation";

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/AlternateLinks.svelte
import { page } from "$app/stores";
import { base as maybe_relative_base } from "$app/paths";
mark_module_start();
AlternateLinks[FILENAME] = "node_modules/@inlang/paraglide-sveltekit/dist/runtime/AlternateLinks.svelte";
var root_2 = add_locations(template(`<link rel="alternate">`), AlternateLinks[FILENAME], [[27, 2]]);
function AlternateLinks($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, AlternateLinks);
  const $$stores = setup_stores();
  const $page = () => (validate_store(page, "page"), store_get(page, "$page", $$stores));
  const localisedPath = mutable_state();
  const canonicalPath = mutable_state();
  const alternateLinks = mutable_state();
  const absoluteBase = normaliseBase(maybe_relative_base, new URL($page().url)) || "/";
  let availableLanguageTags = prop($$props, "availableLanguageTags", 8);
  let strategy = prop($$props, "strategy", 8);
  let currentLang = prop($$props, "currentLang", 8);
  const getAlternateLinks = (canonicalPath2, strategy2) => {
    const links = [];
    for (const lang of availableLanguageTags()) {
      const localisedPath2 = strategy2.getLocalisedPath(canonicalPath2, lang);
      const fullPath = serializeRoute(localisedPath2, absoluteBase, void 0);
      const link = new URL(fullPath, new URL($page().url)).href;
      links.push(link);
    }
    return links;
  };
  legacy_pre_effect(() => (parseRoute, $page()), () => {
    set(localisedPath, parseRoute($page().url.pathname, absoluteBase)[0]);
  });
  legacy_pre_effect(
    () => (deep_read_state(strategy()), get(localisedPath), deep_read_state(currentLang())),
    () => {
      set(canonicalPath, strategy().getCanonicalPath(get(localisedPath), currentLang()));
    }
  );
  legacy_pre_effect(
    () => (get(canonicalPath), deep_read_state(strategy())),
    () => {
      set(alternateLinks, getAlternateLinks(get(canonicalPath), strategy()));
    }
  );
  legacy_pre_effect_reset();
  init();
  var fragment = comment();
  var node = first_child(fragment);
  if_block(node, () => availableLanguageTags().length >= 1, ($$anchor2) => {
    var fragment_1 = comment();
    var node_1 = first_child(fragment_1);
    each(node_1, 1, () => get(alternateLinks), index, ($$anchor3, href, i) => {
      var link_1 = root_2();
      template_effect(() => {
        set_attribute(link_1, "hreflang", availableLanguageTags()[i]);
        set_attribute(link_1, "href", get(href));
      });
      append($$anchor3, link_1);
    });
    append($$anchor2, fragment_1);
  });
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  AlternateLinks = hmr(AlternateLinks, () => AlternateLinks[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = AlternateLinks[HMR].source;
    set(AlternateLinks[HMR].source, module.default[HMR].original);
  });
}
var AlternateLinks_default = AlternateLinks;
mark_module_end(AlternateLinks);

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/cookie.js
var createLangCookie = (lang, path) => `${LANG_COOKIE_NAME}=${lang};Path=${path};SameSite=lax;Max-Age=31557600`;

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte
mark_module_start();
ParaglideJS[FILENAME] = "node_modules/@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte";
function ParaglideJS($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ParaglideJS);
  const $$stores = setup_stores();
  const $page = () => (validate_store(page2, "page"), store_get(page2, "$page", $$stores));
  const lang = mutable_state();
  const langKey = mutable_state();
  const absoluteBase = normaliseBase(maybe_relative_base2, new URL($page().url)) || "/";
  let languageTag = prop($$props, "languageTag", 24, () => void 0);
  let i18n = prop($$props, "i18n", 8);
  let numberOfLanugageChanges = mutable_state(0);
  function translateHref(href, hreflang) {
    try {
      const localisedCurrentUrl = new URL(get2(page2).url);
      const [localisedCurrentPath, suffix] = parseRoute(localisedCurrentUrl.pathname, absoluteBase);
      const canonicalCurrentPath = i18n().strategy.getCanonicalPath(localisedCurrentPath, get(lang));
      const canonicalCurrentUrl = new URL(localisedCurrentUrl);
      canonicalCurrentUrl.pathname = serializeRoute(canonicalCurrentPath, absoluteBase, suffix);
      const original_to = new URL(href, new URL(canonicalCurrentUrl));
      if (isExternal(original_to, localisedCurrentUrl, absoluteBase) || i18n().config.exclude(original_to.pathname)) return href;
      const targetLanguage = hreflang ?? get(lang);
      const [canonicalPath, dataSuffix] = parseRoute(original_to.pathname, absoluteBase);
      const translatedPath = i18n().strategy.getLocalisedPath(canonicalPath, targetLanguage);
      const to = new URL(original_to);
      to.pathname = serializeRoute(translatedPath, absoluteBase, dataSuffix);
      return getHrefBetween(localisedCurrentUrl, to);
    } catch (error) {
      if (dev) console.warn(...log_if_contains_state("warn", `[paraglide-sveltekit] Failed to translate the link "${href}"`));
      return href;
    }
  }
  setParaglideContext({ translateHref });
  legacy_pre_effect(
    () => (deep_read_state(languageTag()), deep_read_state(i18n()), $page()),
    () => {
      set(lang, languageTag() ?? i18n().getLanguageFromUrl($page().url));
    }
  );
  legacy_pre_effect(
    () => (browser, deep_read_state(i18n()), get(lang)),
    () => {
      if (browser) i18n().config.runtime.setLanguageTag(get(lang));
    }
  );
  legacy_pre_effect(() => (browser, get(lang)), () => {
    if (browser) document.documentElement.lang = get(lang);
  });
  legacy_pre_effect(
    () => (browser, deep_read_state(i18n()), get(lang)),
    () => {
      if (browser) document.documentElement.dir = i18n().config.textDirection[get(lang)] ?? "ltr";
    }
  );
  legacy_pre_effect(
    () => (get(lang), get(numberOfLanugageChanges)),
    () => {
      if (get(lang)) set(numberOfLanugageChanges, get(numberOfLanugageChanges) + 1);
    }
  );
  legacy_pre_effect(
    () => (browser, get(lang), get(numberOfLanugageChanges), dev, invalidate, LANGUAGE_CHANGE_INVALIDATION_KEY),
    () => {
      if (browser && get(lang) && (get(numberOfLanugageChanges) > 1 || dev)) invalidate(LANGUAGE_CHANGE_INVALIDATION_KEY);
    }
  );
  legacy_pre_effect(() => get(lang), () => {
    set(langKey, get(lang));
  });
  legacy_pre_effect(() => (browser, createLangCookie, get(lang)), () => {
    if (browser) document.cookie = createLangCookie(get(lang), absoluteBase);
  });
  legacy_pre_effect_reset();
  init();
  var fragment_2 = comment();
  head(($$anchor2) => {
    var fragment = comment();
    var node = first_child(fragment);
    if_block(node, () => strict_equals(i18n().config.seo.noAlternateLinks, true, false) && !i18n().config.exclude($page().url.pathname), ($$anchor3) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      AlternateLinks_default(node_1, {
        get availableLanguageTags() {
          return i18n().config.runtime.availableLanguageTags;
        },
        get strategy() {
          return i18n().strategy;
        },
        get currentLang() {
          return get(lang);
        }
      });
      append($$anchor3, fragment_1);
    });
    append($$anchor2, fragment);
  });
  var node_2 = first_child(fragment_2);
  key_block(node_2, () => get(langKey), ($$anchor2) => {
    var fragment_3 = comment();
    var node_3 = first_child(fragment_3);
    slot(node_3, $$props, "default", {}, null);
    append($$anchor2, fragment_3);
  });
  append($$anchor, fragment_2);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ParaglideJS = hmr(ParaglideJS, () => ParaglideJS[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ParaglideJS[HMR].source;
    set(ParaglideJS[HMR].source, module.default[HMR].original);
  });
}
var ParaglideJS_default = ParaglideJS;
mark_module_end(ParaglideJS);

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/hooks/reroute.js
import { base } from "$app/paths";
import { dev as dev2 } from "$app/environment";
var createReroute = (strategy) => {
  return ({ url }) => {
    try {
      const [localisedPath, dataSuffix] = parseRoute(url.pathname, base);
      const lang = strategy.getLanguageFromLocalisedPath(localisedPath);
      if (!lang)
        return url.pathname;
      const canonicalPath = strategy.getCanonicalPath(localisedPath, lang);
      return serializeRoute(canonicalPath, base, dataSuffix);
    } catch (e) {
      if (dev2)
        console.error("[@inlang/paraglide-sveltekit] Error thrown during reroute", e);
      return url.pathname;
    }
  };
};

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/adapter.client.js
import { base as base2 } from "$app/paths";
import { page as page3 } from "$app/stores";
import { dev as dev3 } from "$app/environment";

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/path.js
function normalize(path) {
  return `/${path.split("/").filter(Boolean).join("/")}`;
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/exclude.js
function createExclude(excludeConfig) {
  const checks = excludeConfig.map((exclude) => typeof exclude === "string" ? (path) => path === exclude : (path) => exclude.test(path));
  return (path) => checks.some((check) => check(normalize(path)));
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/utils/text-dir.js
var RTL = "rtl";
var LTR = "ltr";
function guessTextDir(lang) {
  try {
    const locale = new Intl.Locale(lang);
    if ("textInfo" in locale) {
      return locale.textInfo.direction === RTL ? RTL : LTR;
    }
    return locale.getTextInfo().direction === RTL ? RTL : LTR;
  } catch (e) {
    return LTR;
  }
}
function guessTextDirMap(langs) {
  const entries = langs.map((lang) => [lang, guessTextDir(lang)]);
  return Object.fromEntries(entries);
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/strategy.js
function PrefixStrategy(availableLanguageTags, defaultLanguageTag, translations, matchers, prefixDefaultLanguage) {
  function getLanguageFromLocalisedPath(localisedPath) {
    const segments = localisedPath.split("/");
    const maybeLang = segments[1];
    if (availableLanguageTags.includes(maybeLang) && (prefixDefaultLanguage === "always" || maybeLang !== defaultLanguageTag)) {
      return maybeLang;
    }
    if (prefixDefaultLanguage === "never")
      return defaultLanguageTag;
    else
      return void 0;
  }
  function getLocalisedPath(canonicalPath, languageTag) {
    const trailingSlash = canonicalPath.endsWith("/") && canonicalPath !== "/";
    canonicalPath = trailingSlash ? canonicalPath.slice(0, -1) : canonicalPath;
    let translatedPath = turnIntoTranslatedPath(canonicalPath, languageTag, translations, matchers);
    if (trailingSlash) {
      translatedPath += "/";
    }
    if (prefixDefaultLanguage === "always" || languageTag !== defaultLanguageTag) {
      translatedPath = `/${languageTag}${translatedPath}`;
    }
    return translatedPath;
  }
  function getCanonicalPath(localisedPath, languageTag) {
    const trailingSlahsBefore = localisedPath.endsWith("/") && localisedPath !== "/";
    if (prefixDefaultLanguage === "always" || languageTag !== defaultLanguageTag) {
      localisedPath = localisedPath.replace(`/${languageTag}`, "") || "/";
    }
    const trailingSlash = trailingSlahsBefore;
    localisedPath = trailingSlash ? localisedPath.slice(0, -1) : localisedPath;
    let canonicalPath = turnIntoCanonicalPath(localisedPath, languageTag, translations, matchers);
    if (trailingSlash) {
      canonicalPath += "/";
    }
    return canonicalPath;
  }
  return {
    getLanguageFromLocalisedPath,
    getLocalisedPath,
    getCanonicalPath
  };
}
function turnIntoCanonicalPath(translatedPath, lang, translations, matchers) {
  for (const [canonicalPathDefinition, translationsForPath] of Object.entries(translations)) {
    if (!(lang in translationsForPath))
      continue;
    const translatedPathDefinition = translationsForPath[lang];
    if (!translatedPathDefinition)
      continue;
    const match = bestMatch(translatedPath, [translatedPathDefinition], matchers);
    if (!match)
      continue;
    return resolveRoute(canonicalPathDefinition, match.params);
  }
  return translatedPath;
}
function turnIntoTranslatedPath(canonicalPath, lang, translations, matchers) {
  const match = bestMatch(canonicalPath, Object.keys(translations), matchers);
  if (!match)
    return canonicalPath;
  const translationsForPath = translations[match.id];
  if (!translationsForPath)
    return canonicalPath;
  const translatedPath = translationsForPath[lang];
  if (!translatedPath)
    return canonicalPath;
  return resolveRoute(translatedPath, match.params);
}

// node_modules/@inlang/paraglide-sveltekit/dist/runtime/adapter.client.js
function createI18n(runtime, options) {
  var _a;
  const translations = (options == null ? void 0 : options.pathnames) ? resolveUserPathDefinitions(options.pathnames, runtime.availableLanguageTags) : {};
  if (dev3) {
    const issues = validatePathTranslations(translations, runtime.availableLanguageTags, (options == null ? void 0 : options.matchers) ?? {});
    if (issues.length)
      prettyPrintPathDefinitionIssues(issues);
  }
  const excludeConfig = (options == null ? void 0 : options.exclude) ?? [];
  const defaultLanguageTag = (options == null ? void 0 : options.defaultLanguageTag) ?? runtime.sourceLanguageTag;
  const config = {
    defaultLanguageTag,
    runtime,
    translations,
    matchers: (options == null ? void 0 : options.matchers) ?? {},
    exclude: createExclude(excludeConfig),
    prefixDefaultLanguage: (options == null ? void 0 : options.prefixDefaultLanguage) ?? "never",
    textDirection: (options == null ? void 0 : options.textDirection) ?? guessTextDirMap(runtime.availableLanguageTags),
    seo: {
      noAlternateLinks: ((_a = options == null ? void 0 : options.seo) == null ? void 0 : _a.noAlternateLinks) ?? false
    }
  };
  const strategy = PrefixStrategy(runtime.availableLanguageTags, defaultLanguageTag, config.translations, config.matchers, config.prefixDefaultLanguage);
  Object.freeze(translations);
  Object.freeze(config);
  return {
    /**
     * The configuration that was used to create this i18n instance.
     */
    config,
    /**
     * The routing strategy that's being used.
     *
     * @private Not part of the public API, may change in non-major versions
     */
    strategy,
    /**
     * Returns a `reroute` hook that applies the path translations to the paths.
     * Register it in your `src/hooks.js` file to enable path translations.
     *
     * @example
     * ```ts
     * // src/hooks.js
     * import { i18n } from "../lib/i18n.js"
     * export const reroute = i18n.reroute()
     * ```
     */
    reroute: () => createReroute(strategy),
    /**
     * Returns a `handle` hook that set's the correct `lang` attribute
     * on the `html` element
     *
     * SERVER ONLY
     */
    handle: () => {
      throw new Error(dev3 ? "`i18n.handle` hook should only be used on the server." : "");
    },
    /**
     * Takes in a URL and returns the language that should be used for it.
     *
     * @param url
     * @returns
     */
    getLanguageFromUrl(url) {
      const normalizedBase = normaliseBase2(base2);
      const [localizedPath] = parseRoute(url.pathname, normalizedBase);
      if (config.exclude(localizedPath))
        return config.defaultLanguageTag;
      return strategy.getLanguageFromLocalisedPath(localizedPath) || config.defaultLanguageTag;
    },
    /**
     * Takes in a route and returns a translated version of it.
     * This is useful for use in `goto` statements and `redirect` calls.
     *
     * The oposite of `i18n.route()`.
     *
     * @param canonicalPath The path to translate (eg _/base/about_)
     * @param lang The language to translate to - Defaults to the current language
     * @returns The translated path (eg _/base/de/ueber-uns_)
     *
     * @example
     * ```ts
     * redirect(i18n.resolveRoute("/base/about", "de"))
     * ```
     */
    resolveRoute(path, lang = void 0) {
      if (config.exclude(path))
        return path;
      const normalizedBase = normaliseBase2(base2);
      const [canonicalPath, dataSuffix] = parseRoute(path, normalizedBase);
      lang = lang ?? runtime.languageTag();
      if (!path.startsWith(normalizedBase))
        return path;
      const localisedPath = strategy.getLocalisedPath(canonicalPath, lang);
      return serializeRoute(localisedPath, normalizedBase, dataSuffix);
    },
    /**
     * Takes in a path in one language and returns it's canonical version.
     * The oposite of `i18n.resolveRoute()`.
     * This is useful for use in:
     * - Language Switchers
     * - Navigation
     *
     * @param targetedPathSource The path to translate (eg _/base/de/ueber-uns_)
     * @returns The canonical version path (eg _/base/about_)
     *
     * @example
     * ```ts
     * <a
     *   href={i18n.route($page.url.pathname)}
     *   hreflang="en"
     * >
     * ```
     */
    route(translatedPath) {
      const normalizedBase = normaliseBase2(base2);
      const [localisedPath, dataSuffix] = parseRoute(translatedPath, normalizedBase);
      const lang = strategy.getLanguageFromLocalisedPath(localisedPath);
      const languageTag = lang || config.defaultLanguageTag;
      const canonicalPath = strategy.getCanonicalPath(localisedPath, languageTag);
      return serializeRoute(canonicalPath, normalizedBase, dataSuffix);
    }
  };
}
function normaliseBase2(base3) {
  if (base3 === "")
    return "";
  if (base3.startsWith("/"))
    return base3;
  return normaliseBase(base3, new URL(get2(page3).url));
}
export {
  ParaglideJS_default as ParaglideJS,
  createI18n
};
//# sourceMappingURL=@inlang_paraglide-sveltekit.js.map
