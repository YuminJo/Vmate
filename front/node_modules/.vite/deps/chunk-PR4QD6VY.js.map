{
  "version": 3,
  "sources": ["../../@inlang/paraglide-js/dist/adapter-utils/index.js"],
  "sourcesContent": ["function negotiateLanguagePreferences(accept, availableLanguageTags) {\n  accept ||= \"*\";\n  const acceptLanguageSpecs = parseAcceptLanguageHeader(accept);\n  const priorities = availableLanguageTags.map(\n    (languageTag, index) => getHighestLanguagePriority(languageTag, acceptLanguageSpecs, index)\n  );\n  return priorities.filter((prio) => prio.quality > 0).sort(bySpecificity).sort(byQuality).map((priority) => priority.languageTag);\n}\nfunction parseAcceptLanguageHeader(acceptLanguage) {\n  return acceptLanguage.split(\",\").map((dfn) => dfn.trim()).map((dfn, index) => parseLanguage(dfn, index)).filter((maybeSpec) => Boolean(maybeSpec));\n}\nfunction parseLanguage(languageTag, index) {\n  const LANGUAGE_REGEXP = /^\\s*([^\\s\\-;]+)(?:-([^\\s;]+))?\\s*(?:;(.*))?$/;\n  const match = LANGUAGE_REGEXP.exec(languageTag);\n  if (!match)\n    return void 0;\n  const [, prefix, suffix, qualityMatch] = match;\n  if (!prefix)\n    throw new Error(`Invalid language tag: ${languageTag}`);\n  const full = suffix ? `${prefix}-${suffix}` : prefix;\n  const quality = parseQuality(qualityMatch ?? \"\") ?? 1;\n  return {\n    prefix,\n    suffix,\n    quality,\n    index,\n    full\n  };\n}\nfunction parseQuality(qualityMatch) {\n  return qualityMatch.split(\";\").map((param) => param.split(\"=\")).filter((p) => p[0] == \"q\" && !!p[1]).map(([, value]) => parseFloat(value))[0];\n}\nfunction getHighestLanguagePriority(languageTag, acceptableLanguages, index) {\n  const priorities = acceptableLanguages.map((spec) => calculatePriority(languageTag, spec, index)).filter((prio) => Boolean(prio));\n  const highestPriority = priorities.sort(bySpecificity)[0] || {\n    languageTag,\n    index: 0,\n    order: -1,\n    quality: 0,\n    specificity: 0\n  };\n  return highestPriority;\n}\nfunction calculatePriority(languageTag, spec, index) {\n  const parsed = parseLanguage(languageTag, 0);\n  if (!parsed)\n    return void 0;\n  let specificity = 0;\n  if (spec.full.toLowerCase() === parsed.full.toLowerCase()) {\n    specificity = 4;\n  } else if (spec.prefix.toLowerCase() === parsed.full.toLowerCase()) {\n    specificity = 2;\n  } else if (spec.full.toLowerCase() === parsed.prefix.toLowerCase()) {\n    specificity = 1;\n  }\n  if (specificity === 0 && spec.full !== \"*\")\n    return void 0;\n  return {\n    languageTag,\n    index,\n    order: spec.index,\n    quality: spec.quality,\n    specificity\n  };\n}\nconst byQuality = (a, b) => b.quality - a.quality;\nconst bySpecificity = (a, b) => b.specificity - a.specificity || a.order - b.order || a.index - b.index;\nfunction detectLanguageFromPath({\n  path,\n  availableLanguageTags,\n  base\n}) {\n  base ??= \"\";\n  if (base === \"/\")\n    base = \"\";\n  if (!path.startsWith(base))\n    return void 0;\n  const pathWithoutBase = path.replace(base, \"\");\n  const maybeLang = pathWithoutBase.split(\"/\")[1];\n  if (!maybeLang)\n    return void 0;\n  return availableLanguageTags.map(lower).includes(lower(maybeLang)) ? maybeLang : void 0;\n}\nconst lower = (s) => s.toLowerCase();\nconst STATIC = 0;\nconst OPTIONAL = 1;\nconst REST = 2;\nconst REQUIRED = 4;\nconst PART_TYPE = 0;\nconst PART_CONTENT = 1;\nconst PART_MATCHED = 2;\nfunction sort_routes(routes) {\n  const get_parts = cached(split);\n  return routes.sort((route_a, route_b) => {\n    var _a, _b, _c, _d, _e, _f;\n    const segments_a = split_route_id(route_a).map(get_parts);\n    const segments_b = split_route_id(route_b).map(get_parts);\n    for (let i = 0; i < Math.max(segments_a.length, segments_b.length); i += 1) {\n      const segment_a = segments_a[i];\n      const segment_b = segments_b[i];\n      if (!segment_a)\n        return -1;\n      if (!segment_b)\n        return 1;\n      for (let j = 0; j < Math.max(segment_a.length, segment_b.length); j += 1) {\n        const a = segment_a[j];\n        const b = segment_b[j];\n        const dynamic = (a == null ? void 0 : a[PART_TYPE]) || (b == null ? void 0 : b[PART_TYPE]);\n        if (dynamic) {\n          if (!a)\n            return -1;\n          if (!b)\n            return 1;\n          const next_a = ((_a = segment_a[j + 1]) == null ? void 0 : _a[PART_CONTENT]) || ((_c = (_b = segments_a[i + 1]) == null ? void 0 : _b[0]) == null ? void 0 : _c[PART_CONTENT]);\n          const next_b = ((_d = segment_b[j + 1]) == null ? void 0 : _d[PART_CONTENT]) || ((_f = (_e = segments_b[i + 1]) == null ? void 0 : _e[0]) == null ? void 0 : _f[PART_CONTENT]);\n          const both_have_next = next_a && next_b;\n          const only_a_has_next = next_a && !next_b;\n          const only_b_has_next = !next_a && next_b;\n          if ((a[PART_TYPE] && b[PART_TYPE]) === REST) {\n            if (both_have_next)\n              continue;\n            if (only_a_has_next)\n              return -1;\n            if (only_b_has_next)\n              return 1;\n          }\n          if (a[PART_TYPE] === REST)\n            return only_a_has_next ? -1 : 1;\n          if (b[PART_TYPE] === REST)\n            return only_b_has_next ? 1 : -1;\n          if (a[PART_MATCHED] !== b[PART_MATCHED])\n            return (-1) ** +a[PART_MATCHED];\n          if (a[PART_TYPE] !== b[PART_TYPE]) {\n            return (-1) ** +(a[PART_TYPE] > b[PART_TYPE]);\n          }\n        } else if ((a == null ? void 0 : a[PART_CONTENT]) !== (b == null ? void 0 : b[PART_CONTENT])) {\n          return sort_static(a[PART_CONTENT], b[PART_CONTENT]);\n        }\n      }\n    }\n    return route_a < route_b ? 1 : -1;\n  });\n}\nfunction cached(fn) {\n  const cache = /* @__PURE__ */ new Map();\n  return (arg) => {\n    if (!cache.has(arg))\n      cache.set(arg, fn(arg));\n    return cache.get(arg);\n  };\n}\nfunction split(id) {\n  const parts = [];\n  let i = 0;\n  while (i <= id.length) {\n    const start = id.indexOf(\"[\", i);\n    const entirelyStatic = start === -1;\n    parts.push([STATIC, id.slice(i, entirelyStatic ? void 0 : start), false]);\n    if (entirelyStatic)\n      break;\n    const type = id[start + 1] === \"[\" ? OPTIONAL : id[start + 1] === \".\" ? REST : REQUIRED;\n    const endBrackets = type === OPTIONAL ? \"]]\" : \"]\";\n    const endBracketIdx = id.indexOf(endBrackets, start);\n    if (endBracketIdx === -1)\n      throw new Error(`Invalid route definition ${id}`);\n    const content = id.slice(start, i = endBracketIdx + endBrackets.length);\n    parts.push([type, content, content.includes(\"=\")]);\n  }\n  return parts;\n}\nconst split_route_id = (id) => id.replace(/\\[\\[[^\\]]+\\]\\](?!$)/g, \"\").split(\"/\").filter(Boolean);\nfunction sort_static(a, b) {\n  if (a === b)\n    return 0;\n  let idx = 0;\n  while (a[idx] === b[idx])\n    idx++;\n  return !a[idx] ? 1 : !b[idx] ? -1 : a[idx] < b[idx] ? -1 : 1;\n}\nconst param_pattern = /^(\\[)?(\\.\\.\\.)?(\\w+)(?:=(\\w+))?(\\])?$/;\nfunction parseRouteDefinition(id) {\n  const params = [];\n  const pattern = id === \"/\" ? /^\\/$/ : new RegExp(\n    `^${get_route_segments(id).map((segment) => {\n      const rest_match = /^\\[\\.\\.\\.(\\w+)(?:=(\\w+))?\\]$/.exec(segment);\n      if (rest_match) {\n        params.push({\n          name: rest_match[1],\n          matcher: rest_match[2],\n          optional: false,\n          rest: true,\n          chained: true\n        });\n        return \"(?:/(.*))?\";\n      }\n      const optional_match = /^\\[\\[(\\w+)(?:=(\\w+))?\\]\\]$/.exec(segment);\n      if (optional_match) {\n        params.push({\n          name: optional_match[1],\n          matcher: optional_match[2],\n          optional: true,\n          rest: false,\n          chained: true\n        });\n        return \"(?:/([^/]+))?\";\n      }\n      if (!segment) {\n        return;\n      }\n      const parts = segment.split(/\\[(.+?)\\](?!\\])/);\n      const result = parts.map((content, i) => {\n        if (i % 2) {\n          if (content.startsWith(\"x+\")) {\n            return escape(String.fromCharCode(parseInt(content.slice(2), 16)));\n          }\n          if (content.startsWith(\"u+\")) {\n            return escape(\n              String.fromCharCode(\n                ...content.slice(2).split(\"-\").map((code) => parseInt(code, 16))\n              )\n            );\n          }\n          const match = (\n            /** @type {RegExpExecArray} */\n            param_pattern.exec(content)\n          );\n          if (!match) {\n            throw new Error(`Invalid param: ${content}`);\n          }\n          const [, is_optional, is_rest, name, matcher] = match;\n          params.push({\n            name,\n            matcher,\n            optional: !!is_optional,\n            rest: !!is_rest,\n            chained: is_rest ? i === 1 && parts[0] === \"\" : false\n          });\n          return is_rest ? \"(.*?)\" : is_optional ? \"([^/]*)?\" : \"([^/]+?)\";\n        }\n        return escape(content);\n      }).join(\"\");\n      return \"/\" + result;\n    }).join(\"\")}/?$`\n  );\n  return { pattern, params };\n}\nfunction exec(match, params, matchers) {\n  const result = {};\n  const values = match.slice(1);\n  const values_needing_match = values.filter((v) => v !== void 0);\n  let buffered = 0;\n  for (const [i, param] of params.entries()) {\n    let value = values[i - buffered];\n    if (param.chained && param.rest && buffered) {\n      value = values.slice(i - buffered, i + 1).filter((s) => s).join(\"/\");\n      buffered = 0;\n    }\n    if (value === void 0) {\n      if (param.rest)\n        result[param.name] = \"\";\n      continue;\n    }\n    if (param.matcher && !matchers[param.matcher])\n      return void 0;\n    const matcher = matchers[param.matcher] ?? (() => true);\n    if (matcher(value)) {\n      result[param.name] = value;\n      const next_param = params[i + 1];\n      const next_value = values[i + 1];\n      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {\n        buffered = 0;\n      }\n      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {\n        buffered = 0;\n      }\n      continue;\n    }\n    if (param.optional && param.chained) {\n      buffered++;\n      continue;\n    }\n    return;\n  }\n  if (buffered)\n    return;\n  return result;\n}\nfunction escape(str) {\n  return str.normalize().replace(/[[\\]]/g, \"\\\\$&\").replace(/%/g, \"%25\").replace(/\\//g, \"%2[Ff]\").replace(/\\?/g, \"%3[Ff]\").replace(/#/g, \"%23\").replace(/[.*+?^${}()|\\\\]/g, \"\\\\$&\");\n}\nconst basic_param_pattern = /\\[(\\[)?(\\.\\.\\.)?(\\w+?)(?:=(\\w+))?\\]\\]?/g;\nfunction resolveRoute(id, params) {\n  return \"/\" + get_route_segments(id).map(\n    (segment) => segment.replace(basic_param_pattern, (_, optional, rest, name) => {\n      const param_value = params[name];\n      if (!param_value) {\n        if (optional || rest && param_value !== void 0)\n          return \"\";\n        else\n          throw new Error(`Missing parameter '${name}' in route ${id}`);\n      }\n      if (param_value[0] == \"/\" || param_value.endsWith(\"/\"))\n        throw new Error(`Parameter '${name}' in route ${id} cannot start or end with a slash`);\n      return param_value;\n    })\n  ).filter(Boolean).join(\"/\");\n}\nfunction bestMatch(canonicalPath, pathDefinitions, matchers) {\n  const sorted = sort_routes(pathDefinitions);\n  for (const pathDefinition of sorted) {\n    const route = parseRouteDefinition(pathDefinition);\n    const match = route.pattern.exec(removeTrailingSlash(canonicalPath));\n    if (!match)\n      continue;\n    const params = exec(match, route.params, matchers);\n    if (params)\n      return { params, id: pathDefinition };\n  }\n  return void 0;\n}\nconst removeTrailingSlash = (path) => path.endsWith(\"/\") ? path.slice(0, -1) : path;\nconst get_route_segments = (route) => route.slice(1).split(\"/\");\nfunction validatePathTranslations(pathTranslations, availableLanguageTags, matchers) {\n  const issues = [];\n  const expectedLanguages = new Set(availableLanguageTags);\n  const availableMatchers = new Set(Object.keys(matchers));\n  for (const path in pathTranslations) {\n    if (!isValidPath(path)) {\n      issues.push({\n        path,\n        message: \"Path must start with a slash.\"\n      });\n      continue;\n    }\n    const { params: expectedParams } = parseRouteDefinition(path);\n    const expectedMatchers = expectedParams.map((param) => param.matcher).filter(Boolean);\n    for (const matcher of expectedMatchers) {\n      if (!availableMatchers.has(matcher)) {\n        issues.push({\n          path,\n          message: `Matcher ${matcher} is used but not available. Did you forget to pass it to createI18n?`\n        });\n      }\n    }\n    const translations = pathTranslations[path];\n    if (!translations)\n      continue;\n    for (const [lang, translatedPath] of Object.entries(translations)) {\n      if (!isValidPath(translatedPath)) {\n        issues.push({\n          path,\n          message: `The translation for language ${lang} must start with a slash.`\n        });\n      }\n      const { params: actualParams } = parseRouteDefinition(translatedPath);\n      let paramsDontMatch = false;\n      for (const param of expectedParams) {\n        if (!actualParams.some((actualParam) => paramsAreEqual(param, actualParam))) {\n          paramsDontMatch = true;\n        }\n      }\n      if (expectedParams.length !== actualParams.length) {\n        paramsDontMatch = true;\n      }\n      if (paramsDontMatch) {\n        issues.push({\n          path,\n          message: `The translation for language ${lang} must have the same parameters as the canonical path.`\n        });\n      }\n    }\n    const translatedLanguages = new Set(Object.keys(translations));\n    if (!isSubset(expectedLanguages, translatedLanguages)) {\n      const missingLanguages = new Set(expectedLanguages);\n      for (const lang of translatedLanguages) {\n        missingLanguages.delete(lang);\n      }\n      issues.push({\n        path,\n        message: `The following languages are missing translations: ${[...missingLanguages].join(\n          \", \"\n        )}`\n      });\n    }\n  }\n  return issues;\n}\nfunction paramsAreEqual(param1, param2) {\n  return param1.chained == param2.chained && param1.matcher == param2.matcher && param1.name == param2.name && param1.optional == param2.optional && param1.rest == param2.rest;\n}\nfunction isValidPath(maybePath) {\n  return maybePath.startsWith(\"/\");\n}\nfunction isSubset(a, b) {\n  for (const value of a) {\n    if (!b.has(value))\n      return false;\n  }\n  return true;\n}\nfunction prettyPrintPathDefinitionIssues(issues) {\n  return issues.map((issue) => `${issue.path}: ${issue.message}`).join(\"\\n\");\n}\nconst resolveUserPathDefinitions = (userTranslations, availableLanguageTags) => Object.fromEntries(\n  Object.entries(userTranslations).map(([path, translation]) => [\n    path,\n    typeof translation === \"object\" ? translation : fromMessage(translation, availableLanguageTags)\n  ])\n);\nconst fromMessage = (message, availableLanguageTags) => Object.fromEntries(\n  availableLanguageTags.map((languageTag) => [languageTag, message({}, { languageTag })])\n);\nexport {\n  bestMatch,\n  detectLanguageFromPath,\n  negotiateLanguagePreferences,\n  parseRouteDefinition,\n  prettyPrintPathDefinitionIssues,\n  resolveRoute,\n  resolveUserPathDefinitions,\n  validatePathTranslations\n};\n"],
  "mappings": "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",
  "names": []
}
