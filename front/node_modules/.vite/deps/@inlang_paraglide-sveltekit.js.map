{
  "version": 3,
  "sources": ["../../@inlang/paraglide-sveltekit/dist/runtime/ParaglideJS.svelte", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/normaliseBase.js", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/route.js", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/diff-urls.js", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/external.js", "../../@inlang/paraglide-sveltekit/dist/runtime/AlternateLinks.svelte", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/cookie.js", "../../@inlang/paraglide-sveltekit/dist/runtime/hooks/reroute.js", "../../@inlang/paraglide-sveltekit/dist/runtime/adapter.client.js", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/path.js", "../../@inlang/paraglide-sveltekit/dist/runtime/exclude.js", "../../@inlang/paraglide-sveltekit/dist/runtime/utils/text-dir.js", "../../@inlang/paraglide-sveltekit/dist/runtime/strategy.js"],
  "sourcesContent": [null, "/**\n * Normalises SvelteKit's base path value to always be an absolute path - or an empty string.\n *\n * @param baseValue - The { base } value exported from \"$app/paths\"\n * @param currentUrl - The current URL of the page\n */\nexport function normaliseBase(baseValue, currentUrl) {\n    if (baseValue === \"\")\n        return \"\";\n    const absoluteBase = new URL(baseValue, currentUrl).pathname;\n    return (absoluteBase.endsWith(\"/\") ? absoluteBase.slice(0, -1) : absoluteBase);\n}\n", "/**\n * Takes a path and removes the base & data suffix\n *\n * @param fullPath The path to parse, including base & data suffix. Should be absolute\n * @returns A tuple of the path and the data suffix\n */\nexport function parseRoute(fullPath, normalizedBase) {\n    const decodedPath = safeDecode(fullPath);\n    const pathWithoutBase = removeBase(decodedPath, normalizedBase);\n    const [path, dataSuffix] = removeDataSuffix(pathWithoutBase);\n    return [path, dataSuffix];\n}\n/**\n * Adds the base & data suffix back to a path\n *\n * @param path The path to serialize\n * @param base The normalized base path\n * @param dataSuffix The data suffix (if it exists)\n */\nexport const serializeRoute = (path, normalizedBase, dataSuffix) => [normalizedBase, path, dataSuffix ?? \"\"].filter((s) => s !== \"/\").join(\"\") || \"/\";\n/**\n * Removes the base from an absolute path\n * @param absolutePath\n * @param normalizedBase\n * @returns\n */\nfunction removeBase(absolutePath, normalizedBase) {\n    const withoutBase = absolutePath.replace(normalizedBase, \"\");\n    return withoutBase.startsWith(\"/\") ? withoutBase : `/${withoutBase}`;\n}\n/**\n * Removes any known data suffix from the path\n *\n * @param absolutePath The absolute path\n * @returns A tuple of the path and the data suffix\n */\nfunction removeDataSuffix(absolutePath) {\n    /** The path suffix SvelteKit adds on Data requests */\n    const KNOWN_SUFFIXES = [\"/.html__data.json\", \"/__data.json\"];\n    const dataSuffix = KNOWN_SUFFIXES.find((suffix) => absolutePath.endsWith(suffix));\n    if (dataSuffix) {\n        return [(absolutePath.slice(0, -dataSuffix.length) || \"/\"), dataSuffix];\n    }\n    else {\n        return [absolutePath, undefined];\n    }\n}\nfunction safeDecode(maybeEncoded) {\n    try {\n        return decodeURI(maybeEncoded);\n    }\n    catch {\n        return maybeEncoded;\n    }\n}\n", "export const metaUrl = import.meta.url;\n/**\n * Get's the shortest href that gets from `from` to `to`\n *\n * @returns An href that gets from `from` to `to`\n */\nexport function getHrefBetween(from, to) {\n    //check if they use the same protocol - If not, we can't do anything\n    if (from.protocol !== to.protocol) {\n        return to.href;\n    }\n    //If the credentials are included, we always need to include them - so there is no point in diffing further\n    if (to.password || to.username) {\n        const credentials = [to.username, to.password].filter(Boolean).join(\":\");\n        return \"//\" + credentials + \"@\" + to.host + to.pathname + to.search + to.hash;\n    }\n    // host = hostname + port\n    if (from.host !== to.host) {\n        //since they have the same protocol, we can omit the protocol\n        return \"//\" + to.host + to.pathname + to.search + to.hash;\n    }\n    return to.pathname + to.search + to.hash;\n}\n", "export function isExternal(url, currentUrl, base) {\n    const absoluteBase = new URL(base ?? \"/\", currentUrl).pathname;\n    return url.origin !== currentUrl.origin || !url.pathname.startsWith(absoluteBase);\n}\n", null, "import { LANG_COOKIE_NAME } from \"../../constants.js\";\n/**\n * Returns a language cookie string that can be assigned to `document.cookie`.\n *\n * Use this to update the language cookie in the browser.\n *\n * The cookie lasts for 1 year.\n */\nexport const createLangCookie = (lang, path) => `${LANG_COOKIE_NAME}=${lang};Path=${path};SameSite=lax;Max-Age=31557600`;\n", "import { parseRoute, serializeRoute } from \"../utils/route.js\";\nimport { base } from \"$app/paths\";\nimport { dev } from \"$app/environment\";\n/**\n * Returns a reroute function that applies the given translations to the paths\n * @param translations\n */\nexport const createReroute = (strategy) => {\n    return ({ url }) => {\n        try {\n            const [localisedPath, dataSuffix] = parseRoute(url.pathname, base);\n            const lang = strategy.getLanguageFromLocalisedPath(localisedPath);\n            if (!lang)\n                return url.pathname;\n            const canonicalPath = strategy.getCanonicalPath(localisedPath, lang);\n            return serializeRoute(canonicalPath, base, dataSuffix);\n        }\n        catch (e) {\n            if (dev)\n                console.error(\"[@inlang/paraglide-sveltekit] Error thrown during reroute\", e);\n            return url.pathname;\n        }\n    };\n};\n", "import { createReroute } from \"./hooks/reroute.js\";\nimport { base } from \"$app/paths\";\nimport { page } from \"$app/stores\";\nimport { get } from \"svelte/store\";\nimport { dev } from \"$app/environment\";\nimport { parseRoute, serializeRoute } from \"./utils/route.js\";\nimport { normaliseBase as canonicalNormaliseBase, } from \"./utils/normaliseBase.js\";\nimport { createExclude } from \"./exclude.js\";\nimport { guessTextDirMap } from \"./utils/text-dir.js\";\nimport { prettyPrintPathDefinitionIssues, resolveUserPathDefinitions, validatePathTranslations, } from \"@inlang/paraglide-js/internal/adapter-utils\";\nimport { PrefixStrategy } from \"./strategy.js\";\n/**\n * Creates an i18n instance that manages your internationalization.\n *\n * @param runtime The Paraglide runtime.\n * @param options The options for the i18n instance.\n * @returns An i18n instance.\n *\n * @example\n * ```ts\n * // src/lib/i18n.js\n * import * as runtime from \"../paraglide/runtime.js\"\n * import { createI18n } from \"@inlang/paraglide-sveltekit\"\n *\n * export const i18n = createI18n(runtime, { ...options })\n * ```\n */\nexport function createI18n(runtime, options) {\n    const translations = options?.pathnames\n        ? resolveUserPathDefinitions(options.pathnames, runtime.availableLanguageTags)\n        : {};\n    if (dev) {\n        const issues = validatePathTranslations(translations, runtime.availableLanguageTags, options?.matchers ?? {});\n        if (issues.length)\n            prettyPrintPathDefinitionIssues(issues);\n    }\n    const excludeConfig = options?.exclude ?? [];\n    const defaultLanguageTag = options?.defaultLanguageTag ?? runtime.sourceLanguageTag;\n    const config = {\n        defaultLanguageTag,\n        runtime,\n        translations,\n        matchers: options?.matchers ?? {},\n        exclude: createExclude(excludeConfig),\n        prefixDefaultLanguage: options?.prefixDefaultLanguage ?? \"never\",\n        textDirection: options?.textDirection ?? guessTextDirMap(runtime.availableLanguageTags),\n        seo: {\n            noAlternateLinks: options?.seo?.noAlternateLinks ?? false,\n        },\n    };\n    const strategy = PrefixStrategy(runtime.availableLanguageTags, defaultLanguageTag, config.translations, config.matchers, config.prefixDefaultLanguage);\n    // We don't want the translations to be mutable\n    Object.freeze(translations);\n    Object.freeze(config);\n    return {\n        /**\n         * The configuration that was used to create this i18n instance.\n         */\n        config,\n        /**\n         * The routing strategy that's being used.\n         *\n         * @private Not part of the public API, may change in non-major versions\n         */\n        strategy,\n        /**\n         * Returns a `reroute` hook that applies the path translations to the paths.\n         * Register it in your `src/hooks.js` file to enable path translations.\n         *\n         * @example\n         * ```ts\n         * // src/hooks.js\n         * import { i18n } from \"../lib/i18n.js\"\n         * export const reroute = i18n.reroute()\n         * ```\n         */\n        reroute: () => createReroute(strategy),\n        /**\n         * Returns a `handle` hook that set's the correct `lang` attribute\n         * on the `html` element\n         *\n         * SERVER ONLY\n         */\n        handle: () => {\n            throw new Error(dev ? \"`i18n.handle` hook should only be used on the server.\" : \"\");\n        },\n        /**\n         * Takes in a URL and returns the language that should be used for it.\n         *\n         * @param url\n         * @returns\n         */\n        getLanguageFromUrl(url) {\n            const normalizedBase = normaliseBase(base);\n            const [localizedPath] = parseRoute(url.pathname, normalizedBase);\n            if (config.exclude(localizedPath))\n                return config.defaultLanguageTag;\n            return strategy.getLanguageFromLocalisedPath(localizedPath) || config.defaultLanguageTag;\n        },\n        /**\n         * Takes in a route and returns a translated version of it.\n         * This is useful for use in `goto` statements and `redirect` calls.\n         *\n         * The oposite of `i18n.route()`.\n         *\n         * @param canonicalPath The path to translate (eg _/base/about_)\n         * @param lang The language to translate to - Defaults to the current language\n         * @returns The translated path (eg _/base/de/ueber-uns_)\n         *\n         * @example\n         * ```ts\n         * redirect(i18n.resolveRoute(\"/base/about\", \"de\"))\n         * ```\n         */\n        resolveRoute(path, lang = undefined) {\n            if (config.exclude(path))\n                return path;\n            const normalizedBase = normaliseBase(base);\n            const [canonicalPath, dataSuffix] = parseRoute(path, normalizedBase);\n            lang = lang ?? runtime.languageTag();\n            if (!path.startsWith(normalizedBase))\n                return path;\n            const localisedPath = strategy.getLocalisedPath(canonicalPath, lang);\n            return serializeRoute(localisedPath, normalizedBase, dataSuffix);\n        },\n        /**\n         * Takes in a path in one language and returns it's canonical version.\n         * The oposite of `i18n.resolveRoute()`.\n         * This is useful for use in:\n         * - Language Switchers\n         * - Navigation\n         *\n         * @param targetedPathSource The path to translate (eg _/base/de/ueber-uns_)\n         * @returns The canonical version path (eg _/base/about_)\n         *\n         * @example\n         * ```ts\n         * <a\n         *   href={i18n.route($page.url.pathname)}\n         *   hreflang=\"en\"\n         * >\n         * ```\n         */\n        route(translatedPath) {\n            const normalizedBase = normaliseBase(base);\n            const [localisedPath, dataSuffix] = parseRoute(translatedPath, normalizedBase);\n            const lang = strategy.getLanguageFromLocalisedPath(localisedPath);\n            const languageTag = lang || config.defaultLanguageTag;\n            const canonicalPath = strategy.getCanonicalPath(localisedPath, languageTag);\n            return serializeRoute(canonicalPath, normalizedBase, dataSuffix);\n        },\n    };\n}\nfunction normaliseBase(base) {\n    if (base === \"\")\n        return \"\";\n    if (base.startsWith(\"/\"))\n        return base;\n    // this should only be reachable during component initialization\n    // We can detect this, because base is only ever a relative path during component initialization\n    return canonicalNormaliseBase(base, new URL(get(page).url));\n}\n", "/**\n * Always starts with a slash and never ends with a slash.\n */\nexport function normalize(path) {\n    return `/${path.split(\"/\").filter(Boolean).join(\"/\")}`;\n}\n", "import { normalize } from \"./utils/path.js\";\nexport function createExclude(excludeConfig) {\n    const checks = excludeConfig.map((exclude) => typeof exclude === \"string\" ? (path) => path === exclude : (path) => exclude.test(path));\n    return (path) => checks.some((check) => check(normalize(path)));\n}\n", "const RTL = \"rtl\";\nconst LTR = \"ltr\";\nexport function guessTextDir(lang) {\n    // this is super unreliable across browsers, so we expect errors\n    try {\n        const locale = new Intl.Locale(lang);\n        if (\"textInfo\" in locale) {\n            // @ts-ignore - Chrome & Node\n            return locale.textInfo.direction === RTL ? RTL : LTR;\n        }\n        // @ts-ignore - Safari only\n        return locale.getTextInfo().direction === RTL ? RTL : LTR;\n    }\n    catch (e) {\n        //Firefox lmao\n        return LTR;\n    }\n}\nexport function guessTextDirMap(langs) {\n    const entries = langs.map((lang) => [lang, guessTextDir(lang)]);\n    return Object.fromEntries(entries);\n}\n", "import { bestMatch, resolveRoute, } from \"@inlang/paraglide-js/internal/adapter-utils\";\nexport function PrefixStrategy(availableLanguageTags, defaultLanguageTag, translations, matchers, prefixDefaultLanguage) {\n    function getLanguageFromLocalisedPath(localisedPath) {\n        const segments = localisedPath.split(\"/\");\n        const maybeLang = segments[1];\n        if (availableLanguageTags.includes(maybeLang) &&\n            (prefixDefaultLanguage === \"always\" || maybeLang !== defaultLanguageTag)) {\n            return maybeLang;\n        }\n        if (prefixDefaultLanguage === \"never\")\n            return defaultLanguageTag;\n        else\n            return undefined;\n    }\n    function getLocalisedPath(canonicalPath, languageTag) {\n        const trailingSlash = canonicalPath.endsWith(\"/\") && canonicalPath !== \"/\";\n        canonicalPath = trailingSlash ? canonicalPath.slice(0, -1) : canonicalPath;\n        let translatedPath = turnIntoTranslatedPath(canonicalPath, languageTag, translations, matchers);\n        if (trailingSlash) {\n            translatedPath += \"/\";\n        }\n        if (prefixDefaultLanguage === \"always\" || languageTag !== defaultLanguageTag) {\n            translatedPath = `/${languageTag}${translatedPath}`;\n        }\n        return translatedPath;\n    }\n    function getCanonicalPath(localisedPath, languageTag) {\n        const trailingSlahsBefore = localisedPath.endsWith(\"/\") && localisedPath !== \"/\";\n        if (prefixDefaultLanguage === \"always\" || languageTag !== defaultLanguageTag) {\n            localisedPath = localisedPath.replace(`/${languageTag}`, \"\") || \"/\";\n        }\n        const trailingSlash = trailingSlahsBefore;\n        localisedPath = trailingSlash ? localisedPath.slice(0, -1) : localisedPath;\n        let canonicalPath = turnIntoCanonicalPath(localisedPath, languageTag, translations, matchers);\n        if (trailingSlash) {\n            canonicalPath += \"/\";\n        }\n        return canonicalPath;\n    }\n    return {\n        getLanguageFromLocalisedPath,\n        getLocalisedPath,\n        getCanonicalPath,\n    };\n}\n/**\n * Resolves the canonical path from a translated path\n * @param translatedPath The translated path WITHOUT the language or base\n */\nfunction turnIntoCanonicalPath(translatedPath, lang, translations, matchers) {\n    for (const [canonicalPathDefinition, translationsForPath] of Object.entries(translations)) {\n        if (!(lang in translationsForPath))\n            continue;\n        const translatedPathDefinition = translationsForPath[lang];\n        if (!translatedPathDefinition)\n            continue;\n        const match = bestMatch(translatedPath, [translatedPathDefinition], matchers);\n        if (!match)\n            continue;\n        // return the resolved canonical path\n        return resolveRoute(canonicalPathDefinition, match.params);\n    }\n    // fall back to translated path if no canonical path is found\n    return translatedPath;\n}\nfunction turnIntoTranslatedPath(canonicalPath, lang, translations, matchers) {\n    const match = bestMatch(canonicalPath, Object.keys(translations), matchers);\n    if (!match)\n        return canonicalPath;\n    const translationsForPath = translations[match.id];\n    if (!translationsForPath)\n        return canonicalPath;\n    const translatedPath = translationsForPath[lang];\n    if (!translatedPath)\n        return canonicalPath;\n    // return the translated path\n    return resolveRoute(translatedPath, match.params);\n}\n"],
  "mappings": "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",
  "names": ["page", "maybe_relative_base", "base", "$$anchor", "maybe_relative_base", "get", "page", "$$anchor", "dev", "base", "page", "dev", "dev", "normaliseBase", "base", "get", "page"]
}
